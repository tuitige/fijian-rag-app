{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nimport { Amplify, ConsoleLogger as Logger, parseAWSExports } from '@aws-amplify/core';\nimport { AWSS3Provider } from './providers';\nimport { isCancelError } from './AwsClients/S3/utils';\nimport { AWSS3UploadTask } from './providers/AWSS3UploadTask';\nvar logger = new Logger('StorageClass');\nvar loggerStorageInstance = new Logger('Storage'); // Logging relating to Storage instance management\nvar DEFAULT_PROVIDER = 'AWSS3';\n/**\n * Provide storage methods to use AWS S3\n */\nvar Storage = /** @class */function () {\n  /**\n   * Initialize Storage\n   * @param {Object} config - Configuration object for storage\n   */\n  function Storage() {\n    this._config = {};\n    this._pluggables = [];\n    this._abortControllerMap = new WeakMap();\n    logger.debug('Storage Options', this._config);\n    this.get = this.get.bind(this);\n    this.put = this.put.bind(this);\n    this.remove = this.remove.bind(this);\n    this.list = this.list.bind(this);\n  }\n  Storage.prototype.getModuleName = function () {\n    return 'Storage';\n  };\n  /**\n   * add plugin into Storage category\n   * @param {Object} pluggable - an instance of the plugin\n   */\n  Storage.prototype.addPluggable = function (pluggable) {\n    if (pluggable && pluggable.getCategory() === 'Storage') {\n      this._pluggables.push(pluggable);\n      var config = {};\n      config = pluggable.configure(this._config[pluggable.getProviderName()]);\n      return config;\n    }\n  };\n  /**\n   * Get the plugin object\n   * @param providerName - the name of the plugin\n   */\n  Storage.prototype.getPluggable = function (providerName) {\n    var pluggable = this._pluggables.find(function (pluggable) {\n      return pluggable.getProviderName() === providerName;\n    });\n    if (pluggable === undefined) {\n      logger.debug('No plugin found with providerName', providerName);\n      return null;\n    } else return pluggable;\n  };\n  /**\n   * Remove the plugin object\n   * @param providerName - the name of the plugin\n   */\n  Storage.prototype.removePluggable = function (providerName) {\n    this._pluggables = this._pluggables.filter(function (pluggable) {\n      return pluggable.getProviderName() !== providerName;\n    });\n    return;\n  };\n  /**\n   * Configure Storage\n   * @param {Object} config - Configuration object for storage\n   * @return {Object} - Current configuration\n   */\n  Storage.prototype.configure = function (config) {\n    var _this = this;\n    var _a;\n    logger.debug('configure Storage');\n    if (!config) return this._config;\n    var amplifyConfig = parseAWSExports(config);\n    var storageConfig = (_a = amplifyConfig.Storage) !== null && _a !== void 0 ? _a : {};\n    var defaultProviderConfigKeys = ['bucket', 'region', 'level', 'track', 'customPrefix', 'ContentMD5', 'serverSideEncryption', 'SSECustomerAlgorithm', 'SSECustomerKey',\n    // TODO(AllanZhengYP): remove in V6.\n    'SSECustomerKeyMD5', 'SSEKMSKeyId'];\n    var hasDefaultProviderConfigKeys = function (config) {\n      return Object.keys(config).find(function (key) {\n        return defaultProviderConfigKeys.includes(key);\n      });\n    };\n    if (hasDefaultProviderConfigKeys(storageConfig) && !storageConfig[DEFAULT_PROVIDER]) {\n      storageConfig[DEFAULT_PROVIDER] = {};\n    }\n    Object.entries(storageConfig).forEach(function (_a) {\n      var _b = __read(_a, 2),\n        key = _b[0],\n        value = _b[1];\n      if (key && defaultProviderConfigKeys.includes(key) && value !== undefined) {\n        storageConfig[DEFAULT_PROVIDER][key] = value;\n        delete storageConfig[key];\n      }\n    });\n    // only update new values for each provider\n    Object.keys(storageConfig).forEach(function (providerName) {\n      if (typeof storageConfig[providerName] !== 'string') {\n        _this._config[providerName] = __assign(__assign({}, _this._config[providerName]), storageConfig[providerName]);\n      }\n    });\n    this._pluggables.forEach(function (pluggable) {\n      pluggable.configure(_this._config[pluggable.getProviderName()]);\n    });\n    if (this._pluggables.length === 0) {\n      this.addPluggable(new AWSS3Provider());\n    }\n    return this._config;\n  };\n  Storage.prototype.getAbortController = function () {\n    return new AbortController();\n  };\n  Storage.prototype.updateRequestToBeCancellable = function (request, abortController) {\n    this._abortControllerMap.set(request, abortController);\n  };\n  Storage.prototype.isUploadTask = function (x) {\n    return typeof x !== 'undefined' && typeof x['pause'] === 'function' && typeof x['resume'] === 'function';\n  };\n  Storage.prototype.cancel = function (request, message) {\n    if (request instanceof AWSS3UploadTask) {\n      return request._cancel();\n    }\n    var abortController = this._abortControllerMap.get(request);\n    if (abortController) {\n      // TODO: [v6] clean up the aborted promise in the weak map.\n      // Not doing it yet to avoid breaking changes when users may abort a request twice.\n      abortController.abort(message);\n    } else {\n      logger.debug('The request does not map to any cancel token');\n    }\n  };\n  Storage.prototype.copy = function (src, dest, config) {\n    var provider = (config === null || config === void 0 ? void 0 : config.provider) || DEFAULT_PROVIDER;\n    var plugin = this._pluggables.find(function (pluggable) {\n      return pluggable.getProviderName() === provider;\n    });\n    if (plugin === undefined) {\n      logger.debug('No plugin found with providerName', provider);\n      return Promise.reject('No plugin found in Storage for the provider');\n    }\n    var abortController = this.getAbortController();\n    if (typeof plugin.copy !== 'function') {\n      return Promise.reject(\".copy is not implemented on provider \".concat(plugin.getProviderName()));\n    }\n    var responsePromise = plugin.copy(src, dest, __assign(__assign({}, config), {\n      abortSignal: abortController.signal\n    }));\n    this.updateRequestToBeCancellable(responsePromise, abortController);\n    return responsePromise;\n  };\n  Storage.prototype.get = function (key, config) {\n    var provider = (config === null || config === void 0 ? void 0 : config.provider) || DEFAULT_PROVIDER;\n    var plugin = this._pluggables.find(function (pluggable) {\n      return pluggable.getProviderName() === provider;\n    });\n    if (plugin === undefined) {\n      logger.debug('No plugin found with providerName', provider);\n      return Promise.reject('No plugin found in Storage for the provider');\n    }\n    var abortController = this.getAbortController();\n    var responsePromise = plugin.get(key, __assign(__assign({}, config), {\n      abortSignal: abortController.signal\n    }));\n    this.updateRequestToBeCancellable(responsePromise, abortController);\n    return responsePromise;\n  };\n  Storage.prototype.isCancelError = function (error) {\n    return isCancelError(error);\n  };\n  Storage.prototype.getProperties = function (key, config) {\n    var provider = (config === null || config === void 0 ? void 0 : config.provider) || DEFAULT_PROVIDER;\n    var plugin = this._pluggables.find(function (pluggable) {\n      return pluggable.getProviderName() === provider;\n    });\n    if (plugin === undefined) {\n      logger.debug('No plugin found with providerName', provider);\n      throw new Error('No plugin found with providerName');\n    }\n    var abortController = this.getAbortController();\n    if (typeof plugin.getProperties !== 'function') {\n      return Promise.reject(\".getProperties is not implemented on provider \".concat(plugin.getProviderName()));\n    }\n    var responsePromise = plugin === null || plugin === void 0 ? void 0 : plugin.getProperties(key, __assign({}, config));\n    this.updateRequestToBeCancellable(responsePromise, abortController);\n    return responsePromise;\n  };\n  Storage.prototype.put = function (key, object, config) {\n    var provider = (config === null || config === void 0 ? void 0 : config.provider) || DEFAULT_PROVIDER;\n    var plugin = this._pluggables.find(function (pluggable) {\n      return pluggable.getProviderName() === provider;\n    });\n    if (plugin === undefined) {\n      logger.debug('No plugin found with providerName', provider);\n      return Promise.reject('No plugin found in Storage for the provider');\n    }\n    var abortController = this.getAbortController();\n    var response = plugin.put(key, object, __assign(__assign({}, config), {\n      abortSignal: abortController.signal\n    }));\n    if (!this.isUploadTask(response)) {\n      this.updateRequestToBeCancellable(response, abortController);\n    }\n    return response;\n  };\n  Storage.prototype.remove = function (key, config) {\n    var provider = (config === null || config === void 0 ? void 0 : config.provider) || DEFAULT_PROVIDER;\n    var plugin = this._pluggables.find(function (pluggable) {\n      return pluggable.getProviderName() === provider;\n    });\n    if (plugin === undefined) {\n      logger.debug('No plugin found with providerName', provider);\n      return Promise.reject('No plugin found in Storage for the provider');\n    }\n    return plugin.remove(key, config);\n  };\n  Storage.prototype.list = function (path, config) {\n    var provider = (config === null || config === void 0 ? void 0 : config.provider) || DEFAULT_PROVIDER;\n    var plugin = this._pluggables.find(function (pluggable) {\n      return pluggable.getProviderName() === provider;\n    });\n    if (plugin === undefined) {\n      logger.debug('No plugin found with providerName', provider);\n      return Promise.reject('No plugin found in Storage for the provider');\n    }\n    return plugin.list(path, config);\n  };\n  return Storage;\n}();\nexport { Storage };\n/**\n * Configure & register Storage singleton instance.\n */\nvar _instance = null;\nvar getInstance = function () {\n  if (_instance) {\n    return _instance;\n  }\n  loggerStorageInstance.debug('Create Storage Instance, debug');\n  _instance = new Storage();\n  _instance.vault = new Storage();\n  var old_configure = _instance.configure;\n  _instance.configure = function (options) {\n    loggerStorageInstance.debug('storage configure called');\n    var vaultConfig = __assign({}, old_configure.call(_instance, options));\n    // set level private for each provider for the vault\n    Object.keys(vaultConfig).forEach(function (providerName) {\n      if (typeof vaultConfig[providerName] !== 'string') {\n        vaultConfig[providerName] = __assign(__assign({}, vaultConfig[providerName]), {\n          level: 'private'\n        });\n      }\n    });\n    loggerStorageInstance.debug('storage vault configure called');\n    _instance.vault.configure(vaultConfig);\n  };\n  return _instance;\n};\nexport var StorageInstance = getInstance();\nAmplify.register(StorageInstance);","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}