{"ast":null,"code":"var cookie = {};\n\n/*!\n * cookie\n * Copyright(c) 2012-2014 Roman Shtylman\n * Copyright(c) 2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\nvar hasRequiredCookie;\nfunction requireCookie() {\n  if (hasRequiredCookie) return cookie;\n  hasRequiredCookie = 1;\n\n  /**\n   * Module exports.\n   * @public\n   */\n\n  cookie.parse = parse;\n  cookie.serialize = serialize;\n\n  /**\n   * Module variables.\n   * @private\n   */\n\n  var __toString = Object.prototype.toString;\n  var __hasOwnProperty = Object.prototype.hasOwnProperty;\n\n  /**\n   * RegExp to match cookie-name in RFC 6265 sec 4.1.1\n   * This refers out to the obsoleted definition of token in RFC 2616 sec 2.2\n   * which has been replaced by the token definition in RFC 7230 appendix B.\n   *\n   * cookie-name       = token\n   * token             = 1*tchar\n   * tchar             = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" /\n   *                     \"*\" / \"+\" / \"-\" / \".\" / \"^\" / \"_\" /\n   *                     \"`\" / \"|\" / \"~\" / DIGIT / ALPHA\n   */\n\n  var cookieNameRegExp = /^[!#$%&'*+\\-.^_`|~0-9A-Za-z]+$/;\n\n  /**\n   * RegExp to match cookie-value in RFC 6265 sec 4.1.1\n   *\n   * cookie-value      = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE )\n   * cookie-octet      = %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E\n   *                     ; US-ASCII characters excluding CTLs,\n   *                     ; whitespace DQUOTE, comma, semicolon,\n   *                     ; and backslash\n   */\n\n  var cookieValueRegExp = /^(\"?)[\\u0021\\u0023-\\u002B\\u002D-\\u003A\\u003C-\\u005B\\u005D-\\u007E]*\\1$/;\n\n  /**\n   * RegExp to match domain-value in RFC 6265 sec 4.1.1\n   *\n   * domain-value      = <subdomain>\n   *                     ; defined in [RFC1034], Section 3.5, as\n   *                     ; enhanced by [RFC1123], Section 2.1\n   * <subdomain>       = <label> | <subdomain> \".\" <label>\n   * <label>           = <let-dig> [ [ <ldh-str> ] <let-dig> ]\n   *                     Labels must be 63 characters or less.\n   *                     'let-dig' not 'letter' in the first char, per RFC1123\n   * <ldh-str>         = <let-dig-hyp> | <let-dig-hyp> <ldh-str>\n   * <let-dig-hyp>     = <let-dig> | \"-\"\n   * <let-dig>         = <letter> | <digit>\n   * <letter>          = any one of the 52 alphabetic characters A through Z in\n   *                     upper case and a through z in lower case\n   * <digit>           = any one of the ten digits 0 through 9\n   *\n   * Keep support for leading dot: https://github.com/jshttp/cookie/issues/173\n   *\n   * > (Note that a leading %x2E (\".\"), if present, is ignored even though that\n   * character is not permitted, but a trailing %x2E (\".\"), if present, will\n   * cause the user agent to ignore the attribute.)\n   */\n\n  var domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;\n\n  /**\n   * RegExp to match path-value in RFC 6265 sec 4.1.1\n   *\n   * path-value        = <any CHAR except CTLs or \";\">\n   * CHAR              = %x01-7F\n   *                     ; defined in RFC 5234 appendix B.1\n   */\n\n  var pathValueRegExp = /^[\\u0020-\\u003A\\u003D-\\u007E]*$/;\n\n  /**\n   * Parse a cookie header.\n   *\n   * Parse the given cookie header string into an object\n   * The object has the various cookies as keys(names) => values\n   *\n   * @param {string} str\n   * @param {object} [opt]\n   * @return {object}\n   * @public\n   */\n\n  function parse(str, opt) {\n    if (typeof str !== 'string') {\n      throw new TypeError('argument str must be a string');\n    }\n    var obj = {};\n    var len = str.length;\n    // RFC 6265 sec 4.1.1, RFC 2616 2.2 defines a cookie name consists of one char minimum, plus '='.\n    if (len < 2) return obj;\n    var dec = opt && opt.decode || decode;\n    var index = 0;\n    var eqIdx = 0;\n    var endIdx = 0;\n    do {\n      eqIdx = str.indexOf('=', index);\n      if (eqIdx === -1) break; // No more cookie pairs.\n\n      endIdx = str.indexOf(';', index);\n      if (endIdx === -1) {\n        endIdx = len;\n      } else if (eqIdx > endIdx) {\n        // backtrack on prior semicolon\n        index = str.lastIndexOf(';', eqIdx - 1) + 1;\n        continue;\n      }\n      var keyStartIdx = startIndex(str, index, eqIdx);\n      var keyEndIdx = endIndex(str, eqIdx, keyStartIdx);\n      var key = str.slice(keyStartIdx, keyEndIdx);\n\n      // only assign once\n      if (!__hasOwnProperty.call(obj, key)) {\n        var valStartIdx = startIndex(str, eqIdx + 1, endIdx);\n        var valEndIdx = endIndex(str, endIdx, valStartIdx);\n        if (str.charCodeAt(valStartIdx) === 0x22 /* \" */ && str.charCodeAt(valEndIdx - 1) === 0x22 /* \" */) {\n          valStartIdx++;\n          valEndIdx--;\n        }\n        var val = str.slice(valStartIdx, valEndIdx);\n        obj[key] = tryDecode(val, dec);\n      }\n      index = endIdx + 1;\n    } while (index < len);\n    return obj;\n  }\n  function startIndex(str, index, max) {\n    do {\n      var code = str.charCodeAt(index);\n      if (code !== 0x20 /*   */ && code !== 0x09 /* \\t */) return index;\n    } while (++index < max);\n    return max;\n  }\n  function endIndex(str, index, min) {\n    while (index > min) {\n      var code = str.charCodeAt(--index);\n      if (code !== 0x20 /*   */ && code !== 0x09 /* \\t */) return index + 1;\n    }\n    return min;\n  }\n\n  /**\n   * Serialize data into a cookie header.\n   *\n   * Serialize a name value pair into a cookie string suitable for\n   * http headers. An optional options object specifies cookie parameters.\n   *\n   * serialize('foo', 'bar', { httpOnly: true })\n   *   => \"foo=bar; httpOnly\"\n   *\n   * @param {string} name\n   * @param {string} val\n   * @param {object} [opt]\n   * @return {string}\n   * @public\n   */\n\n  function serialize(name, val, opt) {\n    var enc = opt && opt.encode || encodeURIComponent;\n    if (typeof enc !== 'function') {\n      throw new TypeError('option encode is invalid');\n    }\n    if (!cookieNameRegExp.test(name)) {\n      throw new TypeError('argument name is invalid');\n    }\n    var value = enc(val);\n    if (!cookieValueRegExp.test(value)) {\n      throw new TypeError('argument val is invalid');\n    }\n    var str = name + '=' + value;\n    if (!opt) return str;\n    if (null != opt.maxAge) {\n      var maxAge = Math.floor(opt.maxAge);\n      if (!isFinite(maxAge)) {\n        throw new TypeError('option maxAge is invalid');\n      }\n      str += '; Max-Age=' + maxAge;\n    }\n    if (opt.domain) {\n      if (!domainValueRegExp.test(opt.domain)) {\n        throw new TypeError('option domain is invalid');\n      }\n      str += '; Domain=' + opt.domain;\n    }\n    if (opt.path) {\n      if (!pathValueRegExp.test(opt.path)) {\n        throw new TypeError('option path is invalid');\n      }\n      str += '; Path=' + opt.path;\n    }\n    if (opt.expires) {\n      var expires = opt.expires;\n      if (!isDate(expires) || isNaN(expires.valueOf())) {\n        throw new TypeError('option expires is invalid');\n      }\n      str += '; Expires=' + expires.toUTCString();\n    }\n    if (opt.httpOnly) {\n      str += '; HttpOnly';\n    }\n    if (opt.secure) {\n      str += '; Secure';\n    }\n    if (opt.partitioned) {\n      str += '; Partitioned';\n    }\n    if (opt.priority) {\n      var priority = typeof opt.priority === 'string' ? opt.priority.toLowerCase() : opt.priority;\n      switch (priority) {\n        case 'low':\n          str += '; Priority=Low';\n          break;\n        case 'medium':\n          str += '; Priority=Medium';\n          break;\n        case 'high':\n          str += '; Priority=High';\n          break;\n        default:\n          throw new TypeError('option priority is invalid');\n      }\n    }\n    if (opt.sameSite) {\n      var sameSite = typeof opt.sameSite === 'string' ? opt.sameSite.toLowerCase() : opt.sameSite;\n      switch (sameSite) {\n        case true:\n          str += '; SameSite=Strict';\n          break;\n        case 'lax':\n          str += '; SameSite=Lax';\n          break;\n        case 'strict':\n          str += '; SameSite=Strict';\n          break;\n        case 'none':\n          str += '; SameSite=None';\n          break;\n        default:\n          throw new TypeError('option sameSite is invalid');\n      }\n    }\n    return str;\n  }\n\n  /**\n   * URL-decode string value. Optimized to skip native call when no %.\n   *\n   * @param {string} str\n   * @returns {string}\n   */\n\n  function decode(str) {\n    return str.indexOf('%') !== -1 ? decodeURIComponent(str) : str;\n  }\n\n  /**\n   * Determine if value is a Date.\n   *\n   * @param {*} val\n   * @private\n   */\n\n  function isDate(val) {\n    return __toString.call(val) === '[object Date]';\n  }\n\n  /**\n   * Try decoding a string using a decoding function.\n   *\n   * @param {string} str\n   * @param {function} decode\n   * @private\n   */\n\n  function tryDecode(str, decode) {\n    try {\n      return decode(str);\n    } catch (e) {\n      return str;\n    }\n  }\n  return cookie;\n}\nvar cookieExports = requireCookie();\nfunction hasDocumentCookie() {\n  const testingValue = typeof global === 'undefined' ? undefined : global.TEST_HAS_DOCUMENT_COOKIE;\n  if (typeof testingValue === 'boolean') {\n    return testingValue;\n  }\n  // Can we get/set cookies on document.cookie?\n  return typeof document === 'object' && typeof document.cookie === 'string';\n}\nfunction parseCookies(cookies) {\n  if (typeof cookies === 'string') {\n    return cookieExports.parse(cookies);\n  } else if (typeof cookies === 'object' && cookies !== null) {\n    return cookies;\n  } else {\n    return {};\n  }\n}\nfunction readCookie(value, options = {}) {\n  const cleanValue = cleanupCookieValue(value);\n  if (!options.doNotParse) {\n    try {\n      return JSON.parse(cleanValue);\n    } catch (e) {\n      // At least we tried\n    }\n  }\n  // Ignore clean value if we failed the deserialization\n  // It is not relevant anymore to trim those values\n  return value;\n}\nfunction cleanupCookieValue(value) {\n  // express prepend j: before serializing a cookie\n  if (value && value[0] === 'j' && value[1] === ':') {\n    return value.substr(2);\n  }\n  return value;\n}\nclass Cookies {\n  constructor(cookies, defaultSetOptions = {}) {\n    this.changeListeners = [];\n    this.HAS_DOCUMENT_COOKIE = false;\n    this.update = () => {\n      if (!this.HAS_DOCUMENT_COOKIE) {\n        return;\n      }\n      const previousCookies = this.cookies;\n      this.cookies = cookieExports.parse(document.cookie);\n      this._checkChanges(previousCookies);\n    };\n    const domCookies = typeof document === 'undefined' ? '' : document.cookie;\n    this.cookies = parseCookies(cookies || domCookies);\n    this.defaultSetOptions = defaultSetOptions;\n    this.HAS_DOCUMENT_COOKIE = hasDocumentCookie();\n  }\n  _emitChange(params) {\n    for (let i = 0; i < this.changeListeners.length; ++i) {\n      this.changeListeners[i](params);\n    }\n  }\n  _checkChanges(previousCookies) {\n    const names = new Set(Object.keys(previousCookies).concat(Object.keys(this.cookies)));\n    names.forEach(name => {\n      if (previousCookies[name] !== this.cookies[name]) {\n        this._emitChange({\n          name,\n          value: readCookie(this.cookies[name])\n        });\n      }\n    });\n  }\n  _startPolling() {\n    this.pollingInterval = setInterval(this.update, 300);\n  }\n  _stopPolling() {\n    if (this.pollingInterval) {\n      clearInterval(this.pollingInterval);\n    }\n  }\n  get(name, options = {}) {\n    if (!options.doNotUpdate) {\n      this.update();\n    }\n    return readCookie(this.cookies[name], options);\n  }\n  getAll(options = {}) {\n    if (!options.doNotUpdate) {\n      this.update();\n    }\n    const result = {};\n    for (let name in this.cookies) {\n      result[name] = readCookie(this.cookies[name], options);\n    }\n    return result;\n  }\n  set(name, value, options) {\n    if (options) {\n      options = Object.assign(Object.assign({}, this.defaultSetOptions), options);\n    } else {\n      options = this.defaultSetOptions;\n    }\n    const stringValue = typeof value === 'string' ? value : JSON.stringify(value);\n    this.cookies = Object.assign(Object.assign({}, this.cookies), {\n      [name]: stringValue\n    });\n    if (this.HAS_DOCUMENT_COOKIE) {\n      document.cookie = cookieExports.serialize(name, stringValue, options);\n    }\n    this._emitChange({\n      name,\n      value,\n      options\n    });\n  }\n  remove(name, options) {\n    const finalOptions = options = Object.assign(Object.assign(Object.assign({}, this.defaultSetOptions), options), {\n      expires: new Date(1970, 1, 1, 0, 0, 1),\n      maxAge: 0\n    });\n    this.cookies = Object.assign({}, this.cookies);\n    delete this.cookies[name];\n    if (this.HAS_DOCUMENT_COOKIE) {\n      document.cookie = cookieExports.serialize(name, '', finalOptions);\n    }\n    this._emitChange({\n      name,\n      value: undefined,\n      options\n    });\n  }\n  addChangeListener(callback) {\n    this.changeListeners.push(callback);\n    if (this.HAS_DOCUMENT_COOKIE && this.changeListeners.length === 1) {\n      if (typeof window === 'object' && 'cookieStore' in window) {\n        window.cookieStore.addEventListener('change', this.update);\n      } else {\n        this._startPolling();\n      }\n    }\n  }\n  removeChangeListener(callback) {\n    const idx = this.changeListeners.indexOf(callback);\n    if (idx >= 0) {\n      this.changeListeners.splice(idx, 1);\n    }\n    if (this.HAS_DOCUMENT_COOKIE && this.changeListeners.length === 0) {\n      if (typeof window === 'object' && 'cookieStore' in window) {\n        window.cookieStore.removeEventListener('change', this.update);\n      } else {\n        this._stopPolling();\n      }\n    }\n  }\n}\nexport { Cookies as default };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}