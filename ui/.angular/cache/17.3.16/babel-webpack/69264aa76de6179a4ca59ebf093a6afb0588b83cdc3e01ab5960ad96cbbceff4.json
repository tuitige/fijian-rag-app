{"ast":null,"code":"import { __assign, __asyncValues, __awaiter, __generator, __read, __spread, __values } from \"tslib\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { PredicateInternalsKey } from '../types';\nimport { ModelPredicateCreator as FlatModelPredicateCreator, comparisonKeys } from './index';\nimport { ModelRelationship } from '../storage/relationship';\nimport { asyncSome, asyncEvery } from '../util';\nvar ops = __spread(comparisonKeys);\n/**\n * A map from keys (exposed to customers) to the internal predicate data\n * structures invoking code should not muck with.\n */\nvar predicateInternalsMap = new Map();\n/**\n * Creates a link between a key (and generates a key if needed) and an internal\n * `GroupCondition`, which allows us to return a key object instead of the gory\n * conditions details to customers/invoking code.\n *\n * @param condition The internal condition to keep hidden.\n * @param key The object DataStore will use to find the internal condition.\n * If no key is given, an empty one is created.\n */\nvar registerPredicateInternals = function (condition, key) {\n  var finalKey = key || new PredicateInternalsKey();\n  predicateInternalsMap.set(finalKey, condition);\n  return finalKey;\n};\n/**\n * Takes a key object from `registerPredicateInternals()` to fetch an internal\n * `GroupCondition` object, which can then be used to query storage or\n * test/match objects.\n *\n * This indirection exists to hide `GroupCondition` from public interfaces, since\n * `GroupCondition` contains extra methods and properties that public callers\n * should not use.\n *\n * @param key A key object previously returned by `registerPredicateInternals()`\n */\nexport var internals = function (key) {\n  if (!predicateInternalsMap.has(key)) {\n    throw new Error(\"Invalid predicate. Terminate your predicate with a valid condition (e.g., `p => p.field.eq('value')`) or pass `Predicates.ALL`.\");\n  }\n  return predicateInternalsMap.get(key);\n};\n/**\n * Maps operators to negated operators.\n * Used to facilitate propagation of negation down a tree of conditions.\n */\nvar negations = {\n  and: 'or',\n  or: 'and',\n  not: 'and',\n  eq: 'ne',\n  ne: 'eq',\n  gt: 'le',\n  ge: 'lt',\n  lt: 'ge',\n  le: 'gt',\n  contains: 'notContains',\n  notContains: 'contains'\n};\n/**\n * A condition that can operate against a single \"primitive\" field of a model or item.\n * @member field The field of *some record* to test against.\n * @member operator The equality or comparison operator to use.\n * @member operands The operands for the equality/comparison check.\n */\nvar FieldCondition = /** @class */function () {\n  function FieldCondition(field, operator, operands) {\n    this.field = field;\n    this.operator = operator;\n    this.operands = operands;\n    this.validate();\n  }\n  /**\n   * Creates a copy of self.\n   * @param extract Not used. Present only to fulfill the `UntypedCondition` interface.\n   * @returns A new, identitical `FieldCondition`.\n   */\n  FieldCondition.prototype.copy = function (extract) {\n    return [new FieldCondition(this.field, this.operator, __spread(this.operands)), undefined];\n  };\n  /**\n   * Produces a tree structure similar to a graphql condition. The returned\n   * structure is \"dumb\" and is intended for another query/condition\n   * generation mechanism to interpret, such as the cloud or storage query\n   * builders.\n   *\n   * E.g.,\n   *\n   * ```json\n   * {\n   * \t\"name\": {\n   * \t\t\"eq\": \"robert\"\n   * \t}\n   * }\n   * ```\n   */\n  FieldCondition.prototype.toAST = function () {\n    var _a, _b;\n    return _a = {}, _a[this.field] = (_b = {}, _b[this.operator] = this.operator === 'between' ? [this.operands[0], this.operands[1]] : this.operands[0], _b), _a;\n  };\n  /**\n   * Produces a new condition (`FieldCondition` or `GroupCondition`) that\n   * matches the opposite of this condition.\n   *\n   * Intended to be used when applying De Morgan's Law, which can be done to\n   * produce more efficient queries against the storage layer if a negation\n   * appears in the query tree.\n   *\n   * For example:\n   *\n   * 1. `name.eq('robert')` becomes `name.ne('robert')`\n   * 2. `price.between(100, 200)` becomes `m => m.or(m => [m.price.lt(100), m.price.gt(200)])`\n   *\n   * @param model The model meta to use when construction a new `GroupCondition`\n   * for cases where the negation requires multiple `FieldCondition`'s.\n   */\n  FieldCondition.prototype.negated = function (model) {\n    if (this.operator === 'between') {\n      return new GroupCondition(model, undefined, undefined, 'or', [new FieldCondition(this.field, 'lt', [this.operands[0]]), new FieldCondition(this.field, 'gt', [this.operands[1]])]);\n    } else if (this.operator === 'beginsWith') {\n      // beginsWith negation doesn't have a good, safe optimation right now.\n      // just re-wrap it in negation. The adapter will have to scan-and-filter,\n      // as is likely optimal for negated beginsWith conditions *anyway*.\n      return new GroupCondition(model, undefined, undefined, 'not', [new FieldCondition(this.field, 'beginsWith', [this.operands[0]])]);\n    } else {\n      return new FieldCondition(this.field, negations[this.operator], this.operands);\n    }\n  };\n  /**\n   * Not implemented. Not needed. GroupCondition instead consumes FieldConditions and\n   * transforms them into legacy predicates. (*For now.*)\n   * @param storage N/A. If ever implemented, the storage adapter to query.\n   * @returns N/A. If ever implemented, return items from `storage` that match.\n   */\n  FieldCondition.prototype.fetch = function (storage) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2 /*return*/, Promise.reject('No implementation needed [yet].')];\n      });\n    });\n  };\n  /**\n   * Determins whether a given item matches the expressed condition.\n   * @param item The item to test.\n   * @returns `Promise<boolean>`, `true` if matches; `false` otherwise.\n   */\n  FieldCondition.prototype.matches = function (item) {\n    return __awaiter(this, void 0, void 0, function () {\n      var v, operations, operation, result;\n      var _this = this;\n      return __generator(this, function (_a) {\n        v = item[this.field];\n        operations = {\n          eq: function () {\n            return v === _this.operands[0];\n          },\n          ne: function () {\n            return v !== _this.operands[0];\n          },\n          gt: function () {\n            return v > _this.operands[0];\n          },\n          ge: function () {\n            return v >= _this.operands[0];\n          },\n          lt: function () {\n            return v < _this.operands[0];\n          },\n          le: function () {\n            return v <= _this.operands[0];\n          },\n          contains: function () {\n            return (v === null || v === void 0 ? void 0 : v.indexOf(_this.operands[0])) > -1;\n          },\n          notContains: function () {\n            return !v ? true : v.indexOf(_this.operands[0]) === -1;\n          },\n          beginsWith: function () {\n            return v === null || v === void 0 ? void 0 : v.startsWith(_this.operands[0]);\n          },\n          between: function () {\n            return v >= _this.operands[0] && v <= _this.operands[1];\n          }\n        };\n        operation = operations[this.operator];\n        if (operation) {\n          result = operation();\n          return [2 /*return*/, result];\n        } else {\n          throw new Error(\"Invalid operator given: \" + this.operator);\n        }\n        return [2 /*return*/];\n      });\n    });\n  };\n  /**\n   * Checks `this.operands` for compatibility with `this.operator`.\n   */\n  FieldCondition.prototype.validate = function () {\n    var _this = this;\n    /**\n     * Creates a validator that checks for a particular `operands` count.\n     * Throws an exception if the `count` disagrees with `operands.length`.\n     * @param count The number of `operands` expected.\n     */\n    var argumentCount = function (count) {\n      var argsClause = count === 1 ? 'argument is' : 'arguments are';\n      return function () {\n        if (_this.operands.length !== count) {\n          return \"Exactly \" + count + \" \" + argsClause + \" required.\";\n        }\n      };\n    };\n    // NOTE: validations should return a message on failure.\n    // hence, they should be \"joined\" together with logical OR's\n    // as seen in the `between:` entry.\n    var validations = {\n      eq: argumentCount(1),\n      ne: argumentCount(1),\n      gt: argumentCount(1),\n      ge: argumentCount(1),\n      lt: argumentCount(1),\n      le: argumentCount(1),\n      contains: argumentCount(1),\n      notContains: argumentCount(1),\n      beginsWith: argumentCount(1),\n      between: function () {\n        return argumentCount(2)() || (_this.operands[0] > _this.operands[1] ? 'The first argument must be less than or equal to the second argument.' : null);\n      }\n    };\n    var validate = validations[this.operator];\n    if (validate) {\n      var e = validate();\n      if (typeof e === 'string') throw new Error(\"Incorrect usage of `\" + this.operator + \"()`: \" + e);\n    } else {\n      throw new Error(\"Non-existent operator: `\" + this.operator + \"()`\");\n    }\n  };\n  return FieldCondition;\n}();\nexport { FieldCondition };\n/**\n * Small utility function to generate a monotonically increasing ID.\n * Used by GroupCondition to help keep track of which group is doing what,\n * when, and where during troubleshooting.\n */\nvar getGroupId = function () {\n  var seed = 1;\n  return function () {\n    return \"group_\" + seed++;\n  };\n}();\n/**\n * A set of sub-conditions to operate against a model, optionally scoped to\n * a specific field, combined with the given operator (one of `and`, `or`, or `not`).\n * @member groupId Used to distinguish between GroupCondition instances for\n * debugging and troublehsooting.\n * @member model A metadata object that tells GroupCondition what to query and how.\n * @member field The field on the model that the sub-conditions apply to.\n * @member operator How to group child conditions together.\n * @member operands The child conditions.\n */\nvar GroupCondition = /** @class */function () {\n  function GroupCondition(\n  /**\n   * The `ModelMeta` of the model to query and/or filter against.\n   * Expected to contain:\n   *\n   * ```js\n   * {\n   * \tbuilder: ModelConstructor,\n   * \tschema: SchemaModel,\n   * \tpkField: string[]\n   * }\n   * ```\n   */\n  model,\n  /**\n   * If populated, this group specifices a condition on a relationship.\n   *\n   * If `field` does *not* point to a related model, that's an error. It\n   * could indicate that the `GroupCondition` was instantiated with bad\n   * data, or that the model metadata is incorrect.\n   */\n  field,\n  /**\n   * If a `field` is given, whether the relationship is a `HAS_ONE`,\n   * 'HAS_MANY`, or `BELONGS_TO`.\n   *\n   * TODO: Remove this and replace with derivation using\n   * `ModelRelationship.from(this.model, this.field).relationship`;\n   */\n  relationshipType,\n  /**\n   *\n   */\n  operator,\n  /**\n   *\n   */\n  operands,\n  /**\n   * Whether this GroupCondition is the result of an optimize call.\n   *\n   * This is used to guard against infinitely fetch -> optimize -> fetch\n   * recursion.\n   */\n  isOptimized) {\n    if (isOptimized === void 0) {\n      isOptimized = false;\n    }\n    this.model = model;\n    this.field = field;\n    this.relationshipType = relationshipType;\n    this.operator = operator;\n    this.operands = operands;\n    this.isOptimized = isOptimized;\n    // `groupId` was used for development/debugging.\n    // Should we leave this in for future troubleshooting?\n    this.groupId = getGroupId();\n  }\n  /**\n   * Returns a copy of a GroupCondition, which also returns the copy of a\n   * given reference node to \"extract\".\n   * @param extract A node of interest. Its copy will *also* be returned if the node exists.\n   * @returns [The full copy, the copy of `extract` | undefined]\n   */\n  GroupCondition.prototype.copy = function (extract) {\n    var copied = new GroupCondition(this.model, this.field, this.relationshipType, this.operator, []);\n    var extractedCopy = extract === this ? copied : undefined;\n    this.operands.forEach(function (o) {\n      var _a = __read(o.copy(extract), 2),\n        operandCopy = _a[0],\n        extractedFromOperand = _a[1];\n      copied.operands.push(operandCopy);\n      extractedCopy = extractedCopy || extractedFromOperand;\n    });\n    return [copied, extractedCopy];\n  };\n  /**\n   * Creates a new `GroupCondition` that contains only the local field conditions,\n   * omitting related model conditions. That resulting `GroupCondition` can be\n   * used to produce predicates that are compatible with the storage adapters and\n   * Cloud storage.\n   *\n   * @param negate Whether the condition tree should be negated according\n   * to De Morgan's law.\n   */\n  GroupCondition.prototype.withFieldConditionsOnly = function (negate) {\n    var _this = this;\n    var negateChildren = negate !== (this.operator === 'not');\n    return new GroupCondition(this.model, undefined, undefined, negate ? negations[this.operator] : this.operator, this.operands.filter(function (o) {\n      return o instanceof FieldCondition;\n    }).map(function (o) {\n      return negateChildren ? o.negated(_this.model) : o;\n    }));\n  };\n  /**\n   * Returns a version of the predicate tree with unnecessary logical groups\n   * condensed and merged together. This is intended to create a dense tree\n   * with leaf nodes (`FieldCondition`'s) aggregated under as few group conditions\n   * as possible for the most efficient fetching possible -- it allows `fetch()`.\n   *\n   * E.g. a grouping like this:\n   *\n   * ```yaml\n   * and:\n   * \tand:\n   * \t\tid:\n   * \t\t\teq: \"abc\"\n   * \tand:\n   * \t\tname:\n   * \t\t\teq: \"xyz\"\n   * ```\n   *\n   * Will become this:\n   *\n   * ```yaml\n   * and:\n   * \tid:\n   * \t\teq: \"abc\"\n   * \tname:\n   * \t\teq: \"xyz\"\n   * ```\n   *\n   * This allows `fetch()` to pass both the `id` and `name` conditions to the adapter\n   * together, which can then decide what index to use based on both fields together.\n   *\n   * @param preserveNode Whether to preserve the current node and to explicitly not eliminate\n   * it during optimization. Used internally to preserve the root node and children of\n   * `not` groups. `not` groups will always have a single child, so there's nothing to\n   * optimize below a `not` (for now), and it makes the query logic simpler later.\n   */\n  GroupCondition.prototype.optimized = function (preserveNode) {\n    var _this = this;\n    if (preserveNode === void 0) {\n      preserveNode = true;\n    }\n    var operands = this.operands.map(function (o) {\n      return o instanceof GroupCondition ? o.optimized(_this.operator === 'not') : o;\n    });\n    // we're only collapsing and/or groups that contains a single child for now,\n    // because they're much more common and much more trivial to collapse. basically,\n    // an `and`/`or` that contains a single child doesn't require the layer of\n    // logical grouping.\n    if (!preserveNode && ['and', 'or'].includes(this.operator) && !this.field && operands.length === 1) {\n      var operand = operands[0];\n      if (operand instanceof FieldCondition) {\n        // between conditions should NOT be passed up the chain. if they\n        // need to be *negated* later, it is important that they be properly\n        // contained in an AND group. when de morgan's law is applied, the\n        // conditions are reversed and the AND group flips to an OR. this\n        // doesn't work right if the a `between` doesn't live in an AND group.\n        if (operand.operator !== 'between') {\n          return operand;\n        }\n      } else {\n        return operand;\n      }\n    }\n    return new GroupCondition(this.model, this.field, this.relationshipType, this.operator, operands, true);\n  };\n  /**\n   * Fetches matching records from a given storage adapter using legacy predicates (for now).\n   * @param storage The storage adapter this predicate will query against.\n   * @param breadcrumb For debugging/troubleshooting. A list of the `groupId`'s this\n   * GroupdCondition.fetch is nested within.\n   * @param negate Whether to match on the `NOT` of `this`.\n   * @returns An `Promise` of `any[]` from `storage` matching the child conditions.\n   */\n  GroupCondition.prototype.fetch = function (storage, breadcrumb, negate) {\n    if (breadcrumb === void 0) {\n      breadcrumb = [];\n    }\n    if (negate === void 0) {\n      negate = false;\n    }\n    return __awaiter(this, void 0, void 0, function () {\n      var resultGroups, operator, negateChildren, groups, conditions, groups_1, groups_1_1, g, relatives, relationship, allJoinConditions, relatives_1, relatives_1_1, relative, relativeConditions, i, predicate, _a, _b, e_1_1, predicate, _c, _d, _e, _f, getPKValue, resultIndex, resultGroups_1, resultGroups_1_1, group, intersectWith, _g, _h, k, resultGroups_2, resultGroups_2_1, group, group_1, group_1_1, item;\n      var e_1, _j, e_2, _k, _l, e_3, _m, e_4, _o, e_5, _p, e_6, _q;\n      var _this = this;\n      return __generator(this, function (_r) {\n        switch (_r.label) {\n          case 0:\n            if (!this.isOptimized) {\n              return [2 /*return*/, this.optimized().fetch(storage)];\n            }\n            resultGroups = [];\n            operator = negate ? negations[this.operator] : this.operator;\n            negateChildren = negate !== (this.operator === 'not');\n            groups = this.operands.filter(function (op) {\n              return op instanceof GroupCondition;\n            });\n            conditions = this.operands.filter(function (op) {\n              return op instanceof FieldCondition;\n            });\n            _r.label = 1;\n          case 1:\n            _r.trys.push([1, 10, 11, 12]);\n            groups_1 = __values(groups), groups_1_1 = groups_1.next();\n            _r.label = 2;\n          case 2:\n            if (!!groups_1_1.done) return [3 /*break*/, 9];\n            g = groups_1_1.value;\n            return [4 /*yield*/, g.fetch(storage, __spread(breadcrumb, [this.groupId]), negateChildren)];\n          case 3:\n            relatives = _r.sent();\n            // no relatives -> no need to attempt to perform a \"join\" query for\n            // candidate results:\n            //\n            // select a.* from a,b where b.id in EMPTY_SET ==> EMPTY_SET\n            //\n            // Additionally, the entire (sub)-query can be short-circuited if\n            // the operator is `AND`. Illustrated in SQL:\n            //\n            // select a.* from a where\n            //   id in [a,b,c]\n            //     AND                        <\n            //   id in EMTPY_SET            <<< Look!\n            //     AND                        <\n            //   id in [x,y,z]\n            //\n            // YIELDS: EMPTY_SET           // <-- Easy peasy. Lemon squeezy.\n            //\n            if (relatives.length === 0) {\n              // aggressively short-circuit as soon as we know the group condition will fail\n              if (operator === 'and') {\n                return [2 /*return*/, []];\n              }\n              // less aggressive short-circuit if we know the relatives will produce no\n              // candidate results; but aren't sure yet how this affects the group condition.\n              resultGroups.push([]);\n              return [3 /*break*/, 8];\n            }\n            if (!g.field) return [3 /*break*/, 7];\n            relationship = ModelRelationship.from(this.model, g.field);\n            if (!relationship) return [3 /*break*/, 5];\n            allJoinConditions = [];\n            try {\n              for (relatives_1 = (e_2 = void 0, __values(relatives)), relatives_1_1 = relatives_1.next(); !relatives_1_1.done; relatives_1_1 = relatives_1.next()) {\n                relative = relatives_1_1.value;\n                relativeConditions = [];\n                for (i = 0; i < relationship.localJoinFields.length; i++) {\n                  relativeConditions.push((_l = {}, _l[relationship.localJoinFields[i]] = {\n                    eq: relative[relationship.remoteJoinFields[i]]\n                  }, _l));\n                }\n                allJoinConditions.push({\n                  and: relativeConditions\n                });\n              }\n            } catch (e_2_1) {\n              e_2 = {\n                error: e_2_1\n              };\n            } finally {\n              try {\n                if (relatives_1_1 && !relatives_1_1.done && (_k = relatives_1.return)) _k.call(relatives_1);\n              } finally {\n                if (e_2) throw e_2.error;\n              }\n            }\n            predicate = FlatModelPredicateCreator.createFromAST(this.model.schema, {\n              or: allJoinConditions\n            });\n            _b = (_a = resultGroups).push;\n            return [4 /*yield*/, storage.query(this.model.builder, predicate)];\n          case 4:\n            _b.apply(_a, [_r.sent()]);\n            return [3 /*break*/, 6];\n          case 5:\n            throw new Error('Missing field metadata.');\n          case 6:\n            return [3 /*break*/, 8];\n          case 7:\n            // relatives are not actually relatives. they're candidate results.\n            resultGroups.push(relatives);\n            _r.label = 8;\n          case 8:\n            groups_1_1 = groups_1.next();\n            return [3 /*break*/, 2];\n          case 9:\n            return [3 /*break*/, 12];\n          case 10:\n            e_1_1 = _r.sent();\n            e_1 = {\n              error: e_1_1\n            };\n            return [3 /*break*/, 12];\n          case 11:\n            try {\n              if (groups_1_1 && !groups_1_1.done && (_j = groups_1.return)) _j.call(groups_1);\n            } finally {\n              if (e_1) throw e_1.error;\n            }\n            return [7 /*endfinally*/];\n          case 12:\n            if (!(conditions.length > 0)) return [3 /*break*/, 14];\n            predicate = this.withFieldConditionsOnly(negateChildren).toStoragePredicate();\n            _d = (_c = resultGroups).push;\n            return [4 /*yield*/, storage.query(this.model.builder, predicate)];\n          case 13:\n            _d.apply(_c, [_r.sent()]);\n            return [3 /*break*/, 16];\n          case 14:\n            if (!(conditions.length === 0 && resultGroups.length === 0)) return [3 /*break*/, 16];\n            _f = (_e = resultGroups).push;\n            return [4 /*yield*/, storage.query(this.model.builder)];\n          case 15:\n            _f.apply(_e, [_r.sent()]);\n            _r.label = 16;\n          case 16:\n            getPKValue = function (item) {\n              return JSON.stringify(_this.model.pkField.map(function (name) {\n                return item[name];\n              }));\n            };\n            if (operator === 'and') {\n              if (resultGroups.length === 0) {\n                return [2 /*return*/, []];\n              }\n              try {\n                // for each group, we intersect, removing items from the result index\n                // that aren't present in each subsequent group.\n                for (resultGroups_1 = __values(resultGroups), resultGroups_1_1 = resultGroups_1.next(); !resultGroups_1_1.done; resultGroups_1_1 = resultGroups_1.next()) {\n                  group = resultGroups_1_1.value;\n                  if (resultIndex === undefined) {\n                    resultIndex = new Map(group.map(function (item) {\n                      return [getPKValue(item), item];\n                    }));\n                  } else {\n                    intersectWith = new Map(group.map(function (item) {\n                      return [getPKValue(item), item];\n                    }));\n                    try {\n                      for (_g = (e_4 = void 0, __values(resultIndex.keys())), _h = _g.next(); !_h.done; _h = _g.next()) {\n                        k = _h.value;\n                        if (!intersectWith.has(k)) {\n                          resultIndex.delete(k);\n                        }\n                      }\n                    } catch (e_4_1) {\n                      e_4 = {\n                        error: e_4_1\n                      };\n                    } finally {\n                      try {\n                        if (_h && !_h.done && (_o = _g.return)) _o.call(_g);\n                      } finally {\n                        if (e_4) throw e_4.error;\n                      }\n                    }\n                  }\n                }\n              } catch (e_3_1) {\n                e_3 = {\n                  error: e_3_1\n                };\n              } finally {\n                try {\n                  if (resultGroups_1_1 && !resultGroups_1_1.done && (_m = resultGroups_1.return)) _m.call(resultGroups_1);\n                } finally {\n                  if (e_3) throw e_3.error;\n                }\n              }\n            } else if (operator === 'or' || operator === 'not') {\n              // it's OK to handle NOT here, because NOT must always only negate\n              // a single child predicate. NOT logic will have been distributed down\n              // to the leaf conditions already.\n              resultIndex = new Map();\n              try {\n                // just merge the groups, performing DISTINCT-ification by ID.\n                for (resultGroups_2 = __values(resultGroups), resultGroups_2_1 = resultGroups_2.next(); !resultGroups_2_1.done; resultGroups_2_1 = resultGroups_2.next()) {\n                  group = resultGroups_2_1.value;\n                  try {\n                    for (group_1 = (e_6 = void 0, __values(group)), group_1_1 = group_1.next(); !group_1_1.done; group_1_1 = group_1.next()) {\n                      item = group_1_1.value;\n                      resultIndex.set(getPKValue(item), item);\n                    }\n                  } catch (e_6_1) {\n                    e_6 = {\n                      error: e_6_1\n                    };\n                  } finally {\n                    try {\n                      if (group_1_1 && !group_1_1.done && (_q = group_1.return)) _q.call(group_1);\n                    } finally {\n                      if (e_6) throw e_6.error;\n                    }\n                  }\n                }\n              } catch (e_5_1) {\n                e_5 = {\n                  error: e_5_1\n                };\n              } finally {\n                try {\n                  if (resultGroups_2_1 && !resultGroups_2_1.done && (_p = resultGroups_2.return)) _p.call(resultGroups_2);\n                } finally {\n                  if (e_5) throw e_5.error;\n                }\n              }\n            }\n            return [2 /*return*/, Array.from((resultIndex === null || resultIndex === void 0 ? void 0 : resultIndex.values()) || [])];\n        }\n      });\n    });\n  };\n  /**\n   * Determines whether a single item matches the conditions of `this`.\n   * When checking the target `item`'s properties, each property will be `await`'d\n   * to ensure lazy-loading is respected where applicable.\n   * @param item The item to match against.\n   * @param ignoreFieldName Tells `match()` that the field name has already been dereferenced.\n   * (Used for iterating over children on HAS_MANY checks.)\n   * @returns A boolean (promise): `true` if matched, `false` otherwise.\n   */\n  GroupCondition.prototype.matches = function (item, ignoreFieldName) {\n    if (ignoreFieldName === void 0) {\n      ignoreFieldName = false;\n    }\n    var e_7, _a;\n    return __awaiter(this, void 0, void 0, function () {\n      var itemToCheck, _b, itemToCheck_1, itemToCheck_1_1, singleItem, e_7_1;\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            if (!(this.field && !ignoreFieldName)) return [3 /*break*/, 2];\n            return [4 /*yield*/, item[this.field]];\n          case 1:\n            _b = _c.sent();\n            return [3 /*break*/, 3];\n          case 2:\n            _b = item;\n            _c.label = 3;\n          case 3:\n            itemToCheck = _b;\n            // if there is no item to check, we can stop recursing immediately.\n            // a condition cannot match against an item that does not exist. this\n            // can occur when `item.field` is optional in the schema.\n            if (!itemToCheck) {\n              return [2 /*return*/, false];\n            }\n            if (!(this.relationshipType === 'HAS_MANY' && typeof itemToCheck[Symbol.asyncIterator] === 'function')) return [3 /*break*/, 17];\n            _c.label = 4;\n          case 4:\n            _c.trys.push([4, 10, 11, 16]);\n            itemToCheck_1 = __asyncValues(itemToCheck);\n            _c.label = 5;\n          case 5:\n            return [4 /*yield*/, itemToCheck_1.next()];\n          case 6:\n            if (!(itemToCheck_1_1 = _c.sent(), !itemToCheck_1_1.done)) return [3 /*break*/, 9];\n            singleItem = itemToCheck_1_1.value;\n            return [4 /*yield*/, this.matches(singleItem, true)];\n          case 7:\n            if (_c.sent()) {\n              return [2 /*return*/, true];\n            }\n            _c.label = 8;\n          case 8:\n            return [3 /*break*/, 5];\n          case 9:\n            return [3 /*break*/, 16];\n          case 10:\n            e_7_1 = _c.sent();\n            e_7 = {\n              error: e_7_1\n            };\n            return [3 /*break*/, 16];\n          case 11:\n            _c.trys.push([11,, 14, 15]);\n            if (!(itemToCheck_1_1 && !itemToCheck_1_1.done && (_a = itemToCheck_1.return))) return [3 /*break*/, 13];\n            return [4 /*yield*/, _a.call(itemToCheck_1)];\n          case 12:\n            _c.sent();\n            _c.label = 13;\n          case 13:\n            return [3 /*break*/, 15];\n          case 14:\n            if (e_7) throw e_7.error;\n            return [7 /*endfinally*/];\n          case 15:\n            return [7 /*endfinally*/];\n          case 16:\n            return [2 /*return*/, false];\n          case 17:\n            if (!(this.operator === 'or')) return [3 /*break*/, 18];\n            return [2 /*return*/, asyncSome(this.operands, function (c) {\n              return c.matches(itemToCheck);\n            })];\n          case 18:\n            if (!(this.operator === 'and')) return [3 /*break*/, 19];\n            return [2 /*return*/, asyncEvery(this.operands, function (c) {\n              return c.matches(itemToCheck);\n            })];\n          case 19:\n            if (!(this.operator === 'not')) return [3 /*break*/, 21];\n            if (this.operands.length !== 1) {\n              throw new Error('Invalid arguments! `not()` accepts exactly one predicate expression.');\n            }\n            return [4 /*yield*/, this.operands[0].matches(itemToCheck)];\n          case 20:\n            return [2 /*return*/, !_c.sent()];\n          case 21:\n            throw new Error('Invalid group operator!');\n        }\n      });\n    });\n  };\n  /**\n   * Tranfsorm to a AppSync GraphQL compatible AST.\n   * (Does not support filtering in nested types.)\n   */\n  GroupCondition.prototype.toAST = function () {\n    var _a;\n    if (this.field) throw new Error('Nested type conditions are not supported!');\n    return _a = {}, _a[this.operator] = this.operands.map(function (operand) {\n      return operand.toAST();\n    }), _a;\n  };\n  /**\n   * Turn this predicate group into something a storage adapter\n   * understands how to use.\n   */\n  GroupCondition.prototype.toStoragePredicate = function () {\n    return FlatModelPredicateCreator.createFromAST(this.model.schema, this.toAST());\n  };\n  /**\n   * A JSON representation that's good for debugging.\n   */\n  GroupCondition.prototype.toJSON = function () {\n    return __assign(__assign({}, this), {\n      model: this.model.schema.name\n    });\n  };\n  return GroupCondition;\n}();\nexport { GroupCondition };\n/**\n * Creates a \"seed\" predicate that can be used to build an executable condition.\n * This is used in `query()`, for example, to seed customer- E.g.,\n *\n * ```\n * const p = predicateFor({builder: modelConstructor, schema: modelSchema, pkField: string[]});\n * p.and(child => [\n *   child.field.eq('whatever'),\n *   child.childModel.childField.eq('whatever else'),\n *   child.childModel.or(child => [\n *     child.otherField.contains('x'),\n *     child.otherField.contains('y'),\n *     child.otherField.contains('z'),\n *   ])\n * ])\n * ```\n *\n * `predicateFor()` returns objecst with recursive getters. To facilitate this,\n * a `query` and `tail` can be provided to \"accumulate\" nested conditions.\n *\n * @param ModelType The ModelMeta used to build child properties.\n * @param field Scopes the query branch to a field.\n * @param query A base query to build on. Omit to start a new query.\n * @param tail The point in an existing `query` to attach new conditions to.\n * @returns A ModelPredicate (builder) that customers can create queries with.\n * (As shown in function description.)\n */\nexport function recursivePredicateFor(ModelType, allowRecursion, field, query, tail) {\n  if (allowRecursion === void 0) {\n    allowRecursion = true;\n  }\n  // to be used if we don't have a base query or tail to build onto\n  var starter = new GroupCondition(ModelType, field, undefined, 'and', []);\n  var baseCondition = query && tail ? query : starter;\n  var tailCondition = query && tail ? tail : starter;\n  // our eventual return object, which can be built upon.\n  // next steps will be to add or(), and(), not(), and field.op() methods.\n  var link = {};\n  // so it can be looked up later with in the internals when processing conditions.\n  registerPredicateInternals(baseCondition, link);\n  var copyLink = function () {\n    var _a = __read(baseCondition.copy(tailCondition), 2),\n      query = _a[0],\n      newTail = _a[1];\n    var newLink = recursivePredicateFor(ModelType, allowRecursion, undefined, query, newTail);\n    return {\n      query: query,\n      newTail: newTail,\n      newLink: newLink\n    };\n  };\n  // Adds .or() and .and() methods to the link.\n  // TODO: If revisiting this code, consider writing a Proxy instead.\n  ['and', 'or'].forEach(function (op) {\n    link[op] = function (builder) {\n      // or() and and() will return a copy of the original link\n      // to head off mutability concerns.\n      var _a = copyLink(),\n        query = _a.query,\n        newTail = _a.newTail;\n      var childConditions = builder(recursivePredicateFor(ModelType, allowRecursion));\n      if (!Array.isArray(childConditions)) {\n        throw new Error(\"Invalid predicate. `\" + op + \"` groups must return an array of child conditions.\");\n      }\n      // the customer will supply a child predicate, which apply to the `model.field`\n      // of the tail GroupCondition.\n      newTail === null || newTail === void 0 ? void 0 : newTail.operands.push(new GroupCondition(ModelType, field, undefined, op, childConditions.map(function (c) {\n        return internals(c);\n      })));\n      // FinalPredicate\n      return registerPredicateInternals(query);\n    };\n  });\n  // TODO: If revisiting this code, consider proxy.\n  link.not = function (builder) {\n    // not() will return a copy of the original link\n    // to head off mutability concerns.\n    var _a = copyLink(),\n      query = _a.query,\n      newTail = _a.newTail;\n    // unlike and() and or(), the customer will supply a \"singular\" child predicate.\n    // the difference being: not() does not accept an array of predicate-like objects.\n    // it negates only a *single* predicate subtree.\n    newTail === null || newTail === void 0 ? void 0 : newTail.operands.push(new GroupCondition(ModelType, field, undefined, 'not', [internals(builder(recursivePredicateFor(ModelType, allowRecursion)))]));\n    // A `FinalModelPredicate`.\n    // Return a thing that can no longer be extended, but instead used to `async filter(items)`\n    // or query storage: `.__query.fetch(storage)`.\n    return registerPredicateInternals(query);\n  };\n  var _loop_1 = function (fieldName) {\n    Object.defineProperty(link, fieldName, {\n      enumerable: true,\n      get: function () {\n        var def = ModelType.schema.allFields[fieldName];\n        if (!def.association) {\n          // we're looking at a value field. we need to return a\n          // \"field matcher object\", which contains all of the comparison\n          // functions ('eq', 'ne', 'gt', etc.), scoped to operate\n          // against the target field (fieldName).\n          return ops.reduce(function (fieldMatcher, operator) {\n            var _a;\n            return __assign(__assign({}, fieldMatcher), (_a = {}, _a[operator] = function () {\n              var operands = [];\n              for (var _i = 0; _i < arguments.length; _i++) {\n                operands[_i] = arguments[_i];\n              }\n              // build off a fresh copy of the existing `link`, just in case\n              // the same link is being used elsewhere by the customer.\n              var _a = copyLink(),\n                query = _a.query,\n                newTail = _a.newTail;\n              // normalize operands. if any of the values are `undefiend`, use\n              // `null` instead, because that's what will be stored cross-platform.\n              var normalizedOperands = operands.map(function (o) {\n                return o === undefined ? null : o;\n              });\n              // add the given condition to the link's TAIL node.\n              // remember: the base link might go N nodes deep! e.g.,\n              newTail === null || newTail === void 0 ? void 0 : newTail.operands.push(new FieldCondition(fieldName, operator, normalizedOperands));\n              // A `FinalModelPredicate`.\n              // Return a thing that can no longer be extended, but instead used to `async filter(items)`\n              // or query storage: `.__query.fetch(storage)`.\n              return registerPredicateInternals(query);\n            }, _a));\n          }, {});\n        } else {\n          if (!allowRecursion) {\n            throw new Error('Predication on releated models is not supported in this context.');\n          } else if (def.association.connectionType === 'BELONGS_TO' || def.association.connectionType === 'HAS_ONE' || def.association.connectionType === 'HAS_MANY') {\n            // the use has just typed '.someRelatedModel'. we need to given them\n            // back a predicate chain.\n            var relatedMeta = def.type.modelConstructor;\n            if (!relatedMeta) {\n              throw new Error('Related model metadata is missing. This is a bug! Please report it.');\n            }\n            // `Model.reletedModelField` returns a copy of the original link,\n            // and will contains copies of internal GroupConditions\n            // to head off mutability concerns.\n            var _a = __read(baseCondition.copy(tailCondition), 2),\n              newquery = _a[0],\n              oldtail = _a[1];\n            var newtail = new GroupCondition(relatedMeta, fieldName, def.association.connectionType, 'and', []);\n            // `oldtail` here refers to the *copy* of the old tail.\n            // so, it's safe to modify at this point. and we need to modify\n            // it to push the *new* tail onto the end of it.\n            oldtail.operands.push(newtail);\n            var newlink = recursivePredicateFor(relatedMeta, allowRecursion, undefined, newquery, newtail);\n            return newlink;\n          } else {\n            throw new Error(\"Related model definition doesn't have a typedef. This is a bug! Please report it.\");\n          }\n        }\n      }\n    });\n  };\n  // For each field on the model schema, we want to add a getter\n  // that creates the appropriate new `link` in the query chain.\n  // TODO: If revisiting, consider a proxy.\n  for (var fieldName in ModelType.schema.allFields) {\n    _loop_1(fieldName);\n  }\n  return link;\n}\nexport function predicateFor(ModelType) {\n  // the cast here is just a cheap way to reduce the surface area from\n  // the recursive type.\n  return recursivePredicateFor(ModelType, false);\n}\n//# sourceMappingURL=next.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}