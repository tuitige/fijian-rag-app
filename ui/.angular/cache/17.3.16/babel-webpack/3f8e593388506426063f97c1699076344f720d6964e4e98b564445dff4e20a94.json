{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { __assign, __awaiter, __generator, __rest } from \"tslib\";\nimport { ConsoleLogger as Logger, Credentials, DateUtils, Signer } from '@aws-amplify/core';\nimport axios from 'axios';\nimport { parse, format } from 'url';\nvar logger = new Logger('RestClient');\n/**\n* HTTP Client for REST requests. Send and receive JSON data.\n* Sign request with AWS credentials if available\n* Usage:\n<pre>\nconst restClient = new RestClient();\nrestClient.get('...')\n    .then(function(data) {\n        console.log(data);\n    })\n    .catch(err => console.log(err));\n</pre>\n*/\nvar RestClient = /** @class */function () {\n  /**\n   * @param {RestClientOptions} [options] - Instance options\n   */\n  function RestClient(options) {\n    this._region = 'us-east-1'; // this will be updated by endpoint function\n    this._service = 'execute-api'; // this can be updated by endpoint function\n    this._custom_header = undefined; // this can be updated by endpoint function\n    /**\n     * This weak map provides functionality to let clients cancel\n     * in-flight axios requests. https://github.com/axios/axios#cancellation\n     *\n     * 1. For every axios request, a unique cancel token is generated and added in the request.\n     * 2. Promise for fulfilling the request is then mapped to that unique cancel token.\n     * 3. The promise is returned to the client.\n     * 4. Clients can either wait for the promise to fulfill or call `API.cancel(promise)` to cancel the request.\n     * 5. If `API.cancel(promise)` is called, then the corresponding cancel token is retrieved from the map below.\n     * 6. Promise returned to the client will be in rejected state with the error provided during cancel.\n     * 7. Clients can check if the error is because of cancelling by calling `API.isCancel(error)`.\n     *\n     * For more details, see https://github.com/aws-amplify/amplify-js/pull/3769#issuecomment-552660025\n     */\n    this._cancelTokenMap = null;\n    this.Credentials = Credentials;\n    this._options = options;\n    logger.debug('API Options', this._options);\n    if (this._cancelTokenMap == null) {\n      this._cancelTokenMap = new WeakMap();\n    }\n  }\n  /**\n  * Update AWS credentials\n  * @param {AWSCredentials} credentials - AWS credentials\n  *\n  updateCredentials(credentials: AWSCredentials) {\n      this.options.credentials = credentials;\n  }\n  */\n  /**\n   * Basic HTTP request. Customizable\n   * @param {string | ApiInfo } urlOrApiInfo - Full request URL or Api information\n   * @param {string} method - Request HTTP method\n   * @param {json} [init] - Request extra params\n   * @return {Promise} - A promise that resolves to an object with response status and JSON data, if successful.\n   */\n  RestClient.prototype.ajax = function (urlOrApiInfo, method, init) {\n    return __awaiter(this, void 0, void 0, function () {\n      var parsed_url, url, region, service, custom_header, params, libraryHeaders, initParams, isAllResponse, custom_header_obj, _a, _b, search, parsedUrl, credentials, error_1, signedParams, response, error_2, headers, dateHeader, responseDate, requestDate, rawClientDate;\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            logger.debug(method, urlOrApiInfo);\n            region = 'us-east-1';\n            service = 'execute-api';\n            custom_header = undefined;\n            if (typeof urlOrApiInfo === 'string') {\n              parsed_url = this._parseUrl(urlOrApiInfo);\n              url = urlOrApiInfo;\n            } else {\n              url = urlOrApiInfo.endpoint, custom_header = urlOrApiInfo.custom_header, region = urlOrApiInfo.region, service = urlOrApiInfo.service;\n              parsed_url = this._parseUrl(urlOrApiInfo.endpoint);\n            }\n            params = {\n              method: method,\n              url: url,\n              host: parsed_url.host,\n              path: parsed_url.path,\n              headers: {},\n              data: null,\n              responseType: 'json',\n              timeout: 0,\n              cancelToken: null\n            };\n            libraryHeaders = {};\n            initParams = Object.assign({}, init);\n            isAllResponse = initParams.response;\n            if (initParams.body) {\n              if (typeof FormData === 'function' && initParams.body instanceof FormData) {\n                libraryHeaders['Content-Type'] = 'multipart/form-data';\n                params.data = initParams.body;\n              } else {\n                libraryHeaders['Content-Type'] = 'application/json; charset=UTF-8';\n                params.data = JSON.stringify(initParams.body);\n              }\n            }\n            if (initParams.responseType) {\n              params.responseType = initParams.responseType;\n            }\n            if (initParams.withCredentials) {\n              params['withCredentials'] = initParams.withCredentials;\n            }\n            if (initParams.timeout) {\n              params.timeout = initParams.timeout;\n            }\n            if (initParams.cancellableToken) {\n              params.cancelToken = initParams.cancellableToken.token;\n            }\n            params['signerServiceInfo'] = initParams.signerServiceInfo;\n            if (!(typeof custom_header === 'function')) return [3 /*break*/, 2];\n            return [4 /*yield*/, custom_header()];\n          case 1:\n            _a = _c.sent();\n            return [3 /*break*/, 3];\n          case 2:\n            _a = undefined;\n            _c.label = 3;\n          case 3:\n            custom_header_obj = _a;\n            params.headers = __assign(__assign(__assign({}, libraryHeaders), custom_header_obj), initParams.headers);\n            _b = parse(url, true, true), search = _b.search, parsedUrl = __rest(_b, [\"search\"]);\n            params.url = format(__assign(__assign({}, parsedUrl), {\n              query: __assign(__assign({}, parsedUrl.query), initParams.queryStringParameters || {})\n            }));\n            // Do not sign the request if client has added 'Authorization' header,\n            // which means custom authorizer.\n            if (typeof params.headers['Authorization'] !== 'undefined') {\n              params.headers = Object.keys(params.headers).reduce(function (acc, k) {\n                if (params.headers[k]) {\n                  acc[k] = params.headers[k];\n                }\n                return acc;\n                // tslint:disable-next-line:align\n              }, {});\n              return [2 /*return*/, this._request(params, isAllResponse)];\n            }\n            _c.label = 4;\n          case 4:\n            _c.trys.push([4, 6,, 7]);\n            return [4 /*yield*/, this.Credentials.get()];\n          case 5:\n            credentials = _c.sent();\n            return [3 /*break*/, 7];\n          case 6:\n            error_1 = _c.sent();\n            logger.debug('No credentials available, the request will be unsigned');\n            return [2 /*return*/, this._request(params, isAllResponse)];\n          case 7:\n            _c.trys.push([7, 9,, 10]);\n            signedParams = this._sign(__assign({}, params), credentials, {\n              region: region,\n              service: service\n            });\n            return [4 /*yield*/, axios(signedParams)];\n          case 8:\n            response = _c.sent();\n            return [2 /*return*/, isAllResponse ? response : response.data];\n          case 9:\n            error_2 = _c.sent();\n            logger.debug(error_2);\n            if (DateUtils.isClockSkewError(error_2)) {\n              headers = error_2.response.headers;\n              dateHeader = headers && (headers.date || headers.Date);\n              responseDate = new Date(dateHeader);\n              requestDate = DateUtils.getDateFromHeaderString(signedParams.headers['x-amz-date']);\n              // Compare local clock to the server clock\n              if (DateUtils.isClockSkewed(responseDate)) {\n                rawClientDate = requestDate.getTime() - DateUtils.getClockOffset();\n                DateUtils.setClockOffset(responseDate.getTime() - rawClientDate);\n                return [2 /*return*/, this.ajax(urlOrApiInfo, method, init)];\n              }\n            }\n            throw error_2;\n          case 10:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\n   * GET HTTP request\n   * @param {string | ApiInfo } urlOrApiInfo - Full request URL or Api information\n   * @param {JSON} init - Request extra params\n   * @return {Promise} - A promise that resolves to an object with response status and JSON data, if successful.\n   */\n  RestClient.prototype.get = function (urlOrApiInfo, init) {\n    return this.ajax(urlOrApiInfo, 'GET', init);\n  };\n  /**\n   * PUT HTTP request\n   * @param {string | ApiInfo } urlOrApiInfo - Full request URL or Api information\n   * @param {json} init - Request extra params\n   * @return {Promise} - A promise that resolves to an object with response status and JSON data, if successful.\n   */\n  RestClient.prototype.put = function (urlOrApiInfo, init) {\n    return this.ajax(urlOrApiInfo, 'PUT', init);\n  };\n  /**\n   * PATCH HTTP request\n   * @param {string | ApiInfo } urlOrApiInfo - Full request URL or Api information\n   * @param {json} init - Request extra params\n   * @return {Promise} - A promise that resolves to an object with response status and JSON data, if successful.\n   */\n  RestClient.prototype.patch = function (urlOrApiInfo, init) {\n    return this.ajax(urlOrApiInfo, 'PATCH', init);\n  };\n  /**\n   * POST HTTP request\n   * @param {string | ApiInfo } urlOrApiInfo - Full request URL or Api information\n   * @param {json} init - Request extra params\n   * @return {Promise} - A promise that resolves to an object with response status and JSON data, if successful.\n   */\n  RestClient.prototype.post = function (urlOrApiInfo, init) {\n    return this.ajax(urlOrApiInfo, 'POST', init);\n  };\n  /**\n   * DELETE HTTP request\n   * @param {string | ApiInfo } urlOrApiInfo - Full request URL or Api information\n   * @param {json} init - Request extra params\n   * @return {Promise} - A promise that resolves to an object with response status and JSON data, if successful.\n   */\n  RestClient.prototype.del = function (urlOrApiInfo, init) {\n    return this.ajax(urlOrApiInfo, 'DELETE', init);\n  };\n  /**\n   * HEAD HTTP request\n   * @param {string | ApiInfo } urlOrApiInfo - Full request URL or Api information\n   * @param {json} init - Request extra params\n   * @return {Promise} - A promise that resolves to an object with response status and JSON data, if successful.\n   */\n  RestClient.prototype.head = function (urlOrApiInfo, init) {\n    return this.ajax(urlOrApiInfo, 'HEAD', init);\n  };\n  /**\n   * Cancel an inflight API request\n   * @param {Promise<any>} request - The request promise to cancel\n   * @param {string} [message] - A message to include in the cancelation exception\n   */\n  RestClient.prototype.cancel = function (request, message) {\n    var source = this._cancelTokenMap.get(request);\n    if (source) {\n      source.cancel(message);\n      return true;\n    }\n    return false;\n  };\n  /**\n   * Check if the request has a corresponding cancel token in the WeakMap.\n   * @params request - The request promise\n   * @return if the request has a corresponding cancel token.\n   */\n  RestClient.prototype.hasCancelToken = function (request) {\n    return this._cancelTokenMap.has(request);\n  };\n  /**\n   * Checks to see if an error thrown is from an api request cancellation\n   * @param {any} error - Any error\n   * @return {boolean} - A boolean indicating if the error was from an api request cancellation\n   */\n  RestClient.prototype.isCancel = function (error) {\n    return axios.isCancel(error);\n  };\n  /**\n   * Retrieves a new and unique cancel token which can be\n   * provided in an axios request to be cancelled later.\n   */\n  RestClient.prototype.getCancellableToken = function () {\n    return axios.CancelToken.source();\n  };\n  /**\n   * Updates the weakmap with a response promise and its\n   * cancel token such that the cancel token can be easily\n   * retrieved (and used for cancelling the request)\n   */\n  RestClient.prototype.updateRequestToBeCancellable = function (promise, cancelTokenSource) {\n    this._cancelTokenMap.set(promise, cancelTokenSource);\n  };\n  /**\n   * Getting endpoint for API\n   * @param {string} apiName - The name of the api\n   * @return {string} - The endpoint of the api\n   */\n  RestClient.prototype.endpoint = function (apiName) {\n    var _this = this;\n    var cloud_logic_array = this._options.endpoints;\n    var response = '';\n    if (!Array.isArray(cloud_logic_array)) {\n      return response;\n    }\n    cloud_logic_array.forEach(function (v) {\n      if (v.name === apiName) {\n        response = v.endpoint;\n        if (typeof v.region === 'string') {\n          _this._region = v.region;\n        } else if (typeof _this._options.region === 'string') {\n          _this._region = _this._options.region;\n        }\n        if (typeof v.service === 'string') {\n          _this._service = v.service || 'execute-api';\n        } else {\n          _this._service = 'execute-api';\n        }\n        if (typeof v.custom_header === 'function') {\n          _this._custom_header = v.custom_header;\n        } else {\n          _this._custom_header = undefined;\n        }\n      }\n    });\n    return response;\n  };\n  /** private methods **/\n  RestClient.prototype._sign = function (params, credentials, _a) {\n    var service = _a.service,\n      region = _a.region;\n    var signerServiceInfoParams = params.signerServiceInfo,\n      otherParams = __rest(params, [\"signerServiceInfo\"]);\n    var endpoint_region = region || this._region || this._options.region;\n    var endpoint_service = service || this._service || this._options.service;\n    var creds = {\n      secret_key: credentials.secretAccessKey,\n      access_key: credentials.accessKeyId,\n      session_token: credentials.sessionToken\n    };\n    var endpointInfo = {\n      region: endpoint_region,\n      service: endpoint_service\n    };\n    var signerServiceInfo = Object.assign(endpointInfo, signerServiceInfoParams);\n    var signed_params = Signer.sign(otherParams, creds, signerServiceInfo);\n    if (signed_params.data) {\n      signed_params.body = signed_params.data;\n    }\n    logger.debug('Signed Request: ', signed_params);\n    delete signed_params.headers['host'];\n    return signed_params;\n  };\n  RestClient.prototype._request = function (params, isAllResponse) {\n    if (isAllResponse === void 0) {\n      isAllResponse = false;\n    }\n    return axios(params).then(function (response) {\n      return isAllResponse ? response : response.data;\n    }).catch(function (error) {\n      logger.debug(error);\n      throw error;\n    });\n  };\n  RestClient.prototype._parseUrl = function (url) {\n    var parts = url.split('/');\n    return {\n      host: parts[2],\n      path: '/' + parts.slice(3).join('/')\n    };\n  };\n  return RestClient;\n}();\nexport { RestClient };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}