{"ast":null,"code":"import { __values } from \"tslib\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { isFieldAssociation } from '../types';\n/**\n * Defines a relationship from a LOCAL model.field to a REMOTE model.field and helps\n * navigate the relationship, providing a simplified peek at the relationship details\n * pertinent to setting FK's and constructing join conditions.\n *\n * Because I mean, relationships are tough.\n *\n */\nvar ModelRelationship = /** @class */function () {\n  /**\n   * @param modelDefinition The \"local\" model.\n   * @param field The \"local\" model field.\n   */\n  function ModelRelationship(model, field) {\n    if (!isFieldAssociation(model.schema, field)) {\n      throw new Error(model.schema.name + \".\" + field + \" is not a relationship.\");\n    }\n    this.localModel = model;\n    this._field = field;\n  }\n  /**\n   * Returns a ModelRelationship for the the given model and field if the pair\n   * indicates a relationship to another model. Else, returns `null`.\n   *\n   * @param model The model the relationship field exists in.\n   * @param field The field that may relates the local model to the remote model.\n   */\n  ModelRelationship.from = function (model, field) {\n    if (isFieldAssociation(model.schema, field)) {\n      return new this(model, field);\n    } else {\n      return null;\n    }\n  };\n  /**\n   * Enumerates all valid `ModelRelationship`'s on the given model.\n   *\n   * @param model The model definition to enumerate relationships of.\n   */\n  ModelRelationship.allFrom = function (model) {\n    var e_1, _a;\n    var relationships = [];\n    try {\n      for (var _b = __values(Object.keys(model.schema.fields)), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var field = _c.value;\n        var relationship = ModelRelationship.from(model, field);\n        relationship && relationships.push(relationship);\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n    return relationships;\n  };\n  Object.defineProperty(ModelRelationship.prototype, \"localDefinition\", {\n    get: function () {\n      return this.localModel.schema;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ModelRelationship.prototype, \"field\", {\n    /**\n     * The virtual/computed field on the local model that should contain\n     * the related model.\n     */\n    get: function () {\n      return this._field;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ModelRelationship.prototype, \"localConstructor\", {\n    /**\n     * The constructor that can be used to query DataStore or create instance for\n     * the local model.\n     */\n    get: function () {\n      return this.localModel.builder;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ModelRelationship.prototype, \"type\", {\n    /**\n     * The name/type of the relationship the local model has with the remote model\n     * via the defined local model field.\n     */\n    get: function () {\n      return this.localAssocation.connectionType;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ModelRelationship.prototype, \"localAssocation\", {\n    /**\n     * Raw details about the local FK as-is from the local model's field definition in\n     * the schema. This field requires interpretation.\n     *\n     * @see localJoinFields\n     * @see localAssociatedWith\n     */\n    get: function () {\n      return this.localDefinition.fields[this.field].association;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ModelRelationship.prototype, \"localJoinFields\", {\n    /**\n     * The field names on the local model that can be used to query or queried to match\n     * with instances of the remote model.\n     *\n     * Fields are returned in-order to match the order of `this.remoteKeyFields`.\n     */\n    get: function () {\n      /**\n       * This is relatively straightforward, actually.\n       *\n       * If we have explicitly stated targetNames, codegen is telling us authoritatively\n       * to use those fields for this relationship. The local model \"points to\" fields\n       * in the remote one.\n       *\n       * In other cases, the remote model points to this one's\n       */\n      if (this.localAssocation.targetName) {\n        // This case is theoretically unnecessary going forward.\n        return [this.localAssocation.targetName];\n      } else if (this.localAssocation.targetNames) {\n        return this.localAssocation.targetNames;\n      } else {\n        return this.localPKFields;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ModelRelationship.prototype, \"localPKFields\", {\n    /**\n     * The field names on the local model that uniquely identify it.\n     *\n     * These fields may or may not be relevant to the join fields.\n     */\n    get: function () {\n      return this.localModel.pkField;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ModelRelationship.prototype, \"remoteDefinition\", {\n    get: function () {\n      var _a;\n      return (_a = this.remoteModelType.modelConstructor) === null || _a === void 0 ? void 0 : _a.schema;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ModelRelationship.prototype, \"remoteModelType\", {\n    get: function () {\n      return this.localDefinition.fields[this.field].type;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ModelRelationship.prototype, \"remoteModelConstructor\", {\n    /**\n     * Constructor that can be used to query DataStore or create instances for\n     * the remote model.\n     */\n    get: function () {\n      return this.remoteModelType.modelConstructor.builder;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ModelRelationship.prototype, \"remotePKFields\", {\n    /**\n     * The field names on the remote model that uniquely identify it.\n     *\n     * These fields may or may not be relevant to the join fields.\n     */\n    get: function () {\n      var _a;\n      return ((_a = this.remoteModelType.modelConstructor) === null || _a === void 0 ? void 0 : _a.pkField) || ['id'];\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ModelRelationship.prototype, \"localAssociatedWith\", {\n    /**\n     * The `associatedWith` fields from the local perspective.\n     *\n     * When present, these fields indicate which fields on the remote model to use\n     * when looking for a remote association and/or determining the final remote\n     * key fields.\n     */\n    get: function () {\n      if (this.localAssocation.connectionType === 'HAS_MANY' || this.localAssocation.connectionType === 'HAS_ONE') {\n        // This de-arraying is theoretically unnecessary going forward.\n        return Array.isArray(this.localAssocation.associatedWith) ? this.localAssocation.associatedWith : [this.localAssocation.associatedWith];\n      } else {\n        return undefined;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ModelRelationship.prototype, \"explicitRemoteAssociation\", {\n    /**\n     * The `remote` model's associated field's `assocation` metadata, if\n     * present.\n     *\n     * This is used when determining if the remote model's associated field\n     * specifies which FK fields to use. If this value is `undefined`, the\n     * name of the remote field (`this.localAssociatedWith`) *is* the remote\n     * key field.\n     */\n    get: function () {\n      var _a;\n      if (this.localAssociatedWith) {\n        if (this.localAssociatedWith.length === 1) {\n          return (_a = this.remoteDefinition.fields[this.localAssociatedWith[0]]) === null || _a === void 0 ? void 0 : _a.association;\n        } else {\n          return undefined;\n        }\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ModelRelationship.prototype, \"remoteJoinFields\", {\n    /**\n     * The field names on the remote model that can used to query or queried to match\n     * with instances of the local model.\n     *\n     * Fields are returned in-order to match the order of `this.localKeyFields`.\n     */\n    get: function () {\n      /**\n       * If the local relationship explicitly names \"associated with\" fields, we\n       * need to see if this points direction to a reciprocating assocation. If it\n       * does, the remote assocation indicates what fields to use.\n       */\n      var _a, _b, _c;\n      if ((_a = this.explicitRemoteAssociation) === null || _a === void 0 ? void 0 : _a.targetName) {\n        // This case is theoretically unnecessary going forward.\n        return [this.explicitRemoteAssociation.targetName];\n      } else if ((_b = this.explicitRemoteAssociation) === null || _b === void 0 ? void 0 : _b.targetNames) {\n        return (_c = this.explicitRemoteAssociation) === null || _c === void 0 ? void 0 : _c.targetNames;\n      } else if (this.localAssociatedWith) {\n        return this.localAssociatedWith;\n      } else {\n        return this.remotePKFields;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ModelRelationship.prototype, \"isComplete\", {\n    /**\n     * Whether this relationship everything necessary to get, set, and query from\n     * the perspective of the local model provided at instantiation.\n     */\n    get: function () {\n      return this.localJoinFields.length > 0 && this.remoteJoinFields.length > 0;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Creates an FK mapper object with respect to the given related instance.\n   *\n   * E.g., if the local FK fields are `[parentId, parentName]` and point to\n   * `[customId, name]` on the remote model, `createLocalFKObject(remote)`\n   * will return:\n   *\n   * ```\n   * {\n   * \tparentId: remote.customId,\n   * \tparentName: remote.name\n   * }\n   * ```\n   *\n   * @param remote The remote related instance.\n   */\n  ModelRelationship.prototype.createLocalFKObject = function (remote) {\n    var fk = {};\n    for (var i = 0; i < this.localJoinFields.length; i++) {\n      fk[this.localJoinFields[i]] = remote[this.remoteJoinFields[i]];\n    }\n    return fk;\n  };\n  /**\n   * Creates an query mapper object to help fetch the remote instance(s) or\n   * `null` if any of the necessary local fields are `null` or `undefined`.\n   *\n   * E.g., if the local FK fields are `[parentId, parentName]` and point to\n   * `[customId, name]` on the remote model, `createLocalFKObject(remote)`\n   * will return:\n   *\n   * ```\n   * {\n   * \tcustomId: local.parentId\n   * \tname: local.parentName\n   * }\n   * ```\n   *\n   * If the local fields are not populated, returns\n   *\n   * @param local The local instance.\n   */\n  ModelRelationship.prototype.createRemoteQueryObject = function (local) {\n    var query = {};\n    for (var i = 0; i < this.remoteJoinFields.length; i++) {\n      var localValue = local[this.localJoinFields[i]];\n      if (localValue === null || localValue === undefined) return null;\n      query[this.remoteJoinFields[i]] = local[this.localJoinFields[i]];\n    }\n    return query;\n  };\n  return ModelRelationship;\n}();\nexport { ModelRelationship };\n//# sourceMappingURL=relationship.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}