{"ast":null,"code":"import { NO_RETRY_INCREMENT, RETRY_COST, TIMEOUT_RETRY_COST } from \"./constants\";\nexport var getDefaultRetryQuota = function (initialRetryTokens, options) {\n  var _a, _b, _c;\n  var MAX_CAPACITY = initialRetryTokens;\n  var noRetryIncrement = (_a = options === null || options === void 0 ? void 0 : options.noRetryIncrement) !== null && _a !== void 0 ? _a : NO_RETRY_INCREMENT;\n  var retryCost = (_b = options === null || options === void 0 ? void 0 : options.retryCost) !== null && _b !== void 0 ? _b : RETRY_COST;\n  var timeoutRetryCost = (_c = options === null || options === void 0 ? void 0 : options.timeoutRetryCost) !== null && _c !== void 0 ? _c : TIMEOUT_RETRY_COST;\n  var availableCapacity = initialRetryTokens;\n  var getCapacityAmount = function (error) {\n    return error.name === \"TimeoutError\" ? timeoutRetryCost : retryCost;\n  };\n  var hasRetryTokens = function (error) {\n    return getCapacityAmount(error) <= availableCapacity;\n  };\n  var retrieveRetryTokens = function (error) {\n    if (!hasRetryTokens(error)) {\n      throw new Error(\"No retry token available\");\n    }\n    var capacityAmount = getCapacityAmount(error);\n    availableCapacity -= capacityAmount;\n    return capacityAmount;\n  };\n  var releaseRetryTokens = function (capacityReleaseAmount) {\n    availableCapacity += capacityReleaseAmount !== null && capacityReleaseAmount !== void 0 ? capacityReleaseAmount : noRetryIncrement;\n    availableCapacity = Math.min(availableCapacity, MAX_CAPACITY);\n  };\n  return Object.freeze({\n    hasRetryTokens: hasRetryTokens,\n    retrieveRetryTokens: retrieveRetryTokens,\n    releaseRetryTokens: releaseRetryTokens\n  });\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}