{"ast":null,"code":"import { __awaiter, __generator } from \"tslib\";\nimport { HttpRequest, HttpResponse } from \"@aws-sdk/protocol-http\";\nimport { isThrottlingError } from \"@aws-sdk/service-error-classification\";\nimport { v4 } from \"uuid\";\nimport { DEFAULT_MAX_ATTEMPTS, RETRY_MODES } from \"./config\";\nimport { DEFAULT_RETRY_DELAY_BASE, INITIAL_RETRY_TOKENS, INVOCATION_ID_HEADER, REQUEST_HEADER, THROTTLING_RETRY_DELAY_BASE } from \"./constants\";\nimport { getDefaultRetryQuota } from \"./defaultRetryQuota\";\nimport { defaultDelayDecider } from \"./delayDecider\";\nimport { defaultRetryDecider } from \"./retryDecider\";\nvar StandardRetryStrategy = function () {\n  function StandardRetryStrategy(maxAttemptsProvider, options) {\n    var _a, _b, _c;\n    this.maxAttemptsProvider = maxAttemptsProvider;\n    this.mode = RETRY_MODES.STANDARD;\n    this.retryDecider = (_a = options === null || options === void 0 ? void 0 : options.retryDecider) !== null && _a !== void 0 ? _a : defaultRetryDecider;\n    this.delayDecider = (_b = options === null || options === void 0 ? void 0 : options.delayDecider) !== null && _b !== void 0 ? _b : defaultDelayDecider;\n    this.retryQuota = (_c = options === null || options === void 0 ? void 0 : options.retryQuota) !== null && _c !== void 0 ? _c : getDefaultRetryQuota(INITIAL_RETRY_TOKENS);\n  }\n  StandardRetryStrategy.prototype.shouldRetry = function (error, attempts, maxAttempts) {\n    return attempts < maxAttempts && this.retryDecider(error) && this.retryQuota.hasRetryTokens(error);\n  };\n  StandardRetryStrategy.prototype.getMaxAttempts = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var maxAttempts, error_1;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            _a.trys.push([0, 2,, 3]);\n            return [4, this.maxAttemptsProvider()];\n          case 1:\n            maxAttempts = _a.sent();\n            return [3, 3];\n          case 2:\n            error_1 = _a.sent();\n            maxAttempts = DEFAULT_MAX_ATTEMPTS;\n            return [3, 3];\n          case 3:\n            return [2, maxAttempts];\n        }\n      });\n    });\n  };\n  StandardRetryStrategy.prototype.retry = function (next, args, options) {\n    return __awaiter(this, void 0, void 0, function () {\n      var retryTokenAmount, attempts, totalDelay, maxAttempts, request, _loop_1, this_1, state_1;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            attempts = 0;\n            totalDelay = 0;\n            return [4, this.getMaxAttempts()];\n          case 1:\n            maxAttempts = _a.sent();\n            request = args.request;\n            if (HttpRequest.isInstance(request)) {\n              request.headers[INVOCATION_ID_HEADER] = v4();\n            }\n            _loop_1 = function () {\n              var _b, response, output, e_1, err, delayFromDecider, delayFromResponse, delay_1;\n              return __generator(this, function (_c) {\n                switch (_c.label) {\n                  case 0:\n                    _c.trys.push([0, 4,, 7]);\n                    if (HttpRequest.isInstance(request)) {\n                      request.headers[REQUEST_HEADER] = \"attempt=\".concat(attempts + 1, \"; max=\").concat(maxAttempts);\n                    }\n                    if (!(options === null || options === void 0 ? void 0 : options.beforeRequest)) return [3, 2];\n                    return [4, options.beforeRequest()];\n                  case 1:\n                    _c.sent();\n                    _c.label = 2;\n                  case 2:\n                    return [4, next(args)];\n                  case 3:\n                    _b = _c.sent(), response = _b.response, output = _b.output;\n                    if (options === null || options === void 0 ? void 0 : options.afterRequest) {\n                      options.afterRequest(response);\n                    }\n                    this_1.retryQuota.releaseRetryTokens(retryTokenAmount);\n                    output.$metadata.attempts = attempts + 1;\n                    output.$metadata.totalRetryDelay = totalDelay;\n                    return [2, {\n                      value: {\n                        response: response,\n                        output: output\n                      }\n                    }];\n                  case 4:\n                    e_1 = _c.sent();\n                    err = asSdkError(e_1);\n                    attempts++;\n                    if (!this_1.shouldRetry(err, attempts, maxAttempts)) return [3, 6];\n                    retryTokenAmount = this_1.retryQuota.retrieveRetryTokens(err);\n                    delayFromDecider = this_1.delayDecider(isThrottlingError(err) ? THROTTLING_RETRY_DELAY_BASE : DEFAULT_RETRY_DELAY_BASE, attempts);\n                    delayFromResponse = getDelayFromRetryAfterHeader(err.$response);\n                    delay_1 = Math.max(delayFromResponse || 0, delayFromDecider);\n                    totalDelay += delay_1;\n                    return [4, new Promise(function (resolve) {\n                      return setTimeout(resolve, delay_1);\n                    })];\n                  case 5:\n                    _c.sent();\n                    return [2, \"continue\"];\n                  case 6:\n                    if (!err.$metadata) {\n                      err.$metadata = {};\n                    }\n                    err.$metadata.attempts = attempts;\n                    err.$metadata.totalRetryDelay = totalDelay;\n                    throw err;\n                  case 7:\n                    return [2];\n                }\n              });\n            };\n            this_1 = this;\n            _a.label = 2;\n          case 2:\n            if (!true) return [3, 4];\n            return [5, _loop_1()];\n          case 3:\n            state_1 = _a.sent();\n            if (typeof state_1 === \"object\") return [2, state_1.value];\n            return [3, 2];\n          case 4:\n            return [2];\n        }\n      });\n    });\n  };\n  return StandardRetryStrategy;\n}();\nexport { StandardRetryStrategy };\nvar getDelayFromRetryAfterHeader = function (response) {\n  if (!HttpResponse.isInstance(response)) return;\n  var retryAfterHeaderName = Object.keys(response.headers).find(function (key) {\n    return key.toLowerCase() === \"retry-after\";\n  });\n  if (!retryAfterHeaderName) return;\n  var retryAfter = response.headers[retryAfterHeaderName];\n  var retryAfterSeconds = Number(retryAfter);\n  if (!Number.isNaN(retryAfterSeconds)) return retryAfterSeconds * 1000;\n  var retryAfterDate = new Date(retryAfter);\n  return retryAfterDate.getTime() - Date.now();\n};\nvar asSdkError = function (error) {\n  if (error instanceof Error) return error;\n  if (error instanceof Object) return Object.assign(new Error(), error);\n  if (typeof error === \"string\") return new Error(error);\n  return new Error(\"AWS SDK error wrapper for \".concat(error));\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}