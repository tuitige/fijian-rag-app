{"ast":null,"code":"import { __assign, __awaiter, __extends, __generator, __rest } from \"tslib\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport * as Paho from '../vendor/paho-mqtt';\nimport { v4 as uuid } from 'uuid';\nimport Observable from 'zen-observable-ts';\nimport { AbstractPubSubProvider } from './PubSubProvider';\nimport { ConnectionState } from '../types/PubSub';\nimport { ConsoleLogger as Logger, Hub } from '@aws-amplify/core';\nimport { ConnectionStateMonitor, CONNECTION_CHANGE } from '../utils/ConnectionStateMonitor';\nimport { ReconnectEvent, ReconnectionMonitor } from '../utils/ReconnectionMonitor';\nimport { AMPLIFY_SYMBOL, CONNECTION_STATE_CHANGE } from './constants';\nvar logger = new Logger('MqttOverWSProvider');\nexport function mqttTopicMatch(filter, topic) {\n  var filterArray = filter.split('/');\n  var length = filterArray.length;\n  var topicArray = topic.split('/');\n  for (var i = 0; i < length; ++i) {\n    var left = filterArray[i];\n    var right = topicArray[i];\n    if (left === '#') return topicArray.length >= length;\n    if (left !== '+' && left !== right) return false;\n  }\n  return length === topicArray.length;\n}\nvar ClientsQueue = /** @class */function () {\n  function ClientsQueue() {\n    this.promises = new Map();\n  }\n  ClientsQueue.prototype.get = function (clientId, clientFactory) {\n    return __awaiter(this, void 0, void 0, function () {\n      var cachedPromise, newPromise;\n      var _this = this;\n      return __generator(this, function (_a) {\n        cachedPromise = this.promises.get(clientId);\n        if (cachedPromise) return [2 /*return*/, cachedPromise];\n        if (clientFactory) {\n          newPromise = clientFactory(clientId);\n          this.promises.set(clientId, newPromise);\n          newPromise.catch(function () {\n            return _this.promises.delete(clientId);\n          });\n          return [2 /*return*/, newPromise];\n        }\n        return [2 /*return*/, undefined];\n      });\n    });\n  };\n  Object.defineProperty(ClientsQueue.prototype, \"allClients\", {\n    get: function () {\n      return Array.from(this.promises.keys());\n    },\n    enumerable: true,\n    configurable: true\n  });\n  ClientsQueue.prototype.remove = function (clientId) {\n    this.promises.delete(clientId);\n  };\n  return ClientsQueue;\n}();\nvar dispatchPubSubEvent = function (event, data, message) {\n  Hub.dispatch('pubsub', {\n    event: event,\n    data: data,\n    message: message\n  }, 'PubSub', AMPLIFY_SYMBOL);\n};\nvar topicSymbol = typeof Symbol !== 'undefined' ? Symbol('topic') : '@@topic';\nvar MqttOverWSProvider = /** @class */function (_super) {\n  __extends(MqttOverWSProvider, _super);\n  function MqttOverWSProvider(options) {\n    if (options === void 0) {\n      options = {};\n    }\n    var _this = _super.call(this, __assign(__assign({}, options), {\n      clientId: options.clientId || uuid()\n    })) || this;\n    _this._clientsQueue = new ClientsQueue();\n    _this.connectionStateMonitor = new ConnectionStateMonitor();\n    _this.reconnectionMonitor = new ReconnectionMonitor();\n    _this._topicObservers = new Map();\n    _this._clientIdObservers = new Map();\n    // Monitor the connection health state and pass changes along to Hub\n    _this.connectionStateMonitor.connectionStateObservable.subscribe(function (connectionStateChange) {\n      dispatchPubSubEvent(CONNECTION_STATE_CHANGE, {\n        provider: _this,\n        connectionState: connectionStateChange\n      }, \"Connection state is \" + connectionStateChange);\n      _this.connectionState = connectionStateChange;\n      // Trigger reconnection when the connection is disrupted\n      if (connectionStateChange === ConnectionState.ConnectionDisrupted) {\n        _this.reconnectionMonitor.record(ReconnectEvent.START_RECONNECT);\n      } else if (connectionStateChange !== ConnectionState.Connecting) {\n        // Trigger connected to halt reconnection attempts\n        _this.reconnectionMonitor.record(ReconnectEvent.HALT_RECONNECT);\n      }\n    });\n    return _this;\n  }\n  Object.defineProperty(MqttOverWSProvider.prototype, \"clientId\", {\n    get: function () {\n      return this.options.clientId;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MqttOverWSProvider.prototype, \"endpoint\", {\n    get: function () {\n      return Promise.resolve(this.options.aws_pubsub_endpoint);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MqttOverWSProvider.prototype, \"clientsQueue\", {\n    get: function () {\n      return this._clientsQueue;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MqttOverWSProvider.prototype, \"isSSLEnabled\", {\n    get: function () {\n      return !this.options['aws_appsync_dangerously_connect_to_http_endpoint_for_testing'];\n    },\n    enumerable: true,\n    configurable: true\n  });\n  MqttOverWSProvider.prototype.getProviderName = function () {\n    return 'MqttOverWSProvider';\n  };\n  MqttOverWSProvider.prototype.onDisconnect = function (_a) {\n    var clientId = _a.clientId,\n      errorCode = _a.errorCode,\n      args = __rest(_a, [\"clientId\", \"errorCode\"]);\n    if (errorCode !== 0) {\n      logger.warn(clientId, JSON.stringify(__assign({\n        errorCode: errorCode\n      }, args), null, 2));\n      if (!clientId) {\n        return;\n      }\n      var clientIdObservers = this._clientIdObservers.get(clientId);\n      if (!clientIdObservers) {\n        return;\n      }\n      this.disconnect(clientId);\n    }\n  };\n  MqttOverWSProvider.prototype.newClient = function (_a) {\n    var url = _a.url,\n      clientId = _a.clientId;\n    return __awaiter(this, void 0, void 0, function () {\n      var client, connected;\n      var _this = this;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            logger.debug('Creating new MQTT client', clientId);\n            this.connectionStateMonitor.record(CONNECTION_CHANGE.OPENING_CONNECTION);\n            client = new Paho.Client(url, clientId);\n            client.onMessageArrived = function (_a) {\n              var topic = _a.destinationName,\n                msg = _a.payloadString;\n              _this._onMessage(topic, msg);\n            };\n            client.onConnectionLost = function (_a) {\n              var errorCode = _a.errorCode,\n                args = __rest(_a, [\"errorCode\"]);\n              _this.onDisconnect(__assign({\n                clientId: clientId,\n                errorCode: errorCode\n              }, args));\n              _this.connectionStateMonitor.record(CONNECTION_CHANGE.CLOSED);\n            };\n            return [4 /*yield*/, new Promise(function (resolve, reject) {\n              client.connect({\n                useSSL: _this.isSSLEnabled,\n                mqttVersion: 3,\n                onSuccess: function () {\n                  return resolve(true);\n                },\n                onFailure: function () {\n                  if (clientId) _this._clientsQueue.remove(clientId);\n                  _this.connectionStateMonitor.record(CONNECTION_CHANGE.CLOSED);\n                  resolve(false);\n                }\n              });\n            })];\n          case 1:\n            connected = _b.sent();\n            if (connected) {\n              this.connectionStateMonitor.record(CONNECTION_CHANGE.CONNECTION_ESTABLISHED);\n            }\n            return [2 /*return*/, client];\n        }\n      });\n    });\n  };\n  MqttOverWSProvider.prototype.connect = function (clientId, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, this.clientsQueue.get(clientId, function (clientId) {\n              return __awaiter(_this, void 0, void 0, function () {\n                var client;\n                return __generator(this, function (_a) {\n                  switch (_a.label) {\n                    case 0:\n                      return [4 /*yield*/, this.newClient(__assign(__assign({}, options), {\n                        clientId: clientId\n                      }))];\n                    case 1:\n                      client = _a.sent();\n                      if (client) {\n                        // Once connected, subscribe to all topics registered observers\n                        this._topicObservers.forEach(function (_value, key) {\n                          client.subscribe(key);\n                        });\n                      }\n                      return [2 /*return*/, client];\n                  }\n                });\n              });\n            })];\n          case 1:\n            return [2 /*return*/, _a.sent()];\n        }\n      });\n    });\n  };\n  MqttOverWSProvider.prototype.disconnect = function (clientId) {\n    return __awaiter(this, void 0, void 0, function () {\n      var client;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, this.clientsQueue.get(clientId)];\n          case 1:\n            client = _a.sent();\n            if (client && client.isConnected()) {\n              client.disconnect();\n            }\n            this.clientsQueue.remove(clientId);\n            this.connectionStateMonitor.record(CONNECTION_CHANGE.CLOSED);\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  MqttOverWSProvider.prototype.publish = function (topics, msg) {\n    return __awaiter(this, void 0, void 0, function () {\n      var targetTopics, message, client;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            targetTopics = [].concat(topics);\n            message = JSON.stringify(msg);\n            return [4 /*yield*/, this.clientsQueue.get(this.clientId)];\n          case 1:\n            client = _a.sent();\n            if (client) {\n              logger.debug('Publishing to topic(s)', targetTopics.join(','), message);\n              targetTopics.forEach(function (topic) {\n                return client.send(topic, message);\n              });\n            } else {\n              logger.debug('Publishing to topic(s) failed', targetTopics.join(','), message);\n            }\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  MqttOverWSProvider.prototype._onMessage = function (topic, msg) {\n    try {\n      var matchedTopicObservers_1 = [];\n      this._topicObservers.forEach(function (observerForTopic, observerTopic) {\n        if (mqttTopicMatch(observerTopic, topic)) {\n          matchedTopicObservers_1.push(observerForTopic);\n        }\n      });\n      var parsedMessage_1 = JSON.parse(msg);\n      if (typeof parsedMessage_1 === 'object') {\n        // @ts-ignore\n        parsedMessage_1[topicSymbol] = topic;\n      }\n      matchedTopicObservers_1.forEach(function (observersForTopic) {\n        observersForTopic.forEach(function (observer) {\n          return observer.next(parsedMessage_1);\n        });\n      });\n    } catch (error) {\n      logger.warn('Error handling message', error, msg);\n    }\n  };\n  MqttOverWSProvider.prototype.subscribe = function (topics, options) {\n    var _this = this;\n    if (options === void 0) {\n      options = {};\n    }\n    var targetTopics = [].concat(topics);\n    logger.debug('Subscribing to topic(s)', targetTopics.join(','));\n    var reconnectSubscription;\n    return new Observable(function (observer) {\n      targetTopics.forEach(function (topic) {\n        // this._topicObservers is used to notify the observers according to the topic received on the message\n        var observersForTopic = _this._topicObservers.get(topic);\n        if (!observersForTopic) {\n          observersForTopic = new Set();\n          _this._topicObservers.set(topic, observersForTopic);\n        }\n        observersForTopic.add(observer);\n      });\n      var _a = options.clientId,\n        clientId = _a === void 0 ? _this.clientId : _a;\n      // this._clientIdObservers is used to close observers when client gets disconnected\n      var observersForClientId = _this._clientIdObservers.get(clientId);\n      if (!observersForClientId) {\n        observersForClientId = new Set();\n      }\n      if (observersForClientId) {\n        observersForClientId.add(observer);\n        _this._clientIdObservers.set(clientId, observersForClientId);\n      }\n      (function () {\n        return __awaiter(_this, void 0, void 0, function () {\n          var getClient;\n          var _this = this;\n          return __generator(this, function (_a) {\n            switch (_a.label) {\n              case 0:\n                getClient = function () {\n                  return __awaiter(_this, void 0, void 0, function () {\n                    var _a, url, _b, client_1, e_1;\n                    return __generator(this, function (_c) {\n                      switch (_c.label) {\n                        case 0:\n                          _c.trys.push([0, 5,, 6]);\n                          _a = options.url;\n                          if (!(_a === void 0)) return [3 /*break*/, 2];\n                          return [4 /*yield*/, this.endpoint];\n                        case 1:\n                          _b = _c.sent();\n                          return [3 /*break*/, 3];\n                        case 2:\n                          _b = _a;\n                          _c.label = 3;\n                        case 3:\n                          url = _b;\n                          return [4 /*yield*/, this.connect(clientId, {\n                            url: url\n                          })];\n                        case 4:\n                          client_1 = _c.sent();\n                          if (client_1 !== undefined) {\n                            targetTopics.forEach(function (topic) {\n                              client_1.subscribe(topic);\n                            });\n                          }\n                          return [3 /*break*/, 6];\n                        case 5:\n                          e_1 = _c.sent();\n                          logger.debug('Error forming connection', e_1);\n                          return [3 /*break*/, 6];\n                        case 6:\n                          return [2 /*return*/];\n                      }\n                    });\n                  });\n                };\n                // Establish the initial connection\n                return [4 /*yield*/, getClient()];\n              case 1:\n                // Establish the initial connection\n                _a.sent();\n                // Add an observable to the reconnection list to manage reconnection for this subscription\n                reconnectSubscription = new Observable(function (observer) {\n                  _this.reconnectionMonitor.addObserver(observer);\n                }).subscribe(function () {\n                  getClient();\n                });\n                return [2 /*return*/];\n            }\n          });\n        });\n      })();\n      return function () {\n        return __awaiter(_this, void 0, void 0, function () {\n          var client;\n          var _this = this;\n          var _a, _b;\n          return __generator(this, function (_c) {\n            switch (_c.label) {\n              case 0:\n                return [4 /*yield*/, this.clientsQueue.get(clientId)];\n              case 1:\n                client = _c.sent();\n                reconnectSubscription === null || reconnectSubscription === void 0 ? void 0 : reconnectSubscription.unsubscribe();\n                if (client) {\n                  (_a = this._clientIdObservers.get(clientId)) === null || _a === void 0 ? void 0 : _a.delete(observer);\n                  // No more observers per client => client not needed anymore\n                  if (((_b = this._clientIdObservers.get(clientId)) === null || _b === void 0 ? void 0 : _b.size) === 0) {\n                    this.disconnect(clientId);\n                    this.connectionStateMonitor.record(CONNECTION_CHANGE.CLOSING_CONNECTION);\n                    this._clientIdObservers.delete(clientId);\n                  }\n                  targetTopics.forEach(function (topic) {\n                    var observersForTopic = _this._topicObservers.get(topic) || new Set();\n                    observersForTopic.delete(observer);\n                    // if no observers exists for the topic, topic should be removed\n                    if (observersForTopic.size === 0) {\n                      _this._topicObservers.delete(topic);\n                      if (client.isConnected()) {\n                        client.unsubscribe(topic);\n                      }\n                    }\n                  });\n                }\n                return [2 /*return*/, null];\n            }\n          });\n        });\n      };\n    });\n  };\n  return MqttOverWSProvider;\n}(AbstractPubSubProvider);\nexport { MqttOverWSProvider };\n//# sourceMappingURL=MqttOverWSProvider.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}