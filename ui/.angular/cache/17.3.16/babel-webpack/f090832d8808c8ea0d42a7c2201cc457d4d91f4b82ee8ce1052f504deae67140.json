{"ast":null,"code":"import { getActorContext as e, getActorState as t } from \"./actor.mjs\";\nconst r = e => {\n    const t = t => r => e({\n      type: t,\n      data: r\n    });\n    return {\n      initializeMachine: t(\"INIT\"),\n      resendCode: t(\"RESEND\"),\n      signOut: t(\"SIGN_OUT\"),\n      submitForm: t(\"SUBMIT\"),\n      updateForm: t(\"CHANGE\"),\n      updateBlur: t(\"BLUR\"),\n      toFederatedSignIn: t(\"FEDERATED_SIGN_IN\"),\n      toResetPassword: t(\"RESET_PASSWORD\"),\n      toSignIn: t(\"SIGN_IN\"),\n      toSignUp: t(\"SIGN_UP\"),\n      skipVerification: t(\"SKIP\")\n    };\n  },\n  n = r => {\n    var n, s, i, a, o;\n    const c = null !== (n = e(r)) && void 0 !== n ? n : {},\n      {\n        codeDeliveryDetails: u,\n        remoteError: d,\n        unverifiedContactMethods: l,\n        validationError: m,\n        totpSecretCode: h = null\n      } = c,\n      {\n        socialProviders: v\n      } = null !== (i = null === (s = r.context) || void 0 === s ? void 0 : s.config) && void 0 !== i ? i : {},\n      g = null !== (a = null == c ? void 0 : c.user) && void 0 !== a ? a : null === (o = r.context) || void 0 === o ? void 0 : o.user,\n      f = m && Object.keys(m).length > 0,\n      p = t(r),\n      S = r.hasTag(\"pending\") || (null == p ? void 0 : p.hasTag(\"pending\")),\n      I = (() => {\n        switch (!0) {\n          case r.matches(\"idle\"):\n            return \"idle\";\n          case r.matches(\"setup\"):\n            return \"setup\";\n          case r.matches(\"signOut\"):\n            return \"signOut\";\n          case r.matches(\"authenticated\"):\n            return \"authenticated\";\n          case null == p ? void 0 : p.matches(\"confirmSignUp\"):\n            return \"confirmSignUp\";\n          case null == p ? void 0 : p.matches(\"confirmSignIn\"):\n            return \"confirmSignIn\";\n          case null == p ? void 0 : p.matches(\"setupTOTP.edit\"):\n          case null == p ? void 0 : p.matches(\"setupTOTP.submit\"):\n            return \"setupTOTP\";\n          case null == p ? void 0 : p.matches(\"signIn\"):\n            return \"signIn\";\n          case null == p ? void 0 : p.matches(\"signUp\"):\n            return \"signUp\";\n          case null == p ? void 0 : p.matches(\"forceNewPassword\"):\n            return \"forceNewPassword\";\n          case null == p ? void 0 : p.matches(\"resetPassword\"):\n            return \"resetPassword\";\n          case null == p ? void 0 : p.matches(\"confirmResetPassword\"):\n            return \"confirmResetPassword\";\n          case null == p ? void 0 : p.matches(\"verifyUser\"):\n            return \"verifyUser\";\n          case null == p ? void 0 : p.matches(\"confirmVerifyUser\"):\n            return \"confirmVerifyUser\";\n          case null == p ? void 0 : p.matches(\"setupTOTP.getTotpSecretCode\"):\n          case r.matches(\"signIn.runActor\"):\n            return \"transition\";\n          default:\n            return console.debug(\"Cannot infer `route` from Authenticator state:\", r.value), null;\n        }\n      })(),\n      P = (e => {\n        switch (e) {\n          case \"idle\":\n          case \"setup\":\n            return \"configuring\";\n          case \"authenticated\":\n            return \"authenticated\";\n          default:\n            return \"unauthenticated\";\n        }\n      })(I);\n    return {\n      authStatus: P,\n      codeDeliveryDetails: u,\n      error: d,\n      hasValidationErrors: f,\n      isPending: S,\n      route: I,\n      socialProviders: v,\n      totpSecretCode: h,\n      unverifiedContactMethods: l,\n      user: g,\n      validationErrors: m\n    };\n  },\n  s = ({\n    send: e,\n    state: t\n  }) => {\n    const s = r(e),\n      i = n(t);\n    return Object.assign(Object.assign({}, s), i);\n  };\nexport { r as getSendEventAliases, n as getServiceContextFacade, s as getServiceFacade };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}