{"ast":null,"code":"import { __awaiter as e, __rest as t } from \"tslib\";\nimport { Auth as r } from \"aws-amplify\";\nimport n from \"lodash/get.js\";\nimport { createMachine as o, sendUpdate as i } from \"xstate\";\nimport { runValidators as s } from \"../../../validators/index.mjs\";\nimport { clearAttributeToVerify as a, clearChallengeName as d, clearRequiredAttributes as c, clearError as l, clearFormValues as u, clearTouched as g, clearUnverifiedContactMethods as m, clearValidationError as f, handleInput as p, handleSubmit as h, handleBlur as I, parsePhoneNumber as v, setChallengeName as S, setConfirmResetPasswordIntent as A, setConfirmSignUpIntent as U, setRequiredAttributes as E, setCredentials as y, setFieldErrors as T, setRemoteError as C, setTotpSecretCode as b, setUnverifiedContactMethods as N, setUser as w, setUsernameAuthAttributes as R } from \"../actions.mjs\";\nimport { defaultServices as P } from \"../defaultServices.mjs\";\nimport { isEmpty as V } from \"../../../utils/index.mjs\";\nconst _ = [\"SMS_MFA\", \"SOFTWARE_TOKEN_MFA\"],\n  F = e => n(e, \"data.challengeName\"),\n  O = (e, t) => e === t,\n  j = e => _.includes(e);\nfunction k({\n  services: n\n}) {\n  return o({\n    initial: \"init\",\n    id: \"signInActor\",\n    predictableActionArguments: !0,\n    states: {\n      init: {\n        always: [{\n          target: \"autoSignIn.submit\",\n          cond: \"shouldAutoSubmit\"\n        }, {\n          target: \"autoSignIn\",\n          cond: \"shouldAutoSignIn\"\n        }, {\n          target: \"signIn\"\n        }]\n      },\n      signIn: {\n        initial: \"edit\",\n        exit: [\"clearFormValues\", \"clearTouched\"],\n        states: {\n          edit: {\n            entry: \"sendUpdate\",\n            on: {\n              SUBMIT: {\n                actions: \"handleSubmit\",\n                target: \"submit\"\n              },\n              CHANGE: {\n                actions: \"handleInput\"\n              },\n              FEDERATED_SIGN_IN: \"federatedSignIn\"\n            }\n          },\n          federatedSignIn: {\n            tags: [\"pending\"],\n            entry: [\"sendUpdate\", \"clearError\"],\n            invoke: {\n              src: \"federatedSignIn\",\n              onError: {\n                actions: \"setRemoteError\"\n              }\n            }\n          },\n          submit: {\n            tags: [\"pending\"],\n            entry: [\"parsePhoneNumber\", \"clearError\", \"sendUpdate\"],\n            invoke: {\n              src: \"signIn\",\n              onDone: [{\n                cond: \"shouldSetupTOTP\",\n                actions: [\"setUser\", \"setChallengeName\"],\n                target: \"#signInActor.setupTOTP\"\n              }, {\n                cond: \"shouldConfirmSignIn\",\n                actions: [\"setUser\", \"setChallengeName\"],\n                target: \"#signInActor.confirmSignIn\"\n              }, {\n                cond: \"shouldForceChangePassword\",\n                actions: [\"setUser\", \"setChallengeName\", \"setRequiredAttributes\"],\n                target: \"#signInActor.forceNewPassword\"\n              }, {\n                actions: \"setUser\",\n                target: \"verifying\"\n              }],\n              onError: [{\n                cond: \"shouldRedirectToConfirmSignUp\",\n                actions: [\"setCredentials\", \"setConfirmSignUpIntent\"],\n                target: \"rejected\"\n              }, {\n                cond: \"shouldRedirectToConfirmResetPassword\",\n                actions: [\"setUsernameAuthAttributes\", \"setConfirmResetPasswordIntent\"],\n                target: \"rejected\"\n              }, {\n                actions: \"setRemoteError\",\n                target: \"edit\"\n              }]\n            }\n          },\n          verifying: {\n            tags: [\"pending\"],\n            entry: [\"clearError\", \"sendUpdate\"],\n            invoke: {\n              src: \"checkVerifiedContact\",\n              onDone: [{\n                cond: \"shouldRequestVerification\",\n                target: \"#signInActor.verifyUser\",\n                actions: \"setUnverifiedContactMethods\"\n              }, {\n                target: \"resolved\"\n              }],\n              onError: {\n                actions: \"setRemoteError\",\n                target: \"edit\"\n              }\n            }\n          },\n          resolved: {\n            always: \"#signInActor.resolved\"\n          },\n          rejected: {\n            always: \"#signInActor.rejected\"\n          }\n        }\n      },\n      autoSignIn: {\n        initial: \"pending\",\n        states: {\n          pending: {\n            tags: [\"pending\"],\n            entry: [\"clearError\", \"sendUpdate\"],\n            on: {\n              AUTO_SIGN_IN: [{\n                cond: \"shouldSetupTOTP\",\n                actions: [\"setUser\", \"setChallengeName\"],\n                target: \"#signInActor.setupTOTP\"\n              }, {\n                cond: \"shouldConfirmSignIn\",\n                actions: [\"setUser\", \"setChallengeName\"],\n                target: \"#signInActor.confirmSignIn\"\n              }, {\n                cond: \"shouldForceChangePassword\",\n                actions: [\"setUser\", \"setChallengeName\", \"setRequiredAttributes\"],\n                target: \"#signInActor.forceNewPassword\"\n              }, {\n                actions: \"setUser\",\n                target: \"#signInActor.resolved\"\n              }],\n              AUTO_SIGN_IN_FAILURE: {\n                actions: \"setRemoteError\",\n                target: \"pending\"\n              }\n            }\n          },\n          submit: {\n            tags: [\"pending\"],\n            entry: [\"clearError\", \"sendUpdate\"],\n            invoke: {\n              src: \"signIn\",\n              onDone: [{\n                cond: \"shouldSetupTOTP\",\n                actions: [\"setUser\", \"setChallengeName\"],\n                target: \"#signInActor.setupTOTP\"\n              }, {\n                cond: \"shouldConfirmSignIn\",\n                actions: [\"setUser\", \"setChallengeName\"],\n                target: \"#signInActor.confirmSignIn\"\n              }, {\n                cond: \"shouldForceChangePassword\",\n                actions: [\"setUser\", \"setChallengeName\", \"setRequiredAttributes\"],\n                target: \"#signInActor.forceNewPassword\"\n              }, {\n                actions: \"setUser\",\n                target: \"#signInActor.resolved\"\n              }],\n              onError: {\n                actions: \"setRemoteError\",\n                target: \"#signInActor.signIn\"\n              }\n            }\n          },\n          resolved: {\n            always: \"#signInActor.resolved\"\n          },\n          rejected: {\n            always: \"#signInActor.rejected\"\n          }\n        }\n      },\n      confirmSignIn: {\n        initial: \"edit\",\n        exit: [\"clearFormValues\", \"clearError\", \"clearTouched\"],\n        states: {\n          edit: {\n            entry: \"sendUpdate\",\n            on: {\n              SUBMIT: {\n                actions: \"handleSubmit\",\n                target: \"submit\"\n              },\n              SIGN_IN: \"#signInActor.signIn\",\n              CHANGE: {\n                actions: \"handleInput\"\n              }\n            }\n          },\n          submit: {\n            tags: [\"pending\"],\n            entry: [\"clearError\", \"sendUpdate\"],\n            invoke: {\n              src: \"confirmSignIn\",\n              onDone: {\n                target: \"#signInActor.resolved\",\n                actions: [\"setUser\", \"clearChallengeName\", \"clearRequiredAttributes\"]\n              },\n              onError: {\n                target: \"edit\",\n                actions: \"setRemoteError\"\n              }\n            }\n          }\n        }\n      },\n      forceNewPassword: {\n        type: \"parallel\",\n        exit: [\"clearFormValues\", \"clearError\", \"clearTouched\"],\n        states: {\n          validation: {\n            initial: \"pending\",\n            states: {\n              pending: {\n                invoke: {\n                  src: \"validateFields\",\n                  onDone: {\n                    target: \"valid\",\n                    actions: \"clearValidationError\"\n                  },\n                  onError: {\n                    target: \"invalid\",\n                    actions: \"setFieldErrors\"\n                  }\n                }\n              },\n              valid: {\n                entry: \"sendUpdate\"\n              },\n              invalid: {\n                entry: \"sendUpdate\"\n              }\n            },\n            on: {\n              SIGN_IN: \"#signInActor.signIn\",\n              CHANGE: {\n                actions: \"handleInput\",\n                target: \".pending\"\n              },\n              BLUR: {\n                actions: \"handleBlur\",\n                target: \".pending\"\n              }\n            }\n          },\n          submit: {\n            initial: \"idle\",\n            entry: \"clearError\",\n            states: {\n              idle: {\n                entry: \"sendUpdate\",\n                on: {\n                  SUBMIT: {\n                    actions: \"handleSubmit\",\n                    target: \"validate\"\n                  }\n                }\n              },\n              validate: {\n                entry: \"sendUpdate\",\n                invoke: {\n                  src: \"validateFields\",\n                  onDone: {\n                    target: \"pending\",\n                    actions: \"clearValidationError\"\n                  },\n                  onError: {\n                    target: \"idle\",\n                    actions: \"setFieldErrors\"\n                  }\n                }\n              },\n              pending: {\n                tags: [\"pending\"],\n                entry: [\"sendUpdate\", \"clearError\"],\n                invoke: {\n                  src: \"forceNewPassword\",\n                  onDone: [{\n                    cond: \"shouldConfirmSignIn\",\n                    actions: [\"setUser\", \"setChallengeName\"],\n                    target: \"#signInActor.confirmSignIn\"\n                  }, {\n                    cond: \"shouldSetupTOTP\",\n                    actions: [\"setUser\", \"setChallengeName\"],\n                    target: \"#signInActor.setupTOTP\"\n                  }, {\n                    target: \"resolved\",\n                    actions: [\"setUser\", \"setCredentials\"]\n                  }],\n                  onError: {\n                    target: \"idle\",\n                    actions: \"setRemoteError\"\n                  }\n                }\n              },\n              resolved: {\n                type: \"final\",\n                always: \"#signInActor.resolved\"\n              }\n            }\n          }\n        }\n      },\n      setupTOTP: {\n        initial: \"getTotpSecretCode\",\n        exit: [\"clearFormValues\", \"clearError\", \"clearTouched\"],\n        states: {\n          getTotpSecretCode: {\n            invoke: {\n              src: \"getTotpSecretCode\",\n              onDone: {\n                target: \"edit\",\n                actions: \"setTotpSecretCode\"\n              },\n              onError: {\n                target: \"edit\",\n                actions: \"setRemoteError\"\n              }\n            }\n          },\n          edit: {\n            entry: \"sendUpdate\",\n            on: {\n              SUBMIT: {\n                actions: \"handleSubmit\",\n                target: \"submit\"\n              },\n              SIGN_IN: \"#signInActor.signIn\",\n              CHANGE: {\n                actions: \"handleInput\"\n              }\n            }\n          },\n          submit: {\n            tags: [\"pending\"],\n            entry: [\"sendUpdate\", \"clearError\"],\n            invoke: {\n              src: \"verifyTotpToken\",\n              onDone: {\n                actions: [\"clearChallengeName\", \"clearRequiredAttributes\"],\n                target: \"#signInActor.resolved\"\n              },\n              onError: {\n                actions: \"setRemoteError\",\n                target: \"edit\"\n              }\n            }\n          }\n        }\n      },\n      verifyUser: {\n        initial: \"edit\",\n        exit: [\"clearFormValues\", \"clearError\", \"clearTouched\"],\n        states: {\n          edit: {\n            entry: \"sendUpdate\",\n            on: {\n              SUBMIT: {\n                actions: \"handleSubmit\",\n                target: \"submit\"\n              },\n              SKIP: \"#signInActor.resolved\",\n              CHANGE: {\n                actions: \"handleInput\"\n              }\n            }\n          },\n          submit: {\n            tags: [\"pending\"],\n            entry: \"clearError\",\n            invoke: {\n              src: \"verifyUser\",\n              onDone: {\n                target: \"#signInActor.confirmVerifyUser\"\n              },\n              onError: {\n                actions: \"setRemoteError\",\n                target: \"edit\"\n              }\n            }\n          }\n        }\n      },\n      confirmVerifyUser: {\n        initial: \"edit\",\n        exit: [\"clearFormValues\", \"clearError\", \"clearUnverifiedContactMethods\", \"clearAttributeToVerify\", \"clearTouched\"],\n        states: {\n          edit: {\n            entry: \"sendUpdate\",\n            on: {\n              SUBMIT: {\n                actions: \"handleSubmit\",\n                target: \"submit\"\n              },\n              SKIP: \"#signInActor.resolved\",\n              CHANGE: {\n                actions: \"handleInput\"\n              }\n            }\n          },\n          submit: {\n            tags: [\"pending\"],\n            entry: \"clearError\",\n            invoke: {\n              src: \"confirmVerifyUser\",\n              onDone: {\n                target: \"#signInActor.resolved\"\n              },\n              onError: {\n                actions: \"setRemoteError\",\n                target: \"edit\"\n              }\n            }\n          }\n        }\n      },\n      resolved: {\n        type: \"final\",\n        data: e => ({\n          user: e.user\n        })\n      },\n      rejected: {\n        type: \"final\",\n        data: (e, t) => ({\n          intent: e.redirectIntent,\n          authAttributes: e.authAttributes\n        })\n      }\n    }\n  }, {\n    actions: {\n      clearAttributeToVerify: a,\n      clearChallengeName: d,\n      clearRequiredAttributes: c,\n      clearError: l,\n      clearFormValues: u,\n      clearTouched: g,\n      clearUnverifiedContactMethods: m,\n      clearValidationError: f,\n      handleInput: p,\n      handleSubmit: h,\n      handleBlur: I,\n      parsePhoneNumber: v,\n      setChallengeName: S,\n      setConfirmResetPasswordIntent: A,\n      setConfirmSignUpIntent: U,\n      setRequiredAttributes: E,\n      setCredentials: y,\n      setFieldErrors: T,\n      setRemoteError: C,\n      setTotpSecretCode: b,\n      setUnverifiedContactMethods: N,\n      setUser: w,\n      setUsernameAuthAttributes: R,\n      sendUpdate: i()\n    },\n    guards: {\n      shouldAutoSignIn: e => \"autoSignIn\" === (null == e ? void 0 : e.intent),\n      shouldAutoSubmit: e => \"autoSignInSubmit\" === (null == e ? void 0 : e.intent),\n      shouldConfirmSignIn: (e, t) => j(F(t)),\n      shouldForceChangePassword: (e, t) => O(F(t), \"NEW_PASSWORD_REQUIRED\"),\n      shouldRedirectToConfirmResetPassword: (e, t) => \"PasswordResetRequiredException\" === t.data.code,\n      shouldRedirectToConfirmSignUp: (e, t) => \"UserNotConfirmedException\" === t.data.code,\n      shouldRequestVerification: (e, t) => {\n        const {\n          unverified: r,\n          verified: n\n        } = t.data;\n        return V(n) && !V(r);\n      },\n      shouldSetupTOTP: (e, t) => O(F(t), \"MFA_SETUP\")\n    },\n    services: {\n      signIn(t) {\n        return e(this, void 0, void 0, function* () {\n          const {\n              authAttributes: e = {},\n              formValues: r = {}\n            } = t,\n            o = Object.assign(Object.assign({}, e), r),\n            {\n              username: i,\n              password: s\n            } = o;\n          return yield n.handleSignIn({\n            username: i,\n            password: s\n          });\n        });\n      },\n      confirmSignIn(t) {\n        return e(this, void 0, void 0, function* () {\n          const {\n              challengeName: e,\n              user: o\n            } = t,\n            {\n              confirmation_code: i\n            } = t.formValues,\n            s = j(e) ? e : void 0;\n          return yield n.handleConfirmSignIn({\n            user: o,\n            code: i,\n            mfaType: s\n          }), yield r.currentAuthenticatedUser();\n        });\n      },\n      forceNewPassword(n) {\n        return e(this, void 0, void 0, function* () {\n          const {\n            user: e,\n            formValues: o\n          } = n;\n          let i,\n            {\n              password: s,\n              confirm_password: a,\n              phone_number: d,\n              country_code: c\n            } = o,\n            l = t(o, [\"password\", \"confirm_password\", \"phone_number\", \"country_code\"]);\n          d && (i = `${c}${d}`.replace(/[^A-Z0-9+]/gi, \"\"), l = Object.assign(Object.assign({}, l), {\n            phone_number: i\n          }));\n          try {\n            const t = yield r.completeNewPassword(e, s, l);\n            return t.challengeName ? t : r.currentAuthenticatedUser();\n          } catch (e) {\n            return Promise.reject(e);\n          }\n        });\n      },\n      getTotpSecretCode(t) {\n        return e(this, void 0, void 0, function* () {\n          const {\n            user: e\n          } = t;\n          return r.setupTOTP(e);\n        });\n      },\n      verifyTotpToken(t) {\n        return e(this, void 0, void 0, function* () {\n          const {\n              formValues: e,\n              user: n\n            } = t,\n            {\n              confirmation_code: o\n            } = e;\n          return r.verifyTotpToken(n, o);\n        });\n      },\n      federatedSignIn(t, n) {\n        return e(this, void 0, void 0, function* () {\n          const {\n            provider: e\n          } = n.data;\n          return yield r.federatedSignIn({\n            provider: e\n          });\n        });\n      },\n      checkVerifiedContact(t) {\n        return e(this, void 0, void 0, function* () {\n          const {\n            user: e\n          } = t;\n          return yield r.verifiedContact(e);\n        });\n      },\n      verifyUser(t) {\n        return e(this, void 0, void 0, function* () {\n          const {\n              unverifiedAttr: e\n            } = t.formValues,\n            n = yield r.verifyCurrentUserAttribute(e);\n          return t.attributeToVerify = e, n;\n        });\n      },\n      confirmVerifyUser(t) {\n        return e(this, void 0, void 0, function* () {\n          const {\n              attributeToVerify: e\n            } = t,\n            {\n              confirmation_code: n\n            } = t.formValues;\n          return yield r.verifyCurrentUserAttributeSubmit(e, n);\n        });\n      },\n      validateFields(t) {\n        return e(this, void 0, void 0, function* () {\n          return s(t.formValues, t.touched, t.passwordSettings, [P.validateFormPassword, P.validateConfirmPassword]);\n        });\n      }\n    }\n  });\n}\nexport { k as signInActor };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}