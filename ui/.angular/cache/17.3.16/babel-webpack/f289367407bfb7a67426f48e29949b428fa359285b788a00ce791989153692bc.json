{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nimport { DateUtils } from './Util';\nimport { presignUrl, signRequest, TOKEN_QUERY_PARAM } from './clients/middleware/signing/signer/signatureV4';\nvar IOT_SERVICE_NAME = 'iotdevicegateway';\n// Best practice regex to parse the service and region from an AWS endpoint\nvar AWS_ENDPOINT_REGEX = /([^\\.]+)\\.(?:([^\\.]*)\\.)?amazonaws\\.com(.cn)?$/;\nvar Signer = /** @class */function () {\n  function Signer() {}\n  /**\n  * Sign a HTTP request, add 'Authorization' header to request param\n  * @method sign\n  * @memberof Signer\n  * @static\n  *\n  * @param {object} request - HTTP request object\n  <pre>\n  request: {\n      method: GET | POST | PUT ...\n      url: ...,\n      headers: {\n          header1: ...\n      },\n      data: data\n  }\n  </pre>\n  * @param {object} access_info - AWS access credential info\n  <pre>\n  access_info: {\n      access_key: ...,\n      secret_key: ...,\n      session_token: ...\n  }\n  </pre>\n  * @param {object} [service_info] - AWS service type and region, optional,\n  *                                  if not provided then parse out from url\n  <pre>\n  service_info: {\n      service: ...,\n      region: ...\n  }\n  </pre>\n  *\n  * @returns {object} Signed HTTP request\n  */\n  Signer.sign = function (request, accessInfo, serviceInfo) {\n    request.headers = request.headers || {};\n    if (request.body && !request.data) {\n      throw new Error('The attribute \"body\" was found on the request object. Please use the attribute \"data\" instead.');\n    }\n    var requestToSign = __assign(__assign({}, request), {\n      body: request.data,\n      url: new URL(request.url)\n    });\n    var options = getOptions(requestToSign, accessInfo, serviceInfo);\n    var signedRequest = signRequest(requestToSign, options);\n    // Prior to using `signRequest`, Signer accepted urls as strings and outputted urls as string. Coerce the property\n    // back to a string so as not to disrupt consumers of Signer.\n    signedRequest.url = signedRequest.url.toString();\n    // HTTP headers should be case insensitive but, to maintain parity with the previous Signer implementation and\n    // limit the impact of this implementation swap, replace lowercased headers with title cased ones.\n    signedRequest.headers.Authorization = signedRequest.headers.authorization;\n    signedRequest.headers['X-Amz-Security-Token'] = signedRequest.headers['x-amz-security-token'];\n    delete signedRequest.headers.authorization;\n    delete signedRequest.headers['x-amz-security-token'];\n    return signedRequest;\n  };\n  Signer.signUrl = function (urlOrRequest, accessInfo, serviceInfo, expiration) {\n    var urlToSign = typeof urlOrRequest === 'object' ? urlOrRequest.url : urlOrRequest;\n    var method = typeof urlOrRequest === 'object' ? urlOrRequest.method : 'GET';\n    var body = typeof urlOrRequest === 'object' ? urlOrRequest.body : undefined;\n    var presignable = {\n      body: body,\n      method: method,\n      url: new URL(urlToSign)\n    };\n    var options = getOptions(presignable, accessInfo, serviceInfo, expiration);\n    var signedUrl = presignUrl(presignable, options);\n    if (accessInfo.session_token && !sessionTokenRequiredInSigning(options.signingService)) {\n      signedUrl.searchParams.append(TOKEN_QUERY_PARAM, accessInfo.session_token);\n    }\n    return signedUrl.toString();\n  };\n  return Signer;\n}();\nexport { Signer };\nvar getOptions = function (request, accessInfo, serviceInfo, expiration) {\n  var _a = accessInfo !== null && accessInfo !== void 0 ? accessInfo : {},\n    access_key = _a.access_key,\n    secret_key = _a.secret_key,\n    session_token = _a.session_token;\n  var _b = parseServiceInfo(request.url),\n    urlRegion = _b.region,\n    urlService = _b.service;\n  var _c = serviceInfo !== null && serviceInfo !== void 0 ? serviceInfo : {},\n    _d = _c.region,\n    region = _d === void 0 ? urlRegion : _d,\n    _e = _c.service,\n    service = _e === void 0 ? urlService : _e;\n  var credentials = __assign({\n    accessKeyId: access_key,\n    secretAccessKey: secret_key\n  }, sessionTokenRequiredInSigning(service) ? {\n    sessionToken: session_token\n  } : {});\n  return __assign({\n    credentials: credentials,\n    signingDate: DateUtils.getDateWithClockOffset(),\n    signingRegion: region,\n    signingService: service\n  }, expiration && {\n    expiration: expiration\n  });\n};\n// TODO: V6 investigate whether add to custom clients' general signer implementation.\nvar parseServiceInfo = function (url) {\n  var _a;\n  var host = url.host;\n  var matched = (_a = host.match(AWS_ENDPOINT_REGEX)) !== null && _a !== void 0 ? _a : [];\n  var parsed = matched.slice(1, 3);\n  if (parsed[1] === 'es') {\n    // Elastic Search\n    parsed = parsed.reverse();\n  }\n  return {\n    service: parsed[0],\n    region: parsed[1]\n  };\n};\n// IoT service does not allow the session token in the canonical request\n// https://docs.aws.amazon.com/general/latest/gr/sigv4-add-signature-to-request.html\n// TODO: V6 investigate whether add to custom clients' general signer implementation.\nvar sessionTokenRequiredInSigning = function (service) {\n  return service !== IOT_SERVICE_NAME;\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}