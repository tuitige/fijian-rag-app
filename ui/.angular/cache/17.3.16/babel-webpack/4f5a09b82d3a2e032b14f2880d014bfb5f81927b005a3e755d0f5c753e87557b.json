{"ast":null,"code":"import { __assign, __awaiter, __generator, __read, __spread, __values } from \"tslib\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { Buffer } from 'buffer';\nimport { monotonicFactory } from 'ulid';\nimport { v4 as uuid } from 'uuid';\nimport { produce, applyPatches } from 'immer';\nimport { isPredicateGroup, isPredicateObj, SortDirection, isModelAttributeKey, isModelAttributePrimaryKey, isModelAttributeCompositeKey, LimitTimerRaceResolvedValues } from './types';\nimport { WordArray } from 'amazon-cognito-identity-js';\nimport { ModelSortPredicateCreator } from './predicates';\nexport var ID = 'id';\n/**\n * Used by the Async Storage Adapter to concatenate key values\n * for a record. For instance, if a model has the following keys:\n * `customId: ID! @primaryKey(sortKeyFields: [\"createdAt\"])`,\n * we concatenate the `customId` and `createdAt` as:\n * `12-234-5#2022-09-28T00:00:00.000Z`\n */\nexport var DEFAULT_PRIMARY_KEY_VALUE_SEPARATOR = '#';\n/**\n * Used for generating spinal-cased index name from an array of\n * key field names.\n * E.g. for keys `[id, title]` => 'id-title'\n */\nexport var IDENTIFIER_KEY_SEPARATOR = '-';\nexport var errorMessages = {\n  idEmptyString: 'An index field cannot contain an empty string value',\n  queryByPkWithCompositeKeyPresent: 'Models with composite primary keys cannot be queried by a single key value. Use object literal syntax for composite keys instead: https://docs.amplify.aws/lib/datastore/advanced-workflows/q/platform/js/#querying-records-with-custom-primary-keys',\n  deleteByPkWithCompositeKeyPresent: 'Models with composite primary keys cannot be deleted by a single key value, unless using a predicate. Use object literal syntax for composite keys instead: https://docs.amplify.aws/lib/datastore/advanced-workflows/q/platform/js/#querying-records-with-custom-primary-keys',\n  observeWithObjectLiteral: 'Object literal syntax cannot be used with observe. Use a predicate instead: https://docs.amplify.aws/lib/datastore/data-access/q/platform/js/#predicates'\n};\nexport var NAMESPACES = /*#__PURE__*/function (NAMESPACES) {\n  NAMESPACES[\"DATASTORE\"] = \"datastore\";\n  NAMESPACES[\"USER\"] = \"user\";\n  NAMESPACES[\"SYNC\"] = \"sync\";\n  NAMESPACES[\"STORAGE\"] = \"storage\";\n  return NAMESPACES;\n}(NAMESPACES || {});\nvar DATASTORE = NAMESPACES.DATASTORE;\nvar USER = NAMESPACES.USER;\nvar SYNC = NAMESPACES.SYNC;\nvar STORAGE = NAMESPACES.STORAGE;\nexport { USER, SYNC, STORAGE, DATASTORE };\nexport var exhaustiveCheck = function (obj, throwOnError) {\n  if (throwOnError === void 0) {\n    throwOnError = true;\n  }\n  if (throwOnError) {\n    throw new Error(\"Invalid \" + obj);\n  }\n};\nexport var isNullOrUndefined = function (val) {\n  return typeof val === 'undefined' || val === undefined || val === null;\n};\nexport var validatePredicate = function (model, groupType, predicatesOrGroups) {\n  var filterType;\n  var isNegation = false;\n  if (predicatesOrGroups.length === 0) {\n    return true;\n  }\n  switch (groupType) {\n    case 'not':\n      filterType = 'every';\n      isNegation = true;\n      break;\n    case 'and':\n      filterType = 'every';\n      break;\n    case 'or':\n      filterType = 'some';\n      break;\n    default:\n      throw new Error(\"Invalid \" + groupType);\n  }\n  var result = predicatesOrGroups[filterType](function (predicateOrGroup) {\n    if (isPredicateObj(predicateOrGroup)) {\n      var field = predicateOrGroup.field,\n        operator = predicateOrGroup.operator,\n        operand = predicateOrGroup.operand;\n      var value = model[field];\n      return validatePredicateField(value, operator, operand);\n    }\n    if (isPredicateGroup(predicateOrGroup)) {\n      var type = predicateOrGroup.type,\n        predicates = predicateOrGroup.predicates;\n      return validatePredicate(model, type, predicates);\n    }\n    throw new Error('Not a predicate or group');\n  });\n  return isNegation ? !result : result;\n};\nexport var validatePredicateField = function (value, operator, operand) {\n  switch (operator) {\n    case 'ne':\n      return value !== operand;\n    case 'eq':\n      return value === operand;\n    case 'le':\n      return value <= operand;\n    case 'lt':\n      return value < operand;\n    case 'ge':\n      return value >= operand;\n    case 'gt':\n      return value > operand;\n    case 'between':\n      var _c = __read(operand, 2),\n        min = _c[0],\n        max = _c[1];\n      return value >= min && value <= max;\n    case 'beginsWith':\n      return !isNullOrUndefined(value) && value.startsWith(operand);\n    case 'contains':\n      return !isNullOrUndefined(value) && value.indexOf(operand) > -1;\n    case 'notContains':\n      return isNullOrUndefined(value) || value.indexOf(operand) === -1;\n    default:\n      return false;\n  }\n};\nexport var isModelConstructor = function (obj) {\n  return obj && typeof obj.copyOf === 'function';\n};\nvar nonModelClasses = new WeakSet();\nexport function registerNonModelClass(clazz) {\n  nonModelClasses.add(clazz);\n}\nexport var isNonModelConstructor = function (obj) {\n  return nonModelClasses.has(obj);\n};\nvar topologicallySortedModels = new WeakMap();\nexport var traverseModel = function (srcModelName, instance, namespace, modelInstanceCreator, getModelConstructorByModelName) {\n  var modelConstructor = getModelConstructorByModelName(namespace.name, srcModelName);\n  var result = [];\n  var newInstance = modelConstructor.copyOf(instance, function () {});\n  result.unshift({\n    modelName: srcModelName,\n    item: newInstance,\n    instance: newInstance\n  });\n  if (!topologicallySortedModels.has(namespace)) {\n    topologicallySortedModels.set(namespace, Array.from(namespace.modelTopologicalOrdering.keys()));\n  }\n  var sortedModels = topologicallySortedModels.get(namespace);\n  result.sort(function (a, b) {\n    return sortedModels.indexOf(a.modelName) - sortedModels.indexOf(b.modelName);\n  });\n  return result;\n};\nvar privateModeCheckResult;\nexport var isPrivateMode = function () {\n  return new Promise(function (resolve) {\n    var dbname = uuid();\n    var db;\n    var isPrivate = function () {\n      privateModeCheckResult = false;\n      resolve(true);\n    };\n    var isNotPrivate = function () {\n      return __awaiter(void 0, void 0, void 0, function () {\n        return __generator(this, function (_c) {\n          switch (_c.label) {\n            case 0:\n              if (!(db && db.result && typeof db.result.close === 'function')) return [3 /*break*/, 2];\n              return [4 /*yield*/, db.result.close()];\n            case 1:\n              _c.sent();\n              _c.label = 2;\n            case 2:\n              return [4 /*yield*/, indexedDB.deleteDatabase(dbname)];\n            case 3:\n              _c.sent();\n              privateModeCheckResult = true;\n              return [2 /*return*/, resolve(false)];\n          }\n        });\n      });\n    };\n    if (privateModeCheckResult === true) {\n      return isNotPrivate();\n    }\n    if (privateModeCheckResult === false) {\n      return isPrivate();\n    }\n    if (indexedDB === null) return isPrivate();\n    db = indexedDB.open(dbname);\n    db.onerror = isPrivate;\n    db.onsuccess = isNotPrivate;\n  });\n};\nvar safariCompatabilityModeResult;\n/**\n * Whether the browser's implementation of IndexedDB breaks on array lookups\n * against composite indexes whose keypath contains a single column.\n *\n * E.g., Whether `store.createIndex(indexName, ['id'])` followed by\n * `store.index(indexName).get([1])` will *ever* return records.\n *\n * In all known, modern Safari browsers as of Q4 2022, the query against an index like\n * this will *always* return `undefined`. So, the index needs to be created as a scalar.\n */\nexport var isSafariCompatabilityMode = function () {\n  return __awaiter(void 0, void 0, void 0, function () {\n    var dbName_1, storeName_1, indexName_1, db_1, rwTx, rwStore, result, error_1;\n    return __generator(this, function (_c) {\n      switch (_c.label) {\n        case 0:\n          _c.trys.push([0, 6,, 7]);\n          dbName_1 = uuid();\n          storeName_1 = 'indexedDBFeatureProbeStore';\n          indexName_1 = 'idx';\n          if (indexedDB === null) return [2 /*return*/, false];\n          if (safariCompatabilityModeResult !== undefined) {\n            return [2 /*return*/, safariCompatabilityModeResult];\n          }\n          return [4 /*yield*/, new Promise(function (resolve) {\n            var dbOpenRequest = indexedDB.open(dbName_1);\n            dbOpenRequest.onerror = function () {\n              return resolve(false);\n            };\n            dbOpenRequest.onsuccess = function () {\n              var db = dbOpenRequest.result;\n              resolve(db);\n            };\n            dbOpenRequest.onupgradeneeded = function (event) {\n              var _c;\n              var db = (_c = event === null || event === void 0 ? void 0 : event.target) === null || _c === void 0 ? void 0 : _c.result;\n              db.onerror = function () {\n                return resolve(false);\n              };\n              var store = db.createObjectStore(storeName_1, {\n                autoIncrement: true\n              });\n              store.createIndex(indexName_1, ['id']);\n            };\n          })];\n        case 1:\n          db_1 = _c.sent();\n          if (!db_1) {\n            throw new Error('Could not open probe DB');\n          }\n          rwTx = db_1.transaction(storeName_1, 'readwrite');\n          rwStore = rwTx.objectStore(storeName_1);\n          rwStore.add({\n            id: 1\n          });\n          rwTx.commit();\n          return [4 /*yield*/, new Promise(function (resolve) {\n            var tx = db_1.transaction(storeName_1, 'readonly');\n            var store = tx.objectStore(storeName_1);\n            var index = store.index(indexName_1);\n            var getRequest = index.get([1]);\n            getRequest.onerror = function () {\n              return resolve(false);\n            };\n            getRequest.onsuccess = function (event) {\n              var _c;\n              resolve((_c = event === null || event === void 0 ? void 0 : event.target) === null || _c === void 0 ? void 0 : _c.result);\n            };\n          })];\n        case 2:\n          result = _c.sent();\n          if (!(db_1 && typeof db_1.close === 'function')) return [3 /*break*/, 4];\n          return [4 /*yield*/, db_1.close()];\n        case 3:\n          _c.sent();\n          _c.label = 4;\n        case 4:\n          return [4 /*yield*/, indexedDB.deleteDatabase(dbName_1)];\n        case 5:\n          _c.sent();\n          if (result === undefined) {\n            safariCompatabilityModeResult = true;\n          } else {\n            safariCompatabilityModeResult = false;\n          }\n          return [3 /*break*/, 7];\n        case 6:\n          error_1 = _c.sent();\n          safariCompatabilityModeResult = false;\n          return [3 /*break*/, 7];\n        case 7:\n          return [2 /*return*/, safariCompatabilityModeResult];\n      }\n    });\n  });\n};\nvar randomBytes = function (nBytes) {\n  return Buffer.from(new WordArray().random(nBytes).toString(), 'hex');\n};\nvar prng = function () {\n  return randomBytes(1).readUInt8(0) / 0xff;\n};\nexport function monotonicUlidFactory(seed) {\n  var ulid = monotonicFactory(prng);\n  return function () {\n    return ulid(seed);\n  };\n}\n/**\n * Uses performance.now() if available, otherwise, uses Date.now() (e.g. react native without a polyfill)\n *\n * The values returned by performance.now() always increase at a constant rate,\n * independent of the system clock (which might be adjusted manually or skewed\n * by software like NTP).\n *\n * Otherwise, performance.timing.navigationStart + performance.now() will be\n * approximately equal to Date.now()\n *\n * See: https://developer.mozilla.org/en-US/docs/Web/API/Performance/now#Example\n */\nexport function getNow() {\n  if (typeof performance !== 'undefined' && performance && typeof performance.now === 'function') {\n    return performance.now() | 0; // convert to integer\n  } else {\n    return Date.now();\n  }\n}\nexport function sortCompareFunction(sortPredicates) {\n  return function compareFunction(a, b) {\n    var e_1, _c;\n    try {\n      // enable multi-field sort by iterating over predicates until\n      // a comparison returns -1 or 1\n      for (var sortPredicates_1 = __values(sortPredicates), sortPredicates_1_1 = sortPredicates_1.next(); !sortPredicates_1_1.done; sortPredicates_1_1 = sortPredicates_1.next()) {\n        var predicate = sortPredicates_1_1.value;\n        var field = predicate.field,\n          sortDirection = predicate.sortDirection;\n        // reverse result when direction is descending\n        var sortMultiplier = sortDirection === SortDirection.ASCENDING ? 1 : -1;\n        if (a[field] < b[field]) {\n          return -1 * sortMultiplier;\n        }\n        if (a[field] > b[field]) {\n          return 1 * sortMultiplier;\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (sortPredicates_1_1 && !sortPredicates_1_1.done && (_c = sortPredicates_1.return)) _c.call(sortPredicates_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n    return 0;\n  };\n}\n// deep compare any 2 values\n// primitives or object types (including arrays, Sets, and Maps)\n// returns true if equal by value\n// if nullish is true, treat undefined and null values as equal\n// to normalize for GQL response values for undefined fields\nexport function valuesEqual(valA, valB, nullish) {\n  var e_2, _c;\n  if (nullish === void 0) {\n    nullish = false;\n  }\n  var a = valA;\n  var b = valB;\n  var nullishCompare = function (_a, _b) {\n    return (_a === undefined || _a === null) && (_b === undefined || _b === null);\n  };\n  // if one of the values is a primitive and the other is an object\n  if (a instanceof Object && !(b instanceof Object) || !(a instanceof Object) && b instanceof Object) {\n    return false;\n  }\n  // compare primitive types\n  if (!(a instanceof Object)) {\n    if (nullish && nullishCompare(a, b)) {\n      return true;\n    }\n    return a === b;\n  }\n  // make sure object types match\n  if (Array.isArray(a) && !Array.isArray(b) || Array.isArray(b) && !Array.isArray(a)) {\n    return false;\n  }\n  if (a instanceof Set && b instanceof Set) {\n    a = __spread(a);\n    b = __spread(b);\n  }\n  if (a instanceof Map && b instanceof Map) {\n    a = Object.fromEntries(a);\n    b = Object.fromEntries(b);\n  }\n  var aKeys = Object.keys(a);\n  var bKeys = Object.keys(b);\n  // last condition is to ensure that [] !== [null] even if nullish. However [undefined] === [null] when nullish\n  if (aKeys.length !== bKeys.length && (!nullish || Array.isArray(a))) {\n    return false;\n  }\n  // iterate through the longer set of keys\n  // e.g., for a nullish comparison of a={ a: 1 } and b={ a: 1, b: null }\n  // we want to iterate through bKeys\n  var keys = aKeys.length >= bKeys.length ? aKeys : bKeys;\n  try {\n    for (var keys_1 = __values(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {\n      var key = keys_1_1.value;\n      var aVal = a[key];\n      var bVal = b[key];\n      if (!valuesEqual(aVal, bVal, nullish)) {\n        return false;\n      }\n    }\n  } catch (e_2_1) {\n    e_2 = {\n      error: e_2_1\n    };\n  } finally {\n    try {\n      if (keys_1_1 && !keys_1_1.done && (_c = keys_1.return)) _c.call(keys_1);\n    } finally {\n      if (e_2) throw e_2.error;\n    }\n  }\n  return true;\n}\n/**\n * Statelessly extracts the specified page from an array.\n *\n * @param records - The source array to extract a page from.\n * @param pagination - A definition of the page to extract.\n * @returns This items from `records` matching the `pagination` definition.\n */\nexport function inMemoryPagination(records, pagination) {\n  if (pagination && records.length > 1) {\n    if (pagination.sort) {\n      var sortPredicates = ModelSortPredicateCreator.getPredicates(pagination.sort);\n      if (sortPredicates.length) {\n        var compareFn = sortCompareFunction(sortPredicates);\n        records.sort(compareFn);\n      }\n    }\n    var _c = pagination.page,\n      page = _c === void 0 ? 0 : _c,\n      _d = pagination.limit,\n      limit = _d === void 0 ? 0 : _d;\n    var start = Math.max(0, page * limit) || 0;\n    var end = limit > 0 ? start + limit : records.length;\n    return records.slice(start, end);\n  }\n  return records;\n}\n/**\n * An `aysnc` implementation of `Array.some()`. Returns as soon as a match is found.\n * @param items The items to check.\n * @param matches The async matcher function, expected to\n * return Promise<boolean>: `true` for a matching item, `false` otherwise.\n * @returns A `Promise<boolean>`, `true` if \"some\" items match; `false` otherwise.\n */\nexport function asyncSome(items, matches) {\n  return __awaiter(this, void 0, void 0, function () {\n    var items_1, items_1_1, item, e_3_1;\n    var e_3, _c;\n    return __generator(this, function (_d) {\n      switch (_d.label) {\n        case 0:\n          _d.trys.push([0, 5, 6, 7]);\n          items_1 = __values(items), items_1_1 = items_1.next();\n          _d.label = 1;\n        case 1:\n          if (!!items_1_1.done) return [3 /*break*/, 4];\n          item = items_1_1.value;\n          return [4 /*yield*/, matches(item)];\n        case 2:\n          if (_d.sent()) {\n            return [2 /*return*/, true];\n          }\n          _d.label = 3;\n        case 3:\n          items_1_1 = items_1.next();\n          return [3 /*break*/, 1];\n        case 4:\n          return [3 /*break*/, 7];\n        case 5:\n          e_3_1 = _d.sent();\n          e_3 = {\n            error: e_3_1\n          };\n          return [3 /*break*/, 7];\n        case 6:\n          try {\n            if (items_1_1 && !items_1_1.done && (_c = items_1.return)) _c.call(items_1);\n          } finally {\n            if (e_3) throw e_3.error;\n          }\n          return [7 /*endfinally*/];\n        case 7:\n          return [2 /*return*/, false];\n      }\n    });\n  });\n}\n/**\n * An `aysnc` implementation of `Array.every()`. Returns as soon as a non-match is found.\n * @param items The items to check.\n * @param matches The async matcher function, expected to\n * return Promise<boolean>: `true` for a matching item, `false` otherwise.\n * @returns A `Promise<boolean>`, `true` if every item matches; `false` otherwise.\n */\nexport function asyncEvery(items, matches) {\n  return __awaiter(this, void 0, void 0, function () {\n    var items_2, items_2_1, item, e_4_1;\n    var e_4, _c;\n    return __generator(this, function (_d) {\n      switch (_d.label) {\n        case 0:\n          _d.trys.push([0, 5, 6, 7]);\n          items_2 = __values(items), items_2_1 = items_2.next();\n          _d.label = 1;\n        case 1:\n          if (!!items_2_1.done) return [3 /*break*/, 4];\n          item = items_2_1.value;\n          return [4 /*yield*/, matches(item)];\n        case 2:\n          if (!_d.sent()) {\n            return [2 /*return*/, false];\n          }\n          _d.label = 3;\n        case 3:\n          items_2_1 = items_2.next();\n          return [3 /*break*/, 1];\n        case 4:\n          return [3 /*break*/, 7];\n        case 5:\n          e_4_1 = _d.sent();\n          e_4 = {\n            error: e_4_1\n          };\n          return [3 /*break*/, 7];\n        case 6:\n          try {\n            if (items_2_1 && !items_2_1.done && (_c = items_2.return)) _c.call(items_2);\n          } finally {\n            if (e_4) throw e_4.error;\n          }\n          return [7 /*endfinally*/];\n        case 7:\n          return [2 /*return*/, true];\n      }\n    });\n  });\n}\n/**\n * An `async` implementation of `Array.filter()`. Returns after all items have been filtered.\n * TODO: Return AsyncIterable.\n * @param items The items to filter.\n * @param matches The `async` matcher function, expected to\n * return Promise<boolean>: `true` for a matching item, `false` otherwise.\n * @returns A `Promise<T>` of matching items.\n */\nexport function asyncFilter(items, matches) {\n  return __awaiter(this, void 0, void 0, function () {\n    var results, items_3, items_3_1, item, e_5_1;\n    var e_5, _c;\n    return __generator(this, function (_d) {\n      switch (_d.label) {\n        case 0:\n          results = [];\n          _d.label = 1;\n        case 1:\n          _d.trys.push([1, 6, 7, 8]);\n          items_3 = __values(items), items_3_1 = items_3.next();\n          _d.label = 2;\n        case 2:\n          if (!!items_3_1.done) return [3 /*break*/, 5];\n          item = items_3_1.value;\n          return [4 /*yield*/, matches(item)];\n        case 3:\n          if (_d.sent()) {\n            results.push(item);\n          }\n          _d.label = 4;\n        case 4:\n          items_3_1 = items_3.next();\n          return [3 /*break*/, 2];\n        case 5:\n          return [3 /*break*/, 8];\n        case 6:\n          e_5_1 = _d.sent();\n          e_5 = {\n            error: e_5_1\n          };\n          return [3 /*break*/, 8];\n        case 7:\n          try {\n            if (items_3_1 && !items_3_1.done && (_c = items_3.return)) _c.call(items_3);\n          } finally {\n            if (e_5) throw e_5.error;\n          }\n          return [7 /*endfinally*/];\n        case 8:\n          return [2 /*return*/, results];\n      }\n    });\n  });\n}\nexport var isAWSDate = function (val) {\n  return !!/^\\d{4}-\\d{2}-\\d{2}(Z|[+-]\\d{2}:\\d{2}($|:\\d{2}))?$/.exec(val);\n};\nexport var isAWSTime = function (val) {\n  return !!/^\\d{2}:\\d{2}(:\\d{2}(.\\d+)?)?(Z|[+-]\\d{2}:\\d{2}($|:\\d{2}))?$/.exec(val);\n};\nexport var isAWSDateTime = function (val) {\n  return !!/^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}(:\\d{2}(.\\d+)?)?(Z|[+-]\\d{2}:\\d{2}($|:\\d{2}))?$/.exec(val);\n};\nexport var isAWSTimestamp = function (val) {\n  return !!/^\\d+$/.exec(String(val));\n};\nexport var isAWSEmail = function (val) {\n  return !!/^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/.exec(val);\n};\nexport var isAWSJSON = function (val) {\n  try {\n    JSON.parse(val);\n    return true;\n  } catch (_c) {\n    return false;\n  }\n};\nexport var isAWSURL = function (val) {\n  try {\n    return !!new URL(val);\n  } catch (_c) {\n    return false;\n  }\n};\nexport var isAWSPhone = function (val) {\n  return !!/^\\+?\\d[\\d\\s-]+$/.exec(val);\n};\nexport var isAWSIPAddress = function (val) {\n  return !!/((^((([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))$)|(^((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(%.+)?$))$/.exec(val);\n};\nvar DeferredPromise = /** @class */function () {\n  function DeferredPromise() {\n    var self = this;\n    this.promise = new Promise(function (resolve, reject) {\n      self.resolve = resolve;\n      self.reject = reject;\n    });\n  }\n  return DeferredPromise;\n}();\nexport { DeferredPromise };\nvar DeferredCallbackResolver = /** @class */function () {\n  function DeferredCallbackResolver(options) {\n    this.limitPromise = new DeferredPromise();\n    this.raceInFlight = false;\n    this.callback = function () {};\n    this.defaultErrorHandler = function (msg) {\n      if (msg === void 0) {\n        msg = 'DeferredCallbackResolver error';\n      }\n      throw new Error(msg);\n    };\n    this.callback = options.callback;\n    this.errorHandler = options.errorHandler || this.defaultErrorHandler;\n    this.maxInterval = options.maxInterval || 2000;\n  }\n  DeferredCallbackResolver.prototype.startTimer = function () {\n    var _this = this;\n    this.timerPromise = new Promise(function (resolve, reject) {\n      _this.timer = setTimeout(function () {\n        resolve(LimitTimerRaceResolvedValues.TIMER);\n      }, _this.maxInterval);\n    });\n  };\n  DeferredCallbackResolver.prototype.racePromises = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var winner, err_1;\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            _c.trys.push([0, 2, 3, 4]);\n            this.raceInFlight = true;\n            this.startTimer();\n            return [4 /*yield*/, Promise.race([this.timerPromise, this.limitPromise.promise])];\n          case 1:\n            winner = _c.sent();\n            this.callback();\n            return [3 /*break*/, 4];\n          case 2:\n            err_1 = _c.sent();\n            this.errorHandler(err_1);\n            return [3 /*break*/, 4];\n          case 3:\n            // reset for the next race\n            this.clear();\n            this.raceInFlight = false;\n            this.limitPromise = new DeferredPromise();\n            return [2 /*return*/, winner];\n          case 4:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  DeferredCallbackResolver.prototype.start = function () {\n    if (!this.raceInFlight) this.racePromises();\n  };\n  DeferredCallbackResolver.prototype.clear = function () {\n    clearTimeout(this.timer);\n  };\n  DeferredCallbackResolver.prototype.resolve = function () {\n    this.limitPromise.resolve(LimitTimerRaceResolvedValues.LIMIT);\n  };\n  return DeferredCallbackResolver;\n}();\nexport { DeferredCallbackResolver };\n/**\n * merge two sets of patches created by immer produce.\n * newPatches take precedent over oldPatches for patches modifying the same path.\n * In the case many consecutive pathces are merged the original model should\n * always be the root model.\n *\n * Example:\n * A -> B, patches1\n * B -> C, patches2\n *\n * mergePatches(A, patches1, patches2) to get patches for A -> C\n *\n * @param originalSource the original Model the patches should be applied to\n * @param oldPatches immer produce patch list\n * @param newPatches immer produce patch list (will take precedence)\n * @return merged patches\n */\nexport function mergePatches(originalSource, oldPatches, newPatches) {\n  var patchesToMerge = oldPatches.concat(newPatches);\n  var patches;\n  produce(originalSource, function (draft) {\n    applyPatches(draft, patchesToMerge);\n  }, function (p) {\n    patches = p;\n  });\n  return patches;\n}\nexport var getStorename = function (namespace, modelName) {\n  var storeName = namespace + \"_\" + modelName;\n  return storeName;\n};\n//#region Key Utils\n/*\n  When we have GSI(s) with composite sort keys defined on a model\n    There are some very particular rules regarding which fields must be included in the update mutation input\n    The field selection becomes more complex as the number of GSIs with composite sort keys grows\n\n    To summarize: any time we update a field that is part of the composite sort key of a GSI, we must include:\n     1. all of the other fields in that composite sort key\n     2. all of the fields from any other composite sort key that intersect with the fields from 1.\n\n     E.g.,\n     Model @model\n        @key(name: 'key1' fields: ['hk', 'a', 'b', 'c'])\n        @key(name: 'key2' fields: ['hk', 'a', 'b', 'd'])\n        @key(name: 'key3' fields: ['hk', 'x', 'y', 'z'])\n\n    Model.a is updated => include ['a', 'b', 'c', 'd']\n    Model.c is updated => include ['a', 'b', 'c', 'd']\n    Model.d is updated => include ['a', 'b', 'c', 'd']\n    Model.x is updated => include ['x', 'y', 'z']\n\n    This function accepts a model's attributes and returns grouped sets of composite key fields\n    Using our example Model above, the function will return:\n    [\n        Set('a', 'b', 'c', 'd'),\n        Set('x', 'y', 'z'),\n    ]\n\n    This gives us the opportunity to correctly include the required fields for composite keys\n    When crafting the mutation input in Storage.getUpdateMutationInput\n\n    See 'processCompositeKeys' test in util.test.ts for more examples\n*/\nexport var processCompositeKeys = function (attributes) {\n  var extractCompositeSortKey = function (_c) {\n    var\n      // ignore the HK (fields[0]) we only need to include the composite sort key fields[1...n]\n      _d = __read(_c.properties.fields),\n      sortKeyFields = _d.slice(1);\n    return sortKeyFields;\n  };\n  var compositeKeyFields = attributes.filter(isModelAttributeCompositeKey).map(extractCompositeSortKey);\n  /*\n      if 2 sets of fields have any intersecting fields => combine them into 1 union set\n      e.g., ['a', 'b', 'c'] and ['a', 'b', 'd'] => ['a', 'b', 'c', 'd']\n  */\n  var combineIntersecting = function (fields) {\n    return fields.reduce(function (combined, sortKeyFields) {\n      var sortKeyFieldsSet = new Set(sortKeyFields);\n      if (combined.length === 0) {\n        combined.push(sortKeyFieldsSet);\n        return combined;\n      }\n      // does the current set share values with another set we've already added to `combined`?\n      var intersectingSetIdx = combined.findIndex(function (existingSet) {\n        return __spread(existingSet).some(function (f) {\n          return sortKeyFieldsSet.has(f);\n        });\n      });\n      if (intersectingSetIdx > -1) {\n        var union = new Set(__spread(combined[intersectingSetIdx], sortKeyFieldsSet));\n        // combine the current set with the intersecting set we found above\n        combined[intersectingSetIdx] = union;\n      } else {\n        // none of the sets in `combined` have intersecting values with the current set\n        combined.push(sortKeyFieldsSet);\n      }\n      return combined;\n    }, []);\n  };\n  var initial = combineIntersecting(compositeKeyFields);\n  // a single pass pay not be enough to correctly combine all the fields\n  // call the function once more to get a final merged list of sets\n  var combined = combineIntersecting(initial);\n  return combined;\n};\nexport var extractKeyIfExists = function (modelDefinition) {\n  var _c;\n  var keyAttribute = (_c = modelDefinition === null || modelDefinition === void 0 ? void 0 : modelDefinition.attributes) === null || _c === void 0 ? void 0 : _c.find(isModelAttributeKey);\n  return keyAttribute;\n};\nexport var extractPrimaryKeyFieldNames = function (modelDefinition) {\n  var keyAttribute = extractKeyIfExists(modelDefinition);\n  if (keyAttribute && isModelAttributePrimaryKey(keyAttribute)) {\n    return keyAttribute.properties.fields;\n  }\n  return [ID];\n};\nexport var extractPrimaryKeyValues = function (model, keyFields) {\n  return keyFields.map(function (key) {\n    return model[key];\n  });\n};\nexport var extractPrimaryKeysAndValues = function (model, keyFields) {\n  var primaryKeysAndValues = {};\n  keyFields.forEach(function (key) {\n    return primaryKeysAndValues[key] = model[key];\n  });\n  return primaryKeysAndValues;\n};\n// IdentifierFields<ManagedIdentifier>\n// Default behavior without explicit @primaryKey defined\nexport var isIdManaged = function (modelDefinition) {\n  var keyAttribute = extractKeyIfExists(modelDefinition);\n  if (keyAttribute && isModelAttributePrimaryKey(keyAttribute)) {\n    return false;\n  }\n  return true;\n};\n// IdentifierFields<OptionallyManagedIdentifier>\n// @primaryKey with explicit `id` in the PK. Single key or composite\nexport var isIdOptionallyManaged = function (modelDefinition) {\n  var keyAttribute = extractKeyIfExists(modelDefinition);\n  if (keyAttribute && isModelAttributePrimaryKey(keyAttribute)) {\n    return keyAttribute.properties.fields[0] === ID;\n  }\n  return false;\n};\nexport var establishRelationAndKeys = function (namespace) {\n  var relationship = {};\n  var keys = {};\n  Object.keys(namespace.models).forEach(function (mKey) {\n    var e_6, _c;\n    relationship[mKey] = {\n      indexes: [],\n      relationTypes: []\n    };\n    keys[mKey] = {};\n    var model = namespace.models[mKey];\n    Object.keys(model.fields).forEach(function (attr) {\n      var fieldAttribute = model.fields[attr];\n      if (typeof fieldAttribute.type === 'object' && 'model' in fieldAttribute.type) {\n        var connectionType = fieldAttribute.association.connectionType;\n        relationship[mKey].relationTypes.push({\n          fieldName: fieldAttribute.name,\n          modelName: fieldAttribute.type.model,\n          relationType: connectionType,\n          targetName: fieldAttribute.association['targetName'],\n          targetNames: fieldAttribute.association['targetNames'],\n          associatedWith: fieldAttribute.association['associatedWith']\n        });\n        if (connectionType === 'BELONGS_TO') {\n          var targetNames = extractTargetNamesFromSrc(fieldAttribute.association);\n          if (targetNames) {\n            var idxName_1 = indexNameFromKeys(targetNames);\n            var idxExists = relationship[mKey].indexes.find(function (_c) {\n              var _d = __read(_c, 1),\n                index = _d[0];\n              return index === idxName_1;\n            });\n            if (!idxExists) {\n              relationship[mKey].indexes.push([idxName_1, targetNames]);\n            }\n          }\n        }\n      }\n    });\n    if (model.attributes) {\n      keys[mKey].compositeKeys = processCompositeKeys(model.attributes);\n      var _loop_1 = function (attribute) {\n        if (!isModelAttributeKey(attribute)) {\n          return \"continue\";\n        }\n        var fields = attribute.properties.fields;\n        if (isModelAttributePrimaryKey(attribute)) {\n          keys[mKey].primaryKey = fields;\n          return \"continue\";\n        }\n        // create indexes for all other keys\n        var idxName = indexNameFromKeys(fields);\n        var idxExists = relationship[mKey].indexes.find(function (_c) {\n          var _d = __read(_c, 1),\n            index = _d[0];\n          return index === idxName;\n        });\n        if (!idxExists) {\n          relationship[mKey].indexes.push([idxName, fields]);\n        }\n      };\n      try {\n        for (var _d = __values(model.attributes), _e = _d.next(); !_e.done; _e = _d.next()) {\n          var attribute = _e.value;\n          _loop_1(attribute);\n        }\n      } catch (e_6_1) {\n        e_6 = {\n          error: e_6_1\n        };\n      } finally {\n        try {\n          if (_e && !_e.done && (_c = _d.return)) _c.call(_d);\n        } finally {\n          if (e_6) throw e_6.error;\n        }\n      }\n    }\n    // set 'id' as the PK for models without a custom PK explicitly defined\n    if (!keys[mKey].primaryKey) {\n      keys[mKey].primaryKey = [ID];\n    }\n    // create primary index\n    relationship[mKey].indexes.push(['byPk', keys[mKey].primaryKey, {\n      unique: true\n    }]);\n  });\n  return [relationship, keys];\n};\nexport var getIndex = function (rel, src) {\n  var indexName;\n  rel.some(function (relItem) {\n    if (relItem.modelName === src) {\n      var targetNames = extractTargetNamesFromSrc(relItem);\n      indexName = targetNames && indexNameFromKeys(targetNames);\n      return true;\n    }\n  });\n  return indexName;\n};\nexport var getIndexFromAssociation = function (indexes, src) {\n  var indexName;\n  if (Array.isArray(src)) {\n    indexName = indexNameFromKeys(src);\n  } else {\n    indexName = src;\n  }\n  var associationIndex = indexes.find(function (_c) {\n    var _d = __read(_c, 1),\n      idxName = _d[0];\n    return idxName === indexName;\n  });\n  return associationIndex && associationIndex[0];\n};\n/**\n * Backwards-compatability for schema generated prior to custom primary key support:\nthe single field `targetName` has been replaced with an array of `targetNames`.\n`targetName` and `targetNames` are exclusive (will never exist on the same schema)\n * @param src {RelationType | ModelAssociation | undefined}\n * @returns array of targetNames, or `undefined`\n */\nexport var extractTargetNamesFromSrc = function (src) {\n  var targetName = src === null || src === void 0 ? void 0 : src.targetName;\n  var targetNames = src === null || src === void 0 ? void 0 : src.targetNames;\n  if (Array.isArray(targetNames)) {\n    return targetNames;\n  } else if (typeof targetName === 'string') {\n    return [targetName];\n  } else {\n    return undefined;\n  }\n};\n// Generates spinal-cased index name from an array of key field names\n// E.g. for keys `[id, title]` => 'id-title'\nexport var indexNameFromKeys = function (keys) {\n  return keys.reduce(function (prev, cur, idx) {\n    if (idx === 0) {\n      return cur;\n    }\n    return \"\" + prev + IDENTIFIER_KEY_SEPARATOR + cur;\n  }, '');\n};\nexport var keysEqual = function (keysA, keysB) {\n  if (keysA.length !== keysB.length) {\n    return false;\n  }\n  return keysA.every(function (key, idx) {\n    return key === keysB[idx];\n  });\n};\n// Returns primary keys for a model\nexport var getIndexKeys = function (namespace, modelName) {\n  var _c, _d;\n  var keyPath = (_d = (_c = namespace === null || namespace === void 0 ? void 0 : namespace.keys) === null || _c === void 0 ? void 0 : _c[modelName]) === null || _d === void 0 ? void 0 : _d.primaryKey;\n  if (keyPath) {\n    return keyPath;\n  }\n  return [ID];\n};\n//#endregion\n/**\n * Determine what the managed timestamp field names are for the given model definition\n * and return the mapping.\n *\n * All timestamp fields are included in the mapping, regardless of whether the final field\n * names are the defaults or customized in the `@model` directive.\n *\n * @see https://docs.amplify.aws/cli/graphql/data-modeling/#customize-creation-and-update-timestamps\n *\n * @param definition modelDefinition to inspect.\n * @returns An object mapping `createdAt` and `updatedAt` to their field names.\n */\nexport var getTimestampFields = function (definition) {\n  var _c, _d;\n  var modelAttributes = (_c = definition.attributes) === null || _c === void 0 ? void 0 : _c.find(function (attr) {\n    return attr.type === 'model';\n  });\n  var timestampFieldsMap = (_d = modelAttributes === null || modelAttributes === void 0 ? void 0 : modelAttributes.properties) === null || _d === void 0 ? void 0 : _d.timestamps;\n  var defaultFields = {\n    createdAt: 'createdAt',\n    updatedAt: 'updatedAt'\n  };\n  var customFields = timestampFieldsMap || {};\n  return __assign(__assign({}, defaultFields), customFields);\n};\n//# sourceMappingURL=util.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}