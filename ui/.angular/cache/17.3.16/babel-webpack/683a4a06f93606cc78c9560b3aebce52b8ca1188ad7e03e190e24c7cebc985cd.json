{"ast":null,"code":"import { __assign, __awaiter, __generator, __read, __spread, __values } from \"tslib\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { GRAPHQL_AUTH_MODE } from '@aws-amplify/api-graphql';\nimport { GraphQLAuthError } from '@aws-amplify/api';\nimport { Logger } from '@aws-amplify/core';\nimport { isEnumFieldType, isGraphQLScalarType, isPredicateObj, isSchemaModel, isSchemaModelWithAttributes, isTargetNameAssociation, isNonModelFieldType, OpType, ModelOperation, isPredicateGroup } from '../types';\nimport { extractPrimaryKeyFieldNames, establishRelationAndKeys, IDENTIFIER_KEY_SEPARATOR } from '../util';\nvar logger = new Logger('DataStore');\nvar GraphQLOperationType = /*#__PURE__*/function (GraphQLOperationType) {\n  GraphQLOperationType[\"LIST\"] = \"query\";\n  GraphQLOperationType[\"CREATE\"] = \"mutation\";\n  GraphQLOperationType[\"UPDATE\"] = \"mutation\";\n  GraphQLOperationType[\"DELETE\"] = \"mutation\";\n  GraphQLOperationType[\"GET\"] = \"query\";\n  return GraphQLOperationType;\n}(GraphQLOperationType || {});\nexport var TransformerMutationType = /*#__PURE__*/function (TransformerMutationType) {\n  TransformerMutationType[\"CREATE\"] = \"Create\";\n  TransformerMutationType[\"UPDATE\"] = \"Update\";\n  TransformerMutationType[\"DELETE\"] = \"Delete\";\n  TransformerMutationType[\"GET\"] = \"Get\";\n  return TransformerMutationType;\n}(TransformerMutationType || {});\nvar dummyMetadata = {\n  _version: undefined,\n  _lastChangedAt: undefined,\n  _deleted: undefined\n};\nvar metadataFields = Object.keys(dummyMetadata);\nexport function getMetadataFields() {\n  return metadataFields;\n}\nexport function generateSelectionSet(namespace, modelDefinition) {\n  var scalarFields = getScalarFields(modelDefinition);\n  var nonModelFields = getNonModelFields(namespace, modelDefinition);\n  var implicitOwnerField = getImplicitOwnerField(modelDefinition, scalarFields);\n  var scalarAndMetadataFields = Object.values(scalarFields).map(function (_a) {\n    var name = _a.name;\n    return name;\n  }).concat(implicitOwnerField).concat(nonModelFields);\n  if (isSchemaModel(modelDefinition)) {\n    scalarAndMetadataFields = scalarAndMetadataFields.concat(getMetadataFields()).concat(getConnectionFields(modelDefinition, namespace));\n  }\n  var result = scalarAndMetadataFields.join('\\n');\n  return result;\n}\nfunction getImplicitOwnerField(modelDefinition, scalarFields) {\n  var ownerFields = getOwnerFields(modelDefinition);\n  if (!scalarFields.owner && ownerFields.includes('owner')) {\n    return ['owner'];\n  }\n  return [];\n}\nfunction getOwnerFields(modelDefinition) {\n  var ownerFields = [];\n  if (isSchemaModelWithAttributes(modelDefinition)) {\n    modelDefinition.attributes.forEach(function (attr) {\n      if (attr.properties && attr.properties.rules) {\n        var rule = attr.properties.rules.find(function (rule) {\n          return rule.allow === 'owner';\n        });\n        if (rule && rule.ownerField) {\n          ownerFields.push(rule.ownerField);\n        }\n      }\n    });\n  }\n  return ownerFields;\n}\nfunction getScalarFields(modelDefinition) {\n  var fields = modelDefinition.fields;\n  var result = Object.values(fields).filter(function (field) {\n    if (isGraphQLScalarType(field.type) || isEnumFieldType(field.type)) {\n      return true;\n    }\n    return false;\n  }).reduce(function (acc, field) {\n    acc[field.name] = field;\n    return acc;\n  }, {});\n  return result;\n}\n// Used for generating the selection set for queries and mutations\nfunction getConnectionFields(modelDefinition, namespace) {\n  var result = [];\n  Object.values(modelDefinition.fields).filter(function (_a) {\n    var association = _a.association;\n    return association && Object.keys(association).length;\n  }).forEach(function (_a) {\n    var name = _a.name,\n      association = _a.association;\n    var connectionType = (association || {}).connectionType;\n    switch (connectionType) {\n      case 'HAS_ONE':\n      case 'HAS_MANY':\n        // Intentionally blank\n        break;\n      case 'BELONGS_TO':\n        if (isTargetNameAssociation(association)) {\n          // New codegen (CPK)\n          if (association.targetNames && association.targetNames.length > 0) {\n            // Need to retrieve relations in order to get connected model keys\n            var _b = __read(establishRelationAndKeys(namespace), 1),\n              relations = _b[0];\n            var connectedModelName = modelDefinition.fields[name].type['model'];\n            var byPkIndex = relations[connectedModelName].indexes.find(function (_a) {\n              var _b = __read(_a, 1),\n                name = _b[0];\n              return name === 'byPk';\n            });\n            var keyFields = byPkIndex && byPkIndex[1];\n            var keyFieldSelectionSet = keyFields === null || keyFields === void 0 ? void 0 : keyFields.join(' ');\n            // We rely on `_deleted` when we process the sync query (e.g. in batchSave in the adapters)\n            result.push(name + \" { \" + keyFieldSelectionSet + \" _deleted }\");\n          } else {\n            // backwards-compatability for schema generated prior to custom primary key support\n            result.push(name + \" { id _deleted }\");\n          }\n        }\n        break;\n      default:\n        throw new Error(\"Invalid connection type \" + connectionType);\n    }\n  });\n  return result;\n}\nfunction getNonModelFields(namespace, modelDefinition) {\n  var result = [];\n  Object.values(modelDefinition.fields).forEach(function (_a) {\n    var name = _a.name,\n      type = _a.type;\n    if (isNonModelFieldType(type)) {\n      var typeDefinition = namespace.nonModels[type.nonModel];\n      var scalarFields = Object.values(getScalarFields(typeDefinition)).map(function (_a) {\n        var name = _a.name;\n        return name;\n      });\n      var nested_1 = [];\n      Object.values(typeDefinition.fields).forEach(function (field) {\n        var type = field.type,\n          name = field.name;\n        if (isNonModelFieldType(type)) {\n          var typeDefinition_1 = namespace.nonModels[type.nonModel];\n          nested_1.push(name + \" { \" + generateSelectionSet(namespace, typeDefinition_1) + \" }\");\n        }\n      });\n      result.push(name + \" { \" + scalarFields.join(' ') + \" \" + nested_1.join(' ') + \" }\");\n    }\n  });\n  return result;\n}\nexport function getAuthorizationRules(modelDefinition) {\n  // Searching for owner authorization on attributes\n  var authConfig = [].concat(modelDefinition.attributes || []).find(function (attr) {\n    return attr && attr.type === 'auth';\n  });\n  var _a = (authConfig || {}).properties,\n    _b = (_a === void 0 ? {} : _a).rules,\n    rules = _b === void 0 ? [] : _b;\n  var resultRules = [];\n  // Multiple rules can be declared for allow: owner\n  rules.forEach(function (rule) {\n    // setting defaults for backwards compatibility with old cli\n    var _a = rule.identityClaim,\n      identityClaim = _a === void 0 ? 'cognito:username' : _a,\n      _b = rule.ownerField,\n      ownerField = _b === void 0 ? 'owner' : _b,\n      _c = rule.operations,\n      operations = _c === void 0 ? ['create', 'update', 'delete', 'read'] : _c,\n      _d = rule.provider,\n      provider = _d === void 0 ? 'userPools' : _d,\n      _e = rule.groupClaim,\n      groupClaim = _e === void 0 ? 'cognito:groups' : _e,\n      _f = rule.allow,\n      authStrategy = _f === void 0 ? 'iam' : _f,\n      _g = rule.groups,\n      groups = _g === void 0 ? [] : _g,\n      _h = rule.groupsField,\n      groupsField = _h === void 0 ? '' : _h;\n    var isReadAuthorized = operations.includes('read');\n    var isOwnerAuth = authStrategy === 'owner';\n    if (!isReadAuthorized && !isOwnerAuth) {\n      return;\n    }\n    var authRule = {\n      identityClaim: identityClaim,\n      ownerField: ownerField,\n      provider: provider,\n      groupClaim: groupClaim,\n      authStrategy: authStrategy,\n      groups: groups,\n      groupsField: groupsField,\n      areSubscriptionsPublic: false\n    };\n    if (isOwnerAuth) {\n      // look for the subscription level override\n      // only pay attention to the public level\n      var modelConfig = [].concat(modelDefinition.attributes || []).find(function (attr) {\n        return attr && attr.type === 'model';\n      });\n      // find the subscriptions level. ON is default\n      var _j = (modelConfig || {}).properties,\n        _k = (_j === void 0 ? {} : _j).subscriptions,\n        _l = (_k === void 0 ? {} : _k).level,\n        level = _l === void 0 ? 'on' : _l;\n      // treat subscriptions as public for owner auth with unprotected reads\n      // when `read` is omitted from `operations`\n      authRule.areSubscriptionsPublic = !operations.includes('read') || level === 'public';\n    }\n    if (isOwnerAuth) {\n      // owner rules has least priority\n      resultRules.push(authRule);\n      return;\n    }\n    resultRules.unshift(authRule);\n  });\n  return resultRules;\n}\nexport function buildSubscriptionGraphQLOperation(namespace, modelDefinition, transformerMutationType, isOwnerAuthorization, ownerField, filterArg) {\n  if (filterArg === void 0) {\n    filterArg = false;\n  }\n  var selectionSet = generateSelectionSet(namespace, modelDefinition);\n  var typeName = modelDefinition.name;\n  var opName = \"on\" + transformerMutationType + typeName;\n  var docArgs = [];\n  var opArgs = [];\n  if (filterArg) {\n    docArgs.push(\"$filter: ModelSubscription\" + typeName + \"FilterInput\");\n    opArgs.push('filter: $filter');\n  }\n  if (isOwnerAuthorization) {\n    docArgs.push(\"$\" + ownerField + \": String!\");\n    opArgs.push(ownerField + \": $\" + ownerField);\n  }\n  var docStr = docArgs.length ? \"(\" + docArgs.join(',') + \")\" : '';\n  var opStr = opArgs.length ? \"(\" + opArgs.join(',') + \")\" : '';\n  return [transformerMutationType, opName, \"subscription operation\" + docStr + \"{\\n\\t\\t\\t\" + opName + opStr + \"{\\n\\t\\t\\t\\t\" + selectionSet + \"\\n\\t\\t\\t}\\n\\t\\t}\"];\n}\nexport function buildGraphQLOperation(namespace, modelDefinition, graphQLOpType) {\n  var selectionSet = generateSelectionSet(namespace, modelDefinition);\n  var typeName = modelDefinition.name,\n    pluralTypeName = modelDefinition.pluralName;\n  var operation;\n  var documentArgs;\n  var operationArgs;\n  var transformerMutationType;\n  switch (graphQLOpType) {\n    case 'LIST':\n      operation = \"sync\" + pluralTypeName;\n      documentArgs = \"($limit: Int, $nextToken: String, $lastSync: AWSTimestamp, $filter: Model\" + typeName + \"FilterInput)\";\n      operationArgs = '(limit: $limit, nextToken: $nextToken, lastSync: $lastSync, filter: $filter)';\n      selectionSet = \"items {\\n\\t\\t\\t\\t\\t\\t\\t\" + selectionSet + \"\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tnextToken\\n\\t\\t\\t\\t\\t\\tstartedAt\";\n      break;\n    case 'CREATE':\n      operation = \"create\" + typeName;\n      documentArgs = \"($input: Create\" + typeName + \"Input!)\";\n      operationArgs = '(input: $input)';\n      transformerMutationType = TransformerMutationType.CREATE;\n      break;\n    case 'UPDATE':\n      operation = \"update\" + typeName;\n      documentArgs = \"($input: Update\" + typeName + \"Input!, $condition: Model\" + typeName + \"ConditionInput)\";\n      operationArgs = '(input: $input, condition: $condition)';\n      transformerMutationType = TransformerMutationType.UPDATE;\n      break;\n    case 'DELETE':\n      operation = \"delete\" + typeName;\n      documentArgs = \"($input: Delete\" + typeName + \"Input!, $condition: Model\" + typeName + \"ConditionInput)\";\n      operationArgs = '(input: $input, condition: $condition)';\n      transformerMutationType = TransformerMutationType.DELETE;\n      break;\n    case 'GET':\n      operation = \"get\" + typeName;\n      documentArgs = \"($id: ID!)\";\n      operationArgs = '(id: $id)';\n      transformerMutationType = TransformerMutationType.GET;\n      break;\n    default:\n      throw new Error(\"Invalid graphQlOpType \" + graphQLOpType);\n  }\n  return [[transformerMutationType, operation, GraphQLOperationType[graphQLOpType] + \" operation\" + documentArgs + \"{\\n\\t\\t\" + operation + operationArgs + \"{\\n\\t\\t\\t\" + selectionSet + \"\\n\\t\\t}\\n\\t}\"]];\n}\nexport function createMutationInstanceFromModelOperation(relationships, modelDefinition, opType, model, element, condition, MutationEventConstructor, modelInstanceCreator, id) {\n  var operation;\n  switch (opType) {\n    case OpType.INSERT:\n      operation = TransformerMutationType.CREATE;\n      break;\n    case OpType.UPDATE:\n      operation = TransformerMutationType.UPDATE;\n      break;\n    case OpType.DELETE:\n      operation = TransformerMutationType.DELETE;\n      break;\n    default:\n      throw new Error(\"Invalid opType \" + opType);\n  }\n  // stringify nested objects of type AWSJSON\n  // this allows us to return parsed JSON to users (see `castInstanceType()` in datastore.ts),\n  // but still send the object correctly over the wire\n  var replacer = function (k, v) {\n    var isAWSJSON = k && v !== null && typeof v === 'object' && modelDefinition.fields[k] && modelDefinition.fields[k].type === 'AWSJSON';\n    if (isAWSJSON) {\n      return JSON.stringify(v);\n    }\n    return v;\n  };\n  var modelId = getIdentifierValue(modelDefinition, element);\n  var optionalId = OpType.INSERT && id ? {\n    id: id\n  } : {};\n  var mutationEvent = modelInstanceCreator(MutationEventConstructor, __assign(__assign({}, optionalId), {\n    data: JSON.stringify(element, replacer),\n    modelId: modelId,\n    model: model.name,\n    operation: operation,\n    condition: JSON.stringify(condition)\n  }));\n  return mutationEvent;\n}\nexport function predicateToGraphQLCondition(predicate, modelDefinition) {\n  var result = {};\n  if (!predicate || !Array.isArray(predicate.predicates)) {\n    return result;\n  }\n  // This is compatible with how the GQL Transform currently generates the Condition Input,\n  // i.e. any PK and SK fields are omitted and can't be used as conditions.\n  // However, I think this limits usability.\n  // What if we want to delete all records where SK > some value\n  // Or all records where PK = some value but SKs are different values\n  // TODO: if the Transform gets updated we'll need to modify this logic to only omit\n  // key fields from the predicate/condition when ALL of the keyFields are present and using `eq` operators\n  var keyFields = extractPrimaryKeyFieldNames(modelDefinition);\n  return predicateToGraphQLFilter(predicate, keyFields);\n}\n/**\n * @param predicatesGroup - Predicate Group\n    @returns GQL Filter Expression from Predicate Group\n    \n    @remarks Flattens redundant list predicates\n    @example\n\n    ```js\n    { and:[{ and:[{ username:  { eq: 'bob' }}] }] }\n    ```\n    Becomes\n    ```js\n    { and:[{ username: { eq: 'bob' }}] }\n    ```\n    */\nexport function predicateToGraphQLFilter(predicatesGroup, fieldsToOmit, root) {\n  if (fieldsToOmit === void 0) {\n    fieldsToOmit = [];\n  }\n  if (root === void 0) {\n    root = true;\n  }\n  var result = {};\n  if (!predicatesGroup || !Array.isArray(predicatesGroup.predicates)) {\n    return result;\n  }\n  var type = predicatesGroup.type,\n    predicates = predicatesGroup.predicates;\n  var isList = type === 'and' || type === 'or';\n  result[type] = isList ? [] : {};\n  var children = [];\n  predicates.forEach(function (predicate) {\n    var _a, _b;\n    if (isPredicateObj(predicate)) {\n      var field = predicate.field,\n        operator = predicate.operator,\n        operand = predicate.operand;\n      if (fieldsToOmit.includes(field)) return;\n      var gqlField = (_a = {}, _a[field] = (_b = {}, _b[operator] = operand, _b), _a);\n      children.push(gqlField);\n      return;\n    }\n    var child = predicateToGraphQLFilter(predicate, fieldsToOmit, false);\n    if (Object.keys(child).length > 0) {\n      children.push(child);\n    }\n  });\n  // flatten redundant list predicates\n  if (children.length === 1) {\n    var _a = __read(children, 1),\n      child = _a[0];\n    if (\n    // any nested list node\n    isList && !root ||\n    // root list node where the only child is also a list node\n    isList && root && ('and' in child || 'or' in child)) {\n      delete result[type];\n      Object.assign(result, child);\n      return result;\n    }\n  }\n  children.forEach(function (child) {\n    if (isList) {\n      result[type].push(child);\n    } else {\n      result[type] = child;\n    }\n  });\n  if (isList) {\n    if (result[type].length === 0) return {};\n  } else {\n    if (Object.keys(result[type]).length === 0) return {};\n  }\n  return result;\n}\n/**\n *\n * @param group - selective sync predicate group\n * @returns set of distinct field names in the filter group\n */\nexport function filterFields(group) {\n  var fields = new Set();\n  if (!group || !Array.isArray(group.predicates)) return fields;\n  var predicates = group.predicates;\n  var stack = __spread(predicates);\n  while (stack.length > 0) {\n    var current = stack.pop();\n    if (isPredicateObj(current)) {\n      fields.add(current.field);\n    } else if (isPredicateGroup(current)) {\n      stack.push.apply(stack, __spread(current.predicates));\n    }\n  }\n  return fields;\n}\n/**\n *\n * @param modelDefinition\n * @returns set of field names used with dynamic auth modes configured for the provided model definition\n */\nexport function dynamicAuthFields(modelDefinition) {\n  var e_1, _a;\n  var rules = getAuthorizationRules(modelDefinition);\n  var fields = new Set();\n  try {\n    for (var rules_1 = __values(rules), rules_1_1 = rules_1.next(); !rules_1_1.done; rules_1_1 = rules_1.next()) {\n      var rule = rules_1_1.value;\n      if (rule.groupsField && !rule.groups.length) {\n        // dynamic group rule will have no values in `rule.groups`\n        fields.add(rule.groupsField);\n      } else if (rule.ownerField) {\n        fields.add(rule.ownerField);\n      }\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (rules_1_1 && !rules_1_1.done && (_a = rules_1.return)) _a.call(rules_1);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n  return fields;\n}\n/**\n *\n * @param group - selective sync predicate group\n * @returns the total number of OR'd predicates in the filter group\n *\n * @example returns 2\n * ```js\n * { type: \"or\", predicates: [\n * { field: \"username\", operator: \"beginsWith\", operand: \"a\" },\n * { field: \"title\", operator: \"contains\", operand: \"abc\" },\n * ]}\n * ```\n */\nexport function countFilterCombinations(group) {\n  if (!group || !Array.isArray(group.predicates)) return 0;\n  var count = 0;\n  var stack = [group];\n  while (stack.length > 0) {\n    var current = stack.pop();\n    if (isPredicateGroup(current)) {\n      var predicates = current.predicates,\n        type = current.type;\n      // ignore length = 1; groups with 1 predicate will get flattened when converted to gqlFilter\n      if (type === 'or' && predicates.length > 1) {\n        count += predicates.length;\n      }\n      stack.push.apply(stack, __spread(predicates));\n    }\n  }\n  // if we didn't encounter any OR groups, default to 1\n  return count || 1;\n}\n/**\n *\n * @param group - selective sync predicate group\n * @returns name of repeated field | null\n *\n * @example returns \"username\"\n * ```js\n * { type: \"and\", predicates: [\n * \t\t{ field: \"username\", operator: \"beginsWith\", operand: \"a\" },\n * \t\t{ field: \"username\", operator: \"contains\", operand: \"abc\" },\n * ] }\n * ```\n */\nexport function repeatedFieldInGroup(group) {\n  if (!group || !Array.isArray(group.predicates)) return null;\n  // convert to filter in order to flatten redundant groups\n  var gqlFilter = predicateToGraphQLFilter(group);\n  var stack = [gqlFilter];\n  var hasGroupRepeatedFields = function (fields) {\n    var e_2, _a;\n    var seen = {};\n    try {\n      for (var fields_1 = __values(fields), fields_1_1 = fields_1.next(); !fields_1_1.done; fields_1_1 = fields_1.next()) {\n        var f = fields_1_1.value;\n        var _b = __read(Object.keys(f), 1),\n          fieldName = _b[0];\n        if (seen[fieldName]) {\n          return fieldName;\n        }\n        seen[fieldName] = true;\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (fields_1_1 && !fields_1_1.done && (_a = fields_1.return)) _a.call(fields_1);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n    return null;\n  };\n  while (stack.length > 0) {\n    var current = stack.pop();\n    var _a = __read(Object.keys(current), 1),\n      key = _a[0];\n    var values = current[key];\n    if (!Array.isArray(values)) {\n      return null;\n    }\n    // field value will be single object\n    var predicateObjects = values.filter(function (v) {\n      return !Array.isArray(Object.values(v)[0]);\n    });\n    // group value will be an array\n    var predicateGroups = values.filter(function (v) {\n      return Array.isArray(Object.values(v)[0]);\n    });\n    if (key === 'and') {\n      var repeatedField = hasGroupRepeatedFields(predicateObjects);\n      if (repeatedField) {\n        return repeatedField;\n      }\n    }\n    stack.push.apply(stack, __spread(predicateGroups));\n  }\n  return null;\n}\nexport var RTFError = /*#__PURE__*/function (RTFError) {\n  RTFError[RTFError[\"UnknownField\"] = 0] = \"UnknownField\";\n  RTFError[RTFError[\"MaxAttributes\"] = 1] = \"MaxAttributes\";\n  RTFError[RTFError[\"MaxCombinations\"] = 2] = \"MaxCombinations\";\n  RTFError[RTFError[\"RepeatedFieldname\"] = 3] = \"RepeatedFieldname\";\n  RTFError[RTFError[\"NotGroup\"] = 4] = \"NotGroup\";\n  RTFError[RTFError[\"FieldNotInType\"] = 5] = \"FieldNotInType\";\n  return RTFError;\n}(RTFError || {});\nexport function generateRTFRemediation(errorType, modelDefinition, predicatesGroup) {\n  var selSyncFields = filterFields(predicatesGroup);\n  var selSyncFieldStr = __spread(selSyncFields).join(', ');\n  var dynamicAuthModeFields = dynamicAuthFields(modelDefinition);\n  var dynamicAuthFieldsStr = __spread(dynamicAuthModeFields).join(', ');\n  var filterCombinations = countFilterCombinations(predicatesGroup);\n  var repeatedField = repeatedFieldInGroup(predicatesGroup);\n  switch (errorType) {\n    case RTFError.UnknownField:\n      return \"Your API was generated with an older version of the CLI that doesn't support backend subscription filtering.\" + 'To enable backend subscription filtering, upgrade your Amplify CLI to the latest version and push your app by running `amplify upgrade` followed by `amplify push`';\n    case RTFError.MaxAttributes:\n      {\n        var message = \"Your selective sync expression for \" + modelDefinition.name + \" contains \" + selSyncFields.size + \" different model fields: \" + selSyncFieldStr + \".\\n\\n\";\n        if (dynamicAuthModeFields.size > 0) {\n          message += \"Note: the number of fields you can use with selective sync is affected by @auth rules configured on the model.\\n\\n\" + \"Dynamic auth modes, such as owner auth and dynamic group auth each utilize 1 field.\\n\" + (\"You currently have \" + dynamicAuthModeFields.size + \" dynamic auth mode(s) configured on this model: \" + dynamicAuthFieldsStr + \".\");\n        }\n        return message;\n      }\n    case RTFError.MaxCombinations:\n      {\n        var message = \"Your selective sync expression for \" + modelDefinition.name + \" contains \" + filterCombinations + \" field combinations (total number of predicates in an OR expression).\\n\\n\";\n        if (dynamicAuthModeFields.size > 0) {\n          message += \"Note: the number of fields you can use with selective sync is affected by @auth rules configured on the model.\\n\\n\" + \"Dynamic auth modes, such as owner auth and dynamic group auth factor in to the number of combinations you're using.\\n\" + (\"You currently have \" + dynamicAuthModeFields.size + \" dynamic auth mode(s) configured on this model: \" + dynamicAuthFieldsStr + \".\");\n        }\n        return message;\n      }\n    case RTFError.RepeatedFieldname:\n      return \"Your selective sync expression for \" + modelDefinition.name + \" contains multiple entries for \" + repeatedField + \" in the same AND group.\";\n    case RTFError.NotGroup:\n      return \"Your selective sync expression for \" + modelDefinition.name + \" uses a `not` group. If you'd like to filter subscriptions in the backend, \" + \"rewrite your expression using `ne` or `notContains` operators.\";\n    case RTFError.FieldNotInType:\n      // no remediation instructions. We'll surface the message directly\n      return '';\n  }\n}\nexport function getUserGroupsFromToken(token, rule) {\n  // validate token against groupClaim\n  var userGroups = token[rule.groupClaim] || [];\n  if (typeof userGroups === 'string') {\n    var parsedGroups = void 0;\n    try {\n      parsedGroups = JSON.parse(userGroups);\n    } catch (e) {\n      parsedGroups = userGroups;\n    }\n    userGroups = [].concat(parsedGroups);\n  }\n  return userGroups;\n}\nexport function getModelAuthModes(_a) {\n  var authModeStrategy = _a.authModeStrategy,\n    defaultAuthMode = _a.defaultAuthMode,\n    modelName = _a.modelName,\n    schema = _a.schema;\n  return __awaiter(this, void 0, void 0, function () {\n    var operations, modelAuthModes, error_1;\n    var _this = this;\n    return __generator(this, function (_b) {\n      switch (_b.label) {\n        case 0:\n          operations = Object.values(ModelOperation);\n          modelAuthModes = {\n            CREATE: [],\n            READ: [],\n            UPDATE: [],\n            DELETE: []\n          };\n          _b.label = 1;\n        case 1:\n          _b.trys.push([1, 3,, 4]);\n          return [4 /*yield*/, Promise.all(operations.map(function (operation) {\n            return __awaiter(_this, void 0, void 0, function () {\n              var authModes;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    return [4 /*yield*/, authModeStrategy({\n                      schema: schema,\n                      modelName: modelName,\n                      operation: operation\n                    })];\n                  case 1:\n                    authModes = _a.sent();\n                    if (typeof authModes === 'string') {\n                      modelAuthModes[operation] = [authModes];\n                    } else if (Array.isArray(authModes) && authModes.length) {\n                      modelAuthModes[operation] = authModes;\n                    } else {\n                      // Use default auth mode if nothing is returned from authModeStrategy\n                      modelAuthModes[operation] = [defaultAuthMode];\n                    }\n                    return [2 /*return*/];\n                }\n              });\n            });\n          }))];\n        case 2:\n          _b.sent();\n          return [3 /*break*/, 4];\n        case 3:\n          error_1 = _b.sent();\n          logger.debug(\"Error getting auth modes for model: \" + modelName, error_1);\n          return [3 /*break*/, 4];\n        case 4:\n          return [2 /*return*/, modelAuthModes];\n      }\n    });\n  });\n}\nexport function getForbiddenError(error) {\n  var forbiddenErrorMessages = ['Request failed with status code 401', 'Request failed with status code 403'];\n  var forbiddenError;\n  if (error && error.errors) {\n    forbiddenError = error.errors.find(function (err) {\n      return forbiddenErrorMessages.includes(err.message);\n    });\n  } else if (error && error.message) {\n    forbiddenError = error;\n  }\n  if (forbiddenError) {\n    return forbiddenError.message;\n  }\n  return null;\n}\nexport function getClientSideAuthError(error) {\n  var clientSideAuthErrors = Object.values(GraphQLAuthError);\n  var clientSideError = error && error.message && clientSideAuthErrors.find(function (clientError) {\n    return error.message.includes(clientError);\n  });\n  return clientSideError || null;\n}\nexport function getTokenForCustomAuth(authMode, amplifyConfig) {\n  if (amplifyConfig === void 0) {\n    amplifyConfig = {};\n  }\n  return __awaiter(this, void 0, void 0, function () {\n    var _a, functionAuthProvider, token, error_2;\n    return __generator(this, function (_b) {\n      switch (_b.label) {\n        case 0:\n          if (!(authMode === GRAPHQL_AUTH_MODE.AWS_LAMBDA)) return [3 /*break*/, 6];\n          _a = amplifyConfig.authProviders, functionAuthProvider = (_a === void 0 ? {\n            functionAuthProvider: null\n          } : _a).functionAuthProvider;\n          if (!(functionAuthProvider && typeof functionAuthProvider === 'function')) return [3 /*break*/, 5];\n          _b.label = 1;\n        case 1:\n          _b.trys.push([1, 3,, 4]);\n          return [4 /*yield*/, functionAuthProvider()];\n        case 2:\n          token = _b.sent().token;\n          return [2 /*return*/, token];\n        case 3:\n          error_2 = _b.sent();\n          throw new Error(\"Error retrieving token from `functionAuthProvider`: \" + error_2);\n        case 4:\n          return [3 /*break*/, 6];\n        case 5:\n          // TODO: add docs link once available\n          throw new Error(\"You must provide a `functionAuthProvider` function to `DataStore.configure` when using \" + GRAPHQL_AUTH_MODE.AWS_LAMBDA);\n        case 6:\n          return [2 /*return*/];\n      }\n    });\n  });\n}\n// Util that takes a modelDefinition and model and returns either the id value(s) or the custom primary key value(s)\nexport function getIdentifierValue(modelDefinition, model) {\n  var pkFieldNames = extractPrimaryKeyFieldNames(modelDefinition);\n  var idOrPk = pkFieldNames.map(function (f) {\n    return model[f];\n  }).join(IDENTIFIER_KEY_SEPARATOR);\n  return idOrPk;\n}\n//# sourceMappingURL=utils.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}