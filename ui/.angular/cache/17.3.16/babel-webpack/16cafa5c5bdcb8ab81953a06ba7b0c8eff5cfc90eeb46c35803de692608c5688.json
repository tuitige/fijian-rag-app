{"ast":null,"code":"import { __assign, __awaiter, __generator, __read, __spread } from \"tslib\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { GRAPHQL_AUTH_MODE } from '@aws-amplify/api';\nimport { InternalAPI } from '@aws-amplify/api/internals';\nimport { Auth } from '@aws-amplify/auth';\nimport { Cache } from '@aws-amplify/cache';\nimport { Category, ConsoleLogger as Logger, DataStoreAction, Hub, BackgroundProcessManager } from '@aws-amplify/core';\nimport { CONTROL_MSG as PUBSUB_CONTROL_MSG } from '@aws-amplify/pubsub';\nimport Observable from 'zen-observable-ts';\nimport { ProcessName } from '../../types';\nimport { buildSubscriptionGraphQLOperation, getAuthorizationRules, getModelAuthModes, getUserGroupsFromToken, TransformerMutationType, getTokenForCustomAuth, predicateToGraphQLFilter, RTFError, generateRTFRemediation } from '../utils';\nimport { ModelPredicateCreator } from '../../predicates';\nimport { validatePredicate } from '../../util';\nimport { getSubscriptionErrorType } from './errorMaps';\nvar logger = new Logger('DataStore');\nexport var CONTROL_MSG = /*#__PURE__*/function (CONTROL_MSG) {\n  CONTROL_MSG[\"CONNECTED\"] = \"CONNECTED\";\n  return CONTROL_MSG;\n}(CONTROL_MSG || {});\nexport var USER_CREDENTIALS = /*#__PURE__*/function (USER_CREDENTIALS) {\n  USER_CREDENTIALS[USER_CREDENTIALS[\"none\"] = 0] = \"none\";\n  USER_CREDENTIALS[USER_CREDENTIALS[\"unauth\"] = 1] = \"unauth\";\n  USER_CREDENTIALS[USER_CREDENTIALS[\"auth\"] = 2] = \"auth\";\n  return USER_CREDENTIALS;\n}(USER_CREDENTIALS || {});\nvar SubscriptionProcessor = /** @class */function () {\n  function SubscriptionProcessor(schema, syncPredicates, amplifyConfig, authModeStrategy, errorHandler, amplifyContext) {\n    if (amplifyConfig === void 0) {\n      amplifyConfig = {};\n    }\n    if (amplifyContext === void 0) {\n      amplifyContext = {\n        Auth: Auth,\n        InternalAPI: InternalAPI,\n        Cache: Cache\n      };\n    }\n    this.schema = schema;\n    this.syncPredicates = syncPredicates;\n    this.amplifyConfig = amplifyConfig;\n    this.authModeStrategy = authModeStrategy;\n    this.errorHandler = errorHandler;\n    this.amplifyContext = amplifyContext;\n    this.typeQuery = new WeakMap();\n    this.buffer = [];\n    this.runningProcesses = new BackgroundProcessManager();\n  }\n  SubscriptionProcessor.prototype.buildSubscription = function (namespace, model, transformerMutationType, userCredentials, cognitoTokenPayload, oidcTokenPayload, authMode, filterArg) {\n    if (filterArg === void 0) {\n      filterArg = false;\n    }\n    var aws_appsync_authenticationType = this.amplifyConfig.aws_appsync_authenticationType;\n    var _a = this.getAuthorizationInfo(model, userCredentials, aws_appsync_authenticationType, cognitoTokenPayload, oidcTokenPayload, authMode) || {},\n      isOwner = _a.isOwner,\n      ownerField = _a.ownerField,\n      ownerValue = _a.ownerValue;\n    var _b = __read(buildSubscriptionGraphQLOperation(namespace, model, transformerMutationType, isOwner, ownerField, filterArg), 3),\n      opType = _b[0],\n      opName = _b[1],\n      query = _b[2];\n    return {\n      authMode: authMode,\n      opType: opType,\n      opName: opName,\n      query: query,\n      isOwner: isOwner,\n      ownerField: ownerField,\n      ownerValue: ownerValue\n    };\n  };\n  SubscriptionProcessor.prototype.getAuthorizationInfo = function (model, userCredentials, defaultAuthType, cognitoTokenPayload, oidcTokenPayload, authMode) {\n    if (cognitoTokenPayload === void 0) {\n      cognitoTokenPayload = {};\n    }\n    if (oidcTokenPayload === void 0) {\n      oidcTokenPayload = {};\n    }\n    var rules = getAuthorizationRules(model);\n    // Return null if user doesn't have proper credentials for private API with IAM auth\n    var iamPrivateAuth = authMode === GRAPHQL_AUTH_MODE.AWS_IAM && rules.find(function (rule) {\n      return rule.authStrategy === 'private' && rule.provider === 'iam';\n    });\n    if (iamPrivateAuth && userCredentials === USER_CREDENTIALS.unauth) {\n      return null;\n    }\n    // Group auth should take precedence over owner auth, so we are checking\n    // if rule(s) have group authorization as well as if either the Cognito or\n    // OIDC token has a groupClaim. If so, we are returning auth info before\n    // any further owner-based auth checks.\n    var groupAuthRules = rules.filter(function (rule) {\n      return rule.authStrategy === 'groups' && ['userPools', 'oidc'].includes(rule.provider);\n    });\n    var validGroup = (authMode === GRAPHQL_AUTH_MODE.AMAZON_COGNITO_USER_POOLS || authMode === GRAPHQL_AUTH_MODE.OPENID_CONNECT) && groupAuthRules.find(function (groupAuthRule) {\n      // validate token against groupClaim\n      var cognitoUserGroups = getUserGroupsFromToken(cognitoTokenPayload, groupAuthRule);\n      var oidcUserGroups = getUserGroupsFromToken(oidcTokenPayload, groupAuthRule);\n      return __spread(cognitoUserGroups, oidcUserGroups).find(function (userGroup) {\n        return groupAuthRule.groups.find(function (group) {\n          return group === userGroup;\n        });\n      });\n    });\n    if (validGroup) {\n      return {\n        authMode: authMode,\n        isOwner: false\n      };\n    }\n    // Owner auth needs additional values to be returned in order to create the subscription with\n    // the correct parameters so we are getting the owner value from the Cognito token via the\n    // identityClaim from the auth rule.\n    var cognitoOwnerAuthRules = authMode === GRAPHQL_AUTH_MODE.AMAZON_COGNITO_USER_POOLS ? rules.filter(function (rule) {\n      return rule.authStrategy === 'owner' && rule.provider === 'userPools';\n    }) : [];\n    var ownerAuthInfo;\n    cognitoOwnerAuthRules.forEach(function (ownerAuthRule) {\n      var _a;\n      var ownerValue = cognitoTokenPayload[ownerAuthRule.identityClaim];\n      // AuthZ for \"list of owners\" is handled dynamically in the subscription auth request\n      // resolver. It doesn't rely on a subscription arg.\n      // Only pass a subscription arg for single owner auth\n      var singleOwner = ((_a = model.fields[ownerAuthRule.ownerField]) === null || _a === void 0 ? void 0 : _a.isArray) !== true;\n      var isOwnerArgRequired = singleOwner && !ownerAuthRule.areSubscriptionsPublic;\n      if (ownerValue) {\n        ownerAuthInfo = {\n          authMode: GRAPHQL_AUTH_MODE.AMAZON_COGNITO_USER_POOLS,\n          isOwner: isOwnerArgRequired,\n          ownerField: ownerAuthRule.ownerField,\n          ownerValue: ownerValue\n        };\n      }\n    });\n    if (ownerAuthInfo) {\n      return ownerAuthInfo;\n    }\n    // Owner auth needs additional values to be returned in order to create the subscription with\n    // the correct parameters so we are getting the owner value from the OIDC token via the\n    // identityClaim from the auth rule.\n    var oidcOwnerAuthRules = authMode === GRAPHQL_AUTH_MODE.OPENID_CONNECT ? rules.filter(function (rule) {\n      return rule.authStrategy === 'owner' && rule.provider === 'oidc';\n    }) : [];\n    oidcOwnerAuthRules.forEach(function (ownerAuthRule) {\n      var _a;\n      var ownerValue = oidcTokenPayload[ownerAuthRule.identityClaim];\n      var singleOwner = ((_a = model.fields[ownerAuthRule.ownerField]) === null || _a === void 0 ? void 0 : _a.isArray) !== true;\n      var isOwnerArgRequired = singleOwner && !ownerAuthRule.areSubscriptionsPublic;\n      if (ownerValue) {\n        ownerAuthInfo = {\n          authMode: GRAPHQL_AUTH_MODE.OPENID_CONNECT,\n          isOwner: isOwnerArgRequired,\n          ownerField: ownerAuthRule.ownerField,\n          ownerValue: ownerValue\n        };\n      }\n    });\n    if (ownerAuthInfo) {\n      return ownerAuthInfo;\n    }\n    // Fallback: return authMode or default auth type\n    return {\n      authMode: authMode || defaultAuthType,\n      isOwner: false\n    };\n  };\n  SubscriptionProcessor.prototype.hubQueryCompletionListener = function (completed, capsule) {\n    var event = capsule.payload.event;\n    if (event === PUBSUB_CONTROL_MSG.SUBSCRIPTION_ACK) {\n      completed();\n    }\n  };\n  SubscriptionProcessor.prototype.start = function () {\n    var _this = this;\n    this.runningProcesses = this.runningProcesses || new BackgroundProcessManager();\n    var ctlObservable = new Observable(function (observer) {\n      var promises = [];\n      // Creating subs for each model/operation combo so they can be unsubscribed\n      // independently, since the auth retry behavior is asynchronous.\n      var subscriptions = {};\n      var cognitoTokenPayload, oidcTokenPayload;\n      var userCredentials = USER_CREDENTIALS.none;\n      _this.runningProcesses.add(function () {\n        return __awaiter(_this, void 0, void 0, function () {\n          var credentials, err_1, session, err_2, _a, aws_cognito_region, AuthConfig, token, federatedInfo, currentUser, payload, err_3;\n          var _this = this;\n          return __generator(this, function (_b) {\n            switch (_b.label) {\n              case 0:\n                _b.trys.push([0, 2,, 3]);\n                return [4 /*yield*/, this.amplifyContext.Auth.currentCredentials()];\n              case 1:\n                credentials = _b.sent();\n                userCredentials = credentials.authenticated ? USER_CREDENTIALS.auth : USER_CREDENTIALS.unauth;\n                return [3 /*break*/, 3];\n              case 2:\n                err_1 = _b.sent();\n                return [3 /*break*/, 3];\n              case 3:\n                _b.trys.push([3, 5,, 6]);\n                return [4 /*yield*/, this.amplifyContext.Auth.currentSession()];\n              case 4:\n                session = _b.sent();\n                cognitoTokenPayload = session.getIdToken().decodePayload();\n                return [3 /*break*/, 6];\n              case 5:\n                err_2 = _b.sent();\n                return [3 /*break*/, 6];\n              case 6:\n                _b.trys.push([6, 11,, 12]);\n                _a = this.amplifyConfig, aws_cognito_region = _a.aws_cognito_region, AuthConfig = _a.Auth;\n                if (!aws_cognito_region || AuthConfig && !AuthConfig.region) {\n                  throw 'Auth is not configured';\n                }\n                token = void 0;\n                return [4 /*yield*/, this.amplifyContext.Cache.getItem('federatedInfo')];\n              case 7:\n                federatedInfo = _b.sent();\n                if (!federatedInfo) return [3 /*break*/, 8];\n                token = federatedInfo.token;\n                return [3 /*break*/, 10];\n              case 8:\n                return [4 /*yield*/, this.amplifyContext.Auth.currentAuthenticatedUser()];\n              case 9:\n                currentUser = _b.sent();\n                if (currentUser) {\n                  token = currentUser.token;\n                }\n                _b.label = 10;\n              case 10:\n                if (token) {\n                  payload = token.split('.')[1];\n                  oidcTokenPayload = JSON.parse(Buffer.from(payload, 'base64').toString('utf8'));\n                }\n                return [3 /*break*/, 12];\n              case 11:\n                err_3 = _b.sent();\n                logger.debug('error getting OIDC JWT', err_3);\n                return [3 /*break*/, 12];\n              case 12:\n                Object.values(this.schema.namespaces).forEach(function (namespace) {\n                  Object.values(namespace.models).filter(function (_a) {\n                    var syncable = _a.syncable;\n                    return syncable;\n                  }).forEach(function (modelDefinition) {\n                    return _this.runningProcesses.isOpen && _this.runningProcesses.add(function () {\n                      return __awaiter(_this, void 0, void 0, function () {\n                        var modelAuthModes, readAuthModes, operations, operationAuthModeAttempts, predicatesGroup, addFilterArg, subscriptionRetry;\n                        var _a, _b, _c;\n                        var _this = this;\n                        return __generator(this, function (_d) {\n                          switch (_d.label) {\n                            case 0:\n                              return [4 /*yield*/, getModelAuthModes({\n                                authModeStrategy: this.authModeStrategy,\n                                defaultAuthMode: this.amplifyConfig.aws_appsync_authenticationType,\n                                modelName: modelDefinition.name,\n                                schema: this.schema\n                              })];\n                            case 1:\n                              modelAuthModes = _d.sent();\n                              readAuthModes = modelAuthModes.READ;\n                              subscriptions = __assign(__assign({}, subscriptions), (_a = {}, _a[modelDefinition.name] = (_b = {}, _b[TransformerMutationType.CREATE] = [], _b[TransformerMutationType.UPDATE] = [], _b[TransformerMutationType.DELETE] = [], _b), _a));\n                              operations = [TransformerMutationType.CREATE, TransformerMutationType.UPDATE, TransformerMutationType.DELETE];\n                              operationAuthModeAttempts = (_c = {}, _c[TransformerMutationType.CREATE] = 0, _c[TransformerMutationType.UPDATE] = 0, _c[TransformerMutationType.DELETE] = 0, _c);\n                              predicatesGroup = ModelPredicateCreator.getPredicates(this.syncPredicates.get(modelDefinition), false);\n                              addFilterArg = predicatesGroup !== undefined;\n                              subscriptionRetry = function (operation, addFilter) {\n                                if (addFilter === void 0) {\n                                  addFilter = addFilterArg;\n                                }\n                                return __awaiter(_this, void 0, void 0, function () {\n                                  var _a, transformerMutationType, opName, query, isOwner, ownerField, ownerValue, authMode, authToken, variables, customUserAgentDetails, queryObservable, subscriptionReadyCallback;\n                                  var _this = this;\n                                  return __generator(this, function (_b) {\n                                    switch (_b.label) {\n                                      case 0:\n                                        _a = this.buildSubscription(namespace, modelDefinition, operation, userCredentials, cognitoTokenPayload, oidcTokenPayload, readAuthModes[operationAuthModeAttempts[operation]], addFilter), transformerMutationType = _a.opType, opName = _a.opName, query = _a.query, isOwner = _a.isOwner, ownerField = _a.ownerField, ownerValue = _a.ownerValue, authMode = _a.authMode;\n                                        return [4 /*yield*/, getTokenForCustomAuth(authMode, this.amplifyConfig)];\n                                      case 1:\n                                        authToken = _b.sent();\n                                        variables = {};\n                                        customUserAgentDetails = {\n                                          category: Category.DataStore,\n                                          action: DataStoreAction.Subscribe\n                                        };\n                                        if (addFilter && predicatesGroup) {\n                                          variables['filter'] = predicateToGraphQLFilter(predicatesGroup);\n                                        }\n                                        if (isOwner) {\n                                          if (!ownerValue) {\n                                            observer.error('Owner field required, sign in is needed in order to perform this operation');\n                                            return [2 /*return*/];\n                                          }\n                                          variables[ownerField] = ownerValue;\n                                        }\n                                        logger.debug(\"Attempting \" + operation + \" subscription with authMode: \" + readAuthModes[operationAuthModeAttempts[operation]]);\n                                        queryObservable = this.amplifyContext.InternalAPI.graphql(__assign(__assign({\n                                          query: query,\n                                          variables: variables\n                                        }, {\n                                          authMode: authMode\n                                        }), {\n                                          authToken: authToken\n                                        }), undefined, customUserAgentDetails);\n                                        // TODO: consider onTerminate.then(() => API.cancel(...))\n                                        subscriptions[modelDefinition.name][transformerMutationType].push(queryObservable.map(function (_a) {\n                                          var value = _a.value;\n                                          return value;\n                                        }).subscribe({\n                                          next: function (_a) {\n                                            var data = _a.data,\n                                              errors = _a.errors;\n                                            if (Array.isArray(errors) && errors.length > 0) {\n                                              var messages = errors.map(function (_a) {\n                                                var message = _a.message;\n                                                return message;\n                                              });\n                                              logger.warn(\"Skipping incoming subscription. Messages: \" + messages.join('\\n'));\n                                              _this.drainBuffer();\n                                              return;\n                                            }\n                                            var predicatesGroup = ModelPredicateCreator.getPredicates(_this.syncPredicates.get(modelDefinition), false);\n                                            // @ts-ignore\n                                            var _b = data,\n                                              _c = opName,\n                                              record = _b[_c];\n                                            // checking incoming subscription against syncPredicate.\n                                            // once AppSync implements filters on subscriptions, we'll be\n                                            // able to set these when establishing the subscription instead.\n                                            // Until then, we'll need to filter inbound\n                                            if (_this.passesPredicateValidation(record, predicatesGroup)) {\n                                              _this.pushToBuffer(transformerMutationType, modelDefinition, record);\n                                            }\n                                            _this.drainBuffer();\n                                          },\n                                          error: function (subscriptionError) {\n                                            return __awaiter(_this, void 0, void 0, function () {\n                                              var _a, _b, _c, _d, message, isRTFError, e_1;\n                                              return __generator(this, function (_e) {\n                                                switch (_e.label) {\n                                                  case 0:\n                                                    _a = subscriptionError.error, _b = __read((_a === void 0 ? {\n                                                      errors: []\n                                                    } : _a).errors, 1), _c = _b[0], _d = (_c === void 0 ? {} : _c).message, message = _d === void 0 ? '' : _d;\n                                                    isRTFError =\n                                                    // only attempt catch if a filter variable was added to the subscription query\n                                                    addFilter && this.catchRTFError(message, modelDefinition, predicatesGroup);\n                                                    // Catch RTF errors\n                                                    if (isRTFError) {\n                                                      // Unsubscribe and clear subscription array for model/operation\n                                                      subscriptions[modelDefinition.name][transformerMutationType].forEach(function (subscription) {\n                                                        return subscription.unsubscribe();\n                                                      });\n                                                      subscriptions[modelDefinition.name][transformerMutationType] = [];\n                                                      // retry subscription connection without filter\n                                                      subscriptionRetry(operation, false);\n                                                      return [2 /*return*/];\n                                                    }\n                                                    if (message.includes(PUBSUB_CONTROL_MSG.REALTIME_SUBSCRIPTION_INIT_ERROR) || message.includes(PUBSUB_CONTROL_MSG.CONNECTION_FAILED)) {\n                                                      // Unsubscribe and clear subscription array for model/operation\n                                                      subscriptions[modelDefinition.name][transformerMutationType].forEach(function (subscription) {\n                                                        return subscription.unsubscribe();\n                                                      });\n                                                      subscriptions[modelDefinition.name][transformerMutationType] = [];\n                                                      operationAuthModeAttempts[operation]++;\n                                                      if (operationAuthModeAttempts[operation] >= readAuthModes.length) {\n                                                        // last auth mode retry. Continue with error\n                                                        logger.debug(operation + \" subscription failed with authMode: \" + readAuthModes[operationAuthModeAttempts[operation] - 1]);\n                                                      } else {\n                                                        // retry with different auth mode. Do not trigger\n                                                        // observer error or error handler\n                                                        logger.debug(operation + \" subscription failed with authMode: \" + readAuthModes[operationAuthModeAttempts[operation] - 1] + \". Retrying with authMode: \" + readAuthModes[operationAuthModeAttempts[operation]]);\n                                                        subscriptionRetry(operation);\n                                                        return [2 /*return*/];\n                                                      }\n                                                    }\n                                                    logger.warn('subscriptionError', message);\n                                                    _e.label = 1;\n                                                  case 1:\n                                                    _e.trys.push([1, 3,, 4]);\n                                                    return [4 /*yield*/, this.errorHandler({\n                                                      recoverySuggestion: 'Ensure app code is up to date, auth directives exist and are correct on each model, and that server-side data has not been invalidated by a schema change. If the problem persists, search for or create an issue: https://github.com/aws-amplify/amplify-js/issues',\n                                                      localModel: null,\n                                                      message: message,\n                                                      model: modelDefinition.name,\n                                                      operation: operation,\n                                                      errorType: getSubscriptionErrorType(subscriptionError),\n                                                      process: ProcessName.subscribe,\n                                                      remoteModel: null,\n                                                      cause: subscriptionError\n                                                    })];\n                                                  case 2:\n                                                    _e.sent();\n                                                    return [3 /*break*/, 4];\n                                                  case 3:\n                                                    e_1 = _e.sent();\n                                                    logger.error('Subscription error handler failed with:', e_1);\n                                                    return [3 /*break*/, 4];\n                                                  case 4:\n                                                    if (typeof subscriptionReadyCallback === 'function') {\n                                                      subscriptionReadyCallback();\n                                                    }\n                                                    if (message.includes('\"errorType\":\"Unauthorized\"') || message.includes('\"errorType\":\"OperationDisabled\"')) {\n                                                      return [2 /*return*/];\n                                                    }\n                                                    observer.error(message);\n                                                    return [2 /*return*/];\n                                                }\n                                              });\n                                            });\n                                          }\n                                        }));\n                                        promises.push(function () {\n                                          return __awaiter(_this, void 0, void 0, function () {\n                                            var boundFunction;\n                                            var _this = this;\n                                            return __generator(this, function (_a) {\n                                              switch (_a.label) {\n                                                case 0:\n                                                  return [4 /*yield*/, new Promise(function (res) {\n                                                    subscriptionReadyCallback = res;\n                                                    boundFunction = _this.hubQueryCompletionListener.bind(_this, res);\n                                                    Hub.listen('api', boundFunction);\n                                                  })];\n                                                case 1:\n                                                  _a.sent();\n                                                  Hub.remove('api', boundFunction);\n                                                  return [2 /*return*/];\n                                              }\n                                            });\n                                          });\n                                        }());\n                                        return [2 /*return*/];\n                                    }\n                                  });\n                                });\n                              };\n                              operations.forEach(function (op) {\n                                return subscriptionRetry(op);\n                              });\n                              return [2 /*return*/];\n                          }\n                        });\n                      });\n                    });\n                  });\n                });\n                this.runningProcesses.isOpen && this.runningProcesses.add(function () {\n                  return Promise.all(promises).then(function () {\n                    observer.next(CONTROL_MSG.CONNECTED);\n                  });\n                });\n                return [2 /*return*/];\n            }\n          });\n        });\n      }, 'subscription processor new subscriber');\n      return _this.runningProcesses.addCleaner(function () {\n        return __awaiter(_this, void 0, void 0, function () {\n          return __generator(this, function (_a) {\n            Object.keys(subscriptions).forEach(function (modelName) {\n              subscriptions[modelName][TransformerMutationType.CREATE].forEach(function (subscription) {\n                return subscription.unsubscribe();\n              });\n              subscriptions[modelName][TransformerMutationType.UPDATE].forEach(function (subscription) {\n                return subscription.unsubscribe();\n              });\n              subscriptions[modelName][TransformerMutationType.DELETE].forEach(function (subscription) {\n                return subscription.unsubscribe();\n              });\n            });\n            return [2 /*return*/];\n          });\n        });\n      });\n    });\n    var dataObservable = new Observable(function (observer) {\n      _this.dataObserver = observer;\n      _this.drainBuffer();\n      return _this.runningProcesses.addCleaner(function () {\n        return __awaiter(_this, void 0, void 0, function () {\n          return __generator(this, function (_a) {\n            this.dataObserver = null;\n            return [2 /*return*/];\n          });\n        });\n      });\n    });\n    return [ctlObservable, dataObservable];\n  };\n  SubscriptionProcessor.prototype.stop = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, this.runningProcesses.close()];\n          case 1:\n            _a.sent();\n            return [4 /*yield*/, this.runningProcesses.open()];\n          case 2:\n            _a.sent();\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  SubscriptionProcessor.prototype.passesPredicateValidation = function (record, predicatesGroup) {\n    if (!predicatesGroup) {\n      return true;\n    }\n    var predicates = predicatesGroup.predicates,\n      type = predicatesGroup.type;\n    return validatePredicate(record, type, predicates);\n  };\n  SubscriptionProcessor.prototype.pushToBuffer = function (transformerMutationType, modelDefinition, data) {\n    this.buffer.push([transformerMutationType, modelDefinition, data]);\n  };\n  SubscriptionProcessor.prototype.drainBuffer = function () {\n    var _this = this;\n    if (this.dataObserver) {\n      this.buffer.forEach(function (data) {\n        return _this.dataObserver.next(data);\n      });\n      this.buffer = [];\n    }\n  };\n  /**\n   * @returns true if the service returned an RTF subscription error\n   * @remarks logs a warning with remediation instructions\n   *\n   */\n  SubscriptionProcessor.prototype.catchRTFError = function (message, modelDefinition, predicatesGroup) {\n    var header = 'Backend subscriptions filtering error.\\n' + 'Subscriptions filtering will be applied clientside.\\n';\n    var messageErrorTypeMap = {\n      'UnknownArgument: Unknown field argument filter': RTFError.UnknownField,\n      'Filters exceed maximum attributes limit': RTFError.MaxAttributes,\n      'Filters combination exceed maximum limit': RTFError.MaxCombinations,\n      'filter uses same fieldName multiple time': RTFError.RepeatedFieldname,\n      \"The variables input contains a field name 'not'\": RTFError.NotGroup,\n      'The variables input contains a field that is not defined for input object type': RTFError.FieldNotInType\n    };\n    var _a = __read(Object.entries(messageErrorTypeMap).find(function (_a) {\n        var _b = __read(_a, 1),\n          errorMsg = _b[0];\n        return message.includes(errorMsg);\n      }) || [], 2),\n      _errorMsg = _a[0],\n      errorType = _a[1];\n    if (errorType !== undefined) {\n      var remediationMessage = generateRTFRemediation(errorType, modelDefinition, predicatesGroup);\n      logger.warn(header + \"\\n\" + message + \"\\n\" + remediationMessage);\n      return true;\n    }\n    return false;\n  };\n  return SubscriptionProcessor;\n}();\nexport { SubscriptionProcessor };\n//# sourceMappingURL=subscription.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}