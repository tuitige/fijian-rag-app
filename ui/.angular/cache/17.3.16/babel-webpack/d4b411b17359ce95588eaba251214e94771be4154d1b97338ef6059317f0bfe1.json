{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { __assign, __awaiter, __generator, __rest } from \"tslib\";\nimport { ConsoleLogger as Logger, Hub, StorageHelper } from '@aws-amplify/core';\nimport flatten from 'lodash/flatten';\nimport { addEventListener, notifyEventListeners } from '../common';\nimport { AWSPinpointProvider } from './Providers';\nimport { InAppMessageInteractionEvent } from './types';\nvar STORAGE_KEY_SUFFIX = '_inAppMessages';\nvar logger = new Logger('Notifications.InAppMessaging');\nvar InAppMessaging = /** @class */function () {\n  function InAppMessaging() {\n    var _this = this;\n    this.config = {};\n    this.listeningForAnalyticEvents = false;\n    this.pluggables = [];\n    this.storageSynced = false;\n    /**\n     * Configure InAppMessaging\n     * @param {Object} config - InAppMessaging configuration object\n     */\n    this.configure = function (_a) {\n      if (_a === void 0) {\n        _a = {};\n      }\n      var _b = _a.listenForAnalyticsEvents,\n        listenForAnalyticsEvents = _b === void 0 ? true : _b,\n        config = __rest(_a, [\"listenForAnalyticsEvents\"]);\n      _this.config = __assign(__assign({}, _this.config), config);\n      logger.debug('configure InAppMessaging', _this.config);\n      _this.pluggables.forEach(function (pluggable) {\n        pluggable.configure(_this.config[pluggable.getProviderName()]);\n      });\n      if (_this.pluggables.length === 0) {\n        _this.addPluggable(new AWSPinpointProvider());\n      }\n      if (listenForAnalyticsEvents && !_this.listeningForAnalyticEvents) {\n        Hub.listen('analytics', _this.analyticsListener);\n        _this.listeningForAnalyticEvents = true;\n      }\n      return _this.config;\n    };\n    /**\n     * Get a plugin from added plugins\n     * @param {string} providerName - the name of the plugin to get\n     */\n    this.getPluggable = function (providerName) {\n      var _a;\n      var pluggable = (_a = _this.pluggables.find(function (pluggable) {\n        return pluggable.getProviderName() === providerName;\n      })) !== null && _a !== void 0 ? _a : null;\n      if (!pluggable) {\n        logger.debug(\"No plugin found with name \" + providerName);\n      }\n      return pluggable;\n    };\n    /**\n     * Add plugin into InAppMessaging\n     * @param {InAppMessagingProvider} pluggable - an instance of the plugin\n     */\n    this.addPluggable = function (pluggable) {\n      if (pluggable && pluggable.getCategory() === 'Notifications' && pluggable.getSubCategory() === 'InAppMessaging') {\n        if (_this.getPluggable(pluggable.getProviderName())) {\n          throw new Error(\"Pluggable \" + pluggable.getProviderName() + \" has already been added.\");\n        }\n        _this.pluggables.push(pluggable);\n        pluggable.configure(_this.config[pluggable.getProviderName()]);\n      }\n    };\n    /**\n     * Remove a plugin from added plugins\n     * @param {string} providerName - the name of the plugin to remove\n     */\n    this.removePluggable = function (providerName) {\n      var index = _this.pluggables.findIndex(function (pluggable) {\n        return pluggable.getProviderName() === providerName;\n      });\n      if (index === -1) {\n        logger.debug(\"No plugin found with name \" + providerName);\n      } else {\n        _this.pluggables.splice(index, 1);\n      }\n    };\n    /**\n     * Get the map resources that are currently available through the provider\n     * @param {string} provider\n     * @returns - Array of available map resources\n     */\n    this.syncMessages = function () {\n      return Promise.all(_this.pluggables.map(function (pluggable) {\n        return __awaiter(_this, void 0, void 0, function () {\n          var messages, key, err_1;\n          return __generator(this, function (_a) {\n            switch (_a.label) {\n              case 0:\n                _a.trys.push([0, 3,, 4]);\n                return [4 /*yield*/, pluggable.getInAppMessages()];\n              case 1:\n                messages = _a.sent();\n                key = \"\" + pluggable.getProviderName() + STORAGE_KEY_SUFFIX;\n                return [4 /*yield*/, this.setMessages(key, messages)];\n              case 2:\n                _a.sent();\n                return [3 /*break*/, 4];\n              case 3:\n                err_1 = _a.sent();\n                logger.error('Failed to sync messages', err_1);\n                throw err_1;\n              case 4:\n                return [2 /*return*/];\n            }\n          });\n        });\n      }));\n    };\n    this.clearMessages = function () {\n      return Promise.all(_this.pluggables.map(function (pluggable) {\n        return __awaiter(_this, void 0, void 0, function () {\n          var key;\n          return __generator(this, function (_a) {\n            switch (_a.label) {\n              case 0:\n                key = \"\" + pluggable.getProviderName() + STORAGE_KEY_SUFFIX;\n                return [4 /*yield*/, this.removeMessages(key)];\n              case 1:\n                _a.sent();\n                return [2 /*return*/];\n            }\n          });\n        });\n      }));\n    };\n    this.dispatchEvent = function (event) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var messages, flattenedMessages;\n        var _this = this;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              return [4 /*yield*/, Promise.all(this.pluggables.map(function (pluggable) {\n                return __awaiter(_this, void 0, void 0, function () {\n                  var key, messages;\n                  return __generator(this, function (_a) {\n                    switch (_a.label) {\n                      case 0:\n                        key = \"\" + pluggable.getProviderName() + STORAGE_KEY_SUFFIX;\n                        return [4 /*yield*/, this.getMessages(key)];\n                      case 1:\n                        messages = _a.sent();\n                        return [2 /*return*/, pluggable.processInAppMessages(messages, event)];\n                    }\n                  });\n                });\n              }))];\n            case 1:\n              messages = _a.sent();\n              flattenedMessages = flatten(messages);\n              if (flattenedMessages.length) {\n                notifyEventListeners(InAppMessageInteractionEvent.MESSAGE_RECEIVED, this.conflictHandler(flattenedMessages));\n              }\n              return [2 /*return*/];\n          }\n        });\n      });\n    };\n    this.identifyUser = function (userId, userInfo) {\n      return Promise.all(_this.pluggables.map(function (pluggable) {\n        return __awaiter(_this, void 0, void 0, function () {\n          var err_2;\n          return __generator(this, function (_a) {\n            switch (_a.label) {\n              case 0:\n                _a.trys.push([0, 2,, 3]);\n                return [4 /*yield*/, pluggable.identifyUser(userId, userInfo)];\n              case 1:\n                _a.sent();\n                return [3 /*break*/, 3];\n              case 2:\n                err_2 = _a.sent();\n                logger.error('Failed to identify user', err_2);\n                throw err_2;\n              case 3:\n                return [2 /*return*/];\n            }\n          });\n        });\n      }));\n    };\n    this.onMessageReceived = function (handler) {\n      return addEventListener(InAppMessageInteractionEvent.MESSAGE_RECEIVED, handler);\n    };\n    this.onMessageDisplayed = function (handler) {\n      return addEventListener(InAppMessageInteractionEvent.MESSAGE_DISPLAYED, handler);\n    };\n    this.onMessageDismissed = function (handler) {\n      return addEventListener(InAppMessageInteractionEvent.MESSAGE_DISMISSED, handler);\n    };\n    this.onMessageActionTaken = function (handler) {\n      return addEventListener(InAppMessageInteractionEvent.MESSAGE_ACTION_TAKEN, handler);\n    };\n    this.notifyMessageInteraction = function (message, type) {\n      notifyEventListeners(type, message);\n    };\n    this.setConflictHandler = function (handler) {\n      _this.conflictHandler = handler;\n    };\n    this.analyticsListener = function (_a) {\n      var payload = _a.payload;\n      var event = payload.event,\n        data = payload.data;\n      switch (event) {\n        case 'record':\n          {\n            _this.dispatchEvent(data);\n            break;\n          }\n        default:\n          break;\n      }\n    };\n    this.syncStorage = function () {\n      return __awaiter(_this, void 0, void 0, function () {\n        var storage, err_3;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              storage = this.config.storage;\n              _a.label = 1;\n            case 1:\n              _a.trys.push([1, 4,, 5]);\n              if (!(typeof storage.sync === 'function')) return [3 /*break*/, 3];\n              return [4 /*yield*/, storage.sync()];\n            case 2:\n              _a.sent();\n              _a.label = 3;\n            case 3:\n              this.storageSynced = true;\n              return [3 /*break*/, 5];\n            case 4:\n              err_3 = _a.sent();\n              logger.error('Failed to sync storage', err_3);\n              return [3 /*break*/, 5];\n            case 5:\n              return [2 /*return*/];\n          }\n        });\n      });\n    };\n    this.getMessages = function (key) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var storage, storedMessages, err_4;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              _a.trys.push([0, 3,, 4]);\n              if (!!this.storageSynced) return [3 /*break*/, 2];\n              return [4 /*yield*/, this.syncStorage()];\n            case 1:\n              _a.sent();\n              _a.label = 2;\n            case 2:\n              storage = this.config.storage;\n              storedMessages = storage.getItem(key);\n              return [2 /*return*/, storedMessages ? JSON.parse(storedMessages) : []];\n            case 3:\n              err_4 = _a.sent();\n              logger.error('Failed to retrieve in-app messages from storage', err_4);\n              return [3 /*break*/, 4];\n            case 4:\n              return [2 /*return*/];\n          }\n        });\n      });\n    };\n    this.setMessages = function (key, messages) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var storage, err_5;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              if (!messages) {\n                return [2 /*return*/];\n              }\n              _a.label = 1;\n            case 1:\n              _a.trys.push([1, 4,, 5]);\n              if (!!this.storageSynced) return [3 /*break*/, 3];\n              return [4 /*yield*/, this.syncStorage()];\n            case 2:\n              _a.sent();\n              _a.label = 3;\n            case 3:\n              storage = this.config.storage;\n              storage.setItem(key, JSON.stringify(messages));\n              return [3 /*break*/, 5];\n            case 4:\n              err_5 = _a.sent();\n              logger.error('Failed to store in-app messages', err_5);\n              return [3 /*break*/, 5];\n            case 5:\n              return [2 /*return*/];\n          }\n        });\n      });\n    };\n    this.removeMessages = function (key) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var storage, err_6;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              _a.trys.push([0, 3,, 4]);\n              if (!!this.storageSynced) return [3 /*break*/, 2];\n              return [4 /*yield*/, this.syncStorage()];\n            case 1:\n              _a.sent();\n              _a.label = 2;\n            case 2:\n              storage = this.config.storage;\n              storage.removeItem(key);\n              return [3 /*break*/, 4];\n            case 3:\n              err_6 = _a.sent();\n              logger.error('Failed to remove in-app messages from storage', err_6);\n              return [3 /*break*/, 4];\n            case 4:\n              return [2 /*return*/];\n          }\n        });\n      });\n    };\n    this.defaultConflictHandler = function (messages) {\n      // default behavior is to return the message closest to expiry\n      // this function assumes that messages processed by providers already filters out expired messages\n      var sorted = messages.sort(function (a, b) {\n        var _a, _b;\n        var endDateA = (_a = a.metadata) === null || _a === void 0 ? void 0 : _a.endDate;\n        var endDateB = (_b = b.metadata) === null || _b === void 0 ? void 0 : _b.endDate;\n        // if both message end dates are falsy or have the same date string, treat them as equal\n        if (endDateA === endDateB) {\n          return 0;\n        }\n        // if only message A has an end date, treat it as closer to expiry\n        if (endDateA && !endDateB) {\n          return -1;\n        }\n        // if only message B has an end date, treat it as closer to expiry\n        if (!endDateA && endDateB) {\n          return 1;\n        }\n        // otherwise, compare them\n        return new Date(endDateA) < new Date(endDateB) ? -1 : 1;\n      });\n      // always return the top sorted\n      return sorted[0];\n    };\n    this.config = {\n      storage: new StorageHelper().getStorage()\n    };\n    this.setConflictHandler(this.defaultConflictHandler);\n  }\n  /**\n   * Get the name of this module\n   * @returns {string} name of this module\n   */\n  InAppMessaging.prototype.getModuleName = function () {\n    return 'InAppMessaging';\n  };\n  return InAppMessaging;\n}();\nexport default InAppMessaging;\n//# sourceMappingURL=InAppMessaging.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}