{"ast":null,"code":"import { __awaiter, __generator, __read, __spread, __values } from \"tslib\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { browserOrNode, ConsoleLogger as Logger, BackgroundProcessManager, Hub } from '@aws-amplify/core';\nimport { CONTROL_MSG as PUBSUB_CONTROL_MSG, CONNECTION_STATE_CHANGE as PUBSUB_CONNECTION_STATE_CHANGE, ConnectionState } from '@aws-amplify/pubsub';\nimport Observable from 'zen-observable-ts';\nimport { ModelPredicateCreator } from '../predicates';\nimport { OpType } from '../types';\nimport { getNow, SYNC, USER } from '../util';\nimport DataStoreConnectivity from './datastoreConnectivity';\nimport { ModelMerger } from './merger';\nimport { MutationEventOutbox } from './outbox';\nimport { MutationProcessor } from './processors/mutation';\nimport { CONTROL_MSG, SubscriptionProcessor } from './processors/subscription';\nimport { SyncProcessor } from './processors/sync';\nimport { createMutationInstanceFromModelOperation, getIdentifierValue, predicateToGraphQLCondition } from './utils';\nvar isNode = browserOrNode().isNode;\nvar logger = new Logger('DataStore');\nvar ownSymbol = Symbol('sync');\nexport var ControlMessage = /*#__PURE__*/function (ControlMessage) {\n  ControlMessage[\"SYNC_ENGINE_STORAGE_SUBSCRIBED\"] = \"storageSubscribed\";\n  ControlMessage[\"SYNC_ENGINE_SUBSCRIPTIONS_ESTABLISHED\"] = \"subscriptionsEstablished\";\n  ControlMessage[\"SYNC_ENGINE_SYNC_QUERIES_STARTED\"] = \"syncQueriesStarted\";\n  ControlMessage[\"SYNC_ENGINE_SYNC_QUERIES_READY\"] = \"syncQueriesReady\";\n  ControlMessage[\"SYNC_ENGINE_MODEL_SYNCED\"] = \"modelSynced\";\n  ControlMessage[\"SYNC_ENGINE_OUTBOX_MUTATION_ENQUEUED\"] = \"outboxMutationEnqueued\";\n  ControlMessage[\"SYNC_ENGINE_OUTBOX_MUTATION_PROCESSED\"] = \"outboxMutationProcessed\";\n  ControlMessage[\"SYNC_ENGINE_OUTBOX_STATUS\"] = \"outboxStatus\";\n  ControlMessage[\"SYNC_ENGINE_NETWORK_STATUS\"] = \"networkStatus\";\n  ControlMessage[\"SYNC_ENGINE_READY\"] = \"ready\";\n  return ControlMessage;\n}(ControlMessage || {});\nvar SyncEngine = /** @class */function () {\n  function SyncEngine(schema, namespaceResolver, modelClasses, userModelClasses, storage, modelInstanceCreator, conflictHandler, errorHandler, syncPredicates, amplifyConfig, authModeStrategy, amplifyContext, connectivityMonitor) {\n    var _this = this;\n    if (amplifyConfig === void 0) {\n      amplifyConfig = {};\n    }\n    this.schema = schema;\n    this.namespaceResolver = namespaceResolver;\n    this.modelClasses = modelClasses;\n    this.userModelClasses = userModelClasses;\n    this.storage = storage;\n    this.modelInstanceCreator = modelInstanceCreator;\n    this.syncPredicates = syncPredicates;\n    this.amplifyConfig = amplifyConfig;\n    this.authModeStrategy = authModeStrategy;\n    this.amplifyContext = amplifyContext;\n    this.connectivityMonitor = connectivityMonitor;\n    this.online = false;\n    this.modelSyncedStatus = new WeakMap();\n    this.connectionDisrupted = false;\n    this.runningProcesses = new BackgroundProcessManager();\n    this.waitForSleepState = new Promise(function (resolve) {\n      _this.syncQueriesObservableStartSleeping = resolve;\n    });\n    var MutationEvent = this.modelClasses['MutationEvent'];\n    this.outbox = new MutationEventOutbox(this.schema, MutationEvent, modelInstanceCreator, ownSymbol);\n    this.modelMerger = new ModelMerger(this.outbox, ownSymbol);\n    this.syncQueriesProcessor = new SyncProcessor(this.schema, this.syncPredicates, this.amplifyConfig, this.authModeStrategy, errorHandler, this.amplifyContext);\n    this.subscriptionsProcessor = new SubscriptionProcessor(this.schema, this.syncPredicates, this.amplifyConfig, this.authModeStrategy, errorHandler, this.amplifyContext);\n    this.mutationsProcessor = new MutationProcessor(this.schema, this.storage, this.userModelClasses, this.outbox, this.modelInstanceCreator, MutationEvent, this.amplifyConfig, this.authModeStrategy, errorHandler, conflictHandler, this.amplifyContext);\n    this.datastoreConnectivity = this.connectivityMonitor || new DataStoreConnectivity();\n  }\n  SyncEngine.prototype.getModelSyncedStatus = function (modelConstructor) {\n    return this.modelSyncedStatus.get(modelConstructor);\n  };\n  SyncEngine.prototype.start = function (params) {\n    var _this = this;\n    return new Observable(function (observer) {\n      logger.log('starting sync engine...');\n      var subscriptions = [];\n      _this.runningProcesses.add(function () {\n        return __awaiter(_this, void 0, void 0, function () {\n          var err_1, startPromise, hasMutationsInOutbox;\n          var _this = this;\n          return __generator(this, function (_a) {\n            switch (_a.label) {\n              case 0:\n                _a.trys.push([0, 2,, 3]);\n                return [4 /*yield*/, this.setupModels(params)];\n              case 1:\n                _a.sent();\n                return [3 /*break*/, 3];\n              case 2:\n                err_1 = _a.sent();\n                observer.error(err_1);\n                return [2 /*return*/];\n              case 3:\n                startPromise = new Promise(function (doneStarting, failedStarting) {\n                  _this.datastoreConnectivity.status().subscribe(function (_a) {\n                    var online = _a.online;\n                    return __awaiter(_this, void 0, void 0, function () {\n                      var _this = this;\n                      return __generator(this, function (_b) {\n                        return [2 /*return*/, this.runningProcesses.isOpen && this.runningProcesses.add(function (onTerminate) {\n                          return __awaiter(_this, void 0, void 0, function () {\n                            var ctlSubsObservable_1, dataSubsObservable, err_2, error_1;\n                            var _a;\n                            var _this = this;\n                            return __generator(this, function (_b) {\n                              switch (_b.label) {\n                                case 0:\n                                  if (!(online && !this.online)) return [3 /*break*/, 10];\n                                  this.online = online;\n                                  observer.next({\n                                    type: ControlMessage.SYNC_ENGINE_NETWORK_STATUS,\n                                    data: {\n                                      active: this.online\n                                    }\n                                  });\n                                  dataSubsObservable = void 0;\n                                  if (!isNode) return [3 /*break*/, 1];\n                                  logger.warn('Realtime disabled when in a server-side environment');\n                                  return [3 /*break*/, 6];\n                                case 1:\n                                  this.stopDisruptionListener = this.startDisruptionListener();\n                                  //#region GraphQL Subscriptions\n                                  _a = __read(this.subscriptionsProcessor.start(), 2), ctlSubsObservable_1 = _a[0], dataSubsObservable = _a[1];\n                                  _b.label = 2;\n                                case 2:\n                                  _b.trys.push([2, 4,, 5]);\n                                  return [4 /*yield*/, new Promise(function (resolve, reject) {\n                                    onTerminate.then(reject);\n                                    var ctlSubsSubscription = ctlSubsObservable_1.subscribe({\n                                      next: function (msg) {\n                                        if (msg === CONTROL_MSG.CONNECTED) {\n                                          resolve();\n                                        }\n                                      },\n                                      error: function (err) {\n                                        reject(err);\n                                        var handleDisconnect = _this.disconnectionHandler();\n                                        handleDisconnect(err);\n                                      }\n                                    });\n                                    subscriptions.push(ctlSubsSubscription);\n                                  })];\n                                case 3:\n                                  _b.sent();\n                                  return [3 /*break*/, 5];\n                                case 4:\n                                  err_2 = _b.sent();\n                                  observer.error(err_2);\n                                  failedStarting();\n                                  return [2 /*return*/];\n                                case 5:\n                                  logger.log('Realtime ready');\n                                  observer.next({\n                                    type: ControlMessage.SYNC_ENGINE_SUBSCRIPTIONS_ESTABLISHED\n                                  });\n                                  _b.label = 6;\n                                case 6:\n                                  _b.trys.push([6, 8,, 9]);\n                                  return [4 /*yield*/, new Promise(function (resolve, reject) {\n                                    var syncQuerySubscription = _this.syncQueriesObservable().subscribe({\n                                      next: function (message) {\n                                        var type = message.type;\n                                        if (type === ControlMessage.SYNC_ENGINE_SYNC_QUERIES_READY) {\n                                          resolve();\n                                        }\n                                        observer.next(message);\n                                      },\n                                      complete: function () {\n                                        resolve();\n                                      },\n                                      error: function (error) {\n                                        reject(error);\n                                      }\n                                    });\n                                    if (syncQuerySubscription) {\n                                      subscriptions.push(syncQuerySubscription);\n                                    }\n                                  })];\n                                case 7:\n                                  _b.sent();\n                                  return [3 /*break*/, 9];\n                                case 8:\n                                  error_1 = _b.sent();\n                                  observer.error(error_1);\n                                  failedStarting();\n                                  return [2 /*return*/];\n                                case 9:\n                                  //#endregion\n                                  //#region process mutations (outbox)\n                                  subscriptions.push(this.mutationsProcessor.start().subscribe(function (_a) {\n                                    var modelDefinition = _a.modelDefinition,\n                                      item = _a.model,\n                                      hasMore = _a.hasMore;\n                                    return _this.runningProcesses.add(function () {\n                                      return __awaiter(_this, void 0, void 0, function () {\n                                        var modelConstructor, model;\n                                        var _this = this;\n                                        return __generator(this, function (_a) {\n                                          switch (_a.label) {\n                                            case 0:\n                                              modelConstructor = this.userModelClasses[modelDefinition.name];\n                                              model = this.modelInstanceCreator(modelConstructor, item);\n                                              return [4 /*yield*/, this.storage.runExclusive(function (storage) {\n                                                return _this.modelMerger.merge(storage, model, modelDefinition);\n                                              })];\n                                            case 1:\n                                              _a.sent();\n                                              observer.next({\n                                                type: ControlMessage.SYNC_ENGINE_OUTBOX_MUTATION_PROCESSED,\n                                                data: {\n                                                  model: modelConstructor,\n                                                  element: model\n                                                }\n                                              });\n                                              observer.next({\n                                                type: ControlMessage.SYNC_ENGINE_OUTBOX_STATUS,\n                                                data: {\n                                                  isEmpty: !hasMore\n                                                }\n                                              });\n                                              return [2 /*return*/];\n                                          }\n                                        });\n                                      });\n                                    }, 'mutation processor event');\n                                  }));\n                                  //#endregion\n                                  //#region Merge subscriptions buffer\n                                  // TODO: extract to function\n                                  if (!isNode) {\n                                    subscriptions.push(dataSubsObservable.subscribe(function (_a) {\n                                      var _b = __read(_a, 3),\n                                        _transformerMutationType = _b[0],\n                                        modelDefinition = _b[1],\n                                        item = _b[2];\n                                      return _this.runningProcesses.add(function () {\n                                        return __awaiter(_this, void 0, void 0, function () {\n                                          var modelConstructor, model;\n                                          var _this = this;\n                                          return __generator(this, function (_a) {\n                                            switch (_a.label) {\n                                              case 0:\n                                                modelConstructor = this.userModelClasses[modelDefinition.name];\n                                                model = this.modelInstanceCreator(modelConstructor, item);\n                                                return [4 /*yield*/, this.storage.runExclusive(function (storage) {\n                                                  return _this.modelMerger.merge(storage, model, modelDefinition);\n                                                })];\n                                              case 1:\n                                                _a.sent();\n                                                return [2 /*return*/];\n                                            }\n                                          });\n                                        });\n                                      }, 'subscription dataSubsObservable event');\n                                    }));\n                                  }\n                                  return [3 /*break*/, 11];\n                                case 10:\n                                  if (!online) {\n                                    this.online = online;\n                                    observer.next({\n                                      type: ControlMessage.SYNC_ENGINE_NETWORK_STATUS,\n                                      data: {\n                                        active: this.online\n                                      }\n                                    });\n                                    subscriptions.forEach(function (sub) {\n                                      return sub.unsubscribe();\n                                    });\n                                    subscriptions = [];\n                                  }\n                                  _b.label = 11;\n                                case 11:\n                                  doneStarting();\n                                  return [2 /*return*/];\n                              }\n                            });\n                          });\n                        }, 'datastore connectivity event')];\n                      });\n                    });\n                  });\n                });\n                this.storage.observe(null, null, ownSymbol).filter(function (_a) {\n                  var model = _a.model;\n                  var modelDefinition = _this.getModelDefinition(model);\n                  return modelDefinition.syncable === true;\n                }).subscribe({\n                  next: function (_a) {\n                    var opType = _a.opType,\n                      model = _a.model,\n                      element = _a.element,\n                      condition = _a.condition;\n                    return __awaiter(_this, void 0, void 0, function () {\n                      var _this = this;\n                      return __generator(this, function (_b) {\n                        return [2 /*return*/, this.runningProcesses.add(function () {\n                          return __awaiter(_this, void 0, void 0, function () {\n                            var namespace, MutationEventConstructor, modelDefinition, graphQLCondition, mutationEvent;\n                            return __generator(this, function (_a) {\n                              switch (_a.label) {\n                                case 0:\n                                  namespace = this.schema.namespaces[this.namespaceResolver(model)];\n                                  MutationEventConstructor = this.modelClasses['MutationEvent'];\n                                  modelDefinition = this.getModelDefinition(model);\n                                  graphQLCondition = predicateToGraphQLCondition(condition, modelDefinition);\n                                  mutationEvent = createMutationInstanceFromModelOperation(namespace.relationships, this.getModelDefinition(model), opType, model, element, graphQLCondition, MutationEventConstructor, this.modelInstanceCreator);\n                                  return [4 /*yield*/, this.outbox.enqueue(this.storage, mutationEvent)];\n                                case 1:\n                                  _a.sent();\n                                  observer.next({\n                                    type: ControlMessage.SYNC_ENGINE_OUTBOX_MUTATION_ENQUEUED,\n                                    data: {\n                                      model: model,\n                                      element: element\n                                    }\n                                  });\n                                  observer.next({\n                                    type: ControlMessage.SYNC_ENGINE_OUTBOX_STATUS,\n                                    data: {\n                                      isEmpty: false\n                                    }\n                                  });\n                                  return [4 /*yield*/, startPromise];\n                                case 2:\n                                  _a.sent();\n                                  // Set by the this.datastoreConnectivity.status().subscribe() loop\n                                  if (this.online) {\n                                    this.mutationsProcessor.resume();\n                                  }\n                                  return [2 /*return*/];\n                              }\n                            });\n                          });\n                        }, 'storage event')];\n                      });\n                    });\n                  }\n                });\n                observer.next({\n                  type: ControlMessage.SYNC_ENGINE_STORAGE_SUBSCRIBED\n                });\n                return [4 /*yield*/, this.outbox.peek(this.storage)];\n              case 4:\n                hasMutationsInOutbox = _a.sent() === undefined;\n                observer.next({\n                  type: ControlMessage.SYNC_ENGINE_OUTBOX_STATUS,\n                  data: {\n                    isEmpty: hasMutationsInOutbox\n                  }\n                });\n                return [4 /*yield*/, startPromise];\n              case 5:\n                _a.sent();\n                observer.next({\n                  type: ControlMessage.SYNC_ENGINE_READY\n                });\n                return [2 /*return*/];\n            }\n          });\n        });\n      }, 'sync start');\n    });\n  };\n  SyncEngine.prototype.getModelsMetadataWithNextFullSync = function (currentTimeStamp) {\n    return __awaiter(this, void 0, void 0, function () {\n      var modelLastSync, _a;\n      var _this = this;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            _a = Map.bind;\n            return [4 /*yield*/, this.runningProcesses.add(function () {\n              return _this.getModelsMetadata();\n            }, 'sync/index getModelsMetadataWithNextFullSync')];\n          case 1:\n            modelLastSync = new (_a.apply(Map, [void 0, _b.sent().map(function (_a) {\n              var namespace = _a.namespace,\n                model = _a.model,\n                lastSync = _a.lastSync,\n                lastFullSync = _a.lastFullSync,\n                fullSyncInterval = _a.fullSyncInterval,\n                lastSyncPredicate = _a.lastSyncPredicate;\n              var nextFullSync = lastFullSync + fullSyncInterval;\n              var syncFrom = !lastFullSync || nextFullSync < currentTimeStamp ? 0 // perform full sync if expired\n              : lastSync; // perform delta sync\n              return [_this.schema.namespaces[namespace].models[model], [namespace, syncFrom]];\n            })]))();\n            return [2 /*return*/, modelLastSync];\n        }\n      });\n    });\n  };\n  SyncEngine.prototype.syncQueriesObservable = function () {\n    var _this = this;\n    if (!this.online) {\n      return Observable.of();\n    }\n    return new Observable(function (observer) {\n      var syncQueriesSubscription;\n      _this.runningProcesses.isOpen && _this.runningProcesses.add(function (onTerminate) {\n        return __awaiter(_this, void 0, void 0, function () {\n          var terminated, _loop_1, this_1;\n          var _this = this;\n          return __generator(this, function (_a) {\n            switch (_a.label) {\n              case 0:\n                terminated = false;\n                _loop_1 = function () {\n                  var count, modelLastSync, paginatingModels, lastFullSyncStartedAt, syncInterval, start, syncDuration, lastStartedAt, msNextFullSync;\n                  return __generator(this, function (_a) {\n                    switch (_a.label) {\n                      case 0:\n                        count = new WeakMap();\n                        return [4 /*yield*/, this_1.getModelsMetadataWithNextFullSync(Date.now())];\n                      case 1:\n                        modelLastSync = _a.sent();\n                        paginatingModels = new Set(modelLastSync.keys());\n                        return [4 /*yield*/, new Promise(function (resolve, reject) {\n                          if (!_this.runningProcesses.isOpen) resolve();\n                          onTerminate.then(function () {\n                            return resolve();\n                          });\n                          syncQueriesSubscription = _this.syncQueriesProcessor.start(modelLastSync).subscribe({\n                            next: function (_a) {\n                              var namespace = _a.namespace,\n                                modelDefinition = _a.modelDefinition,\n                                items = _a.items,\n                                done = _a.done,\n                                startedAt = _a.startedAt,\n                                isFullSync = _a.isFullSync;\n                              return __awaiter(_this, void 0, void 0, function () {\n                                var modelConstructor, modelName, modelMetadata_1, lastFullSync, fullSyncInterval, counts;\n                                var _this = this;\n                                return __generator(this, function (_b) {\n                                  switch (_b.label) {\n                                    case 0:\n                                      modelConstructor = this.userModelClasses[modelDefinition.name];\n                                      if (!count.has(modelConstructor)) {\n                                        count.set(modelConstructor, {\n                                          new: 0,\n                                          updated: 0,\n                                          deleted: 0\n                                        });\n                                        start = getNow();\n                                        lastStartedAt = lastStartedAt === undefined ? startedAt : Math.max(lastStartedAt, startedAt);\n                                      }\n                                      /**\n                                       * If there are mutations in the outbox for a given id, those need to be\n                                       * merged individually. Otherwise, we can merge them in batches.\n                                       */\n                                      return [4 /*yield*/, this.storage.runExclusive(function (storage) {\n                                        return __awaiter(_this, void 0, void 0, function () {\n                                          var idsInOutbox, oneByOne, page, opTypeCount, oneByOne_1, oneByOne_1_1, item, opType, e_1_1, _a, _b, _c, counts;\n                                          var e_1, _d;\n                                          return __generator(this, function (_e) {\n                                            switch (_e.label) {\n                                              case 0:\n                                                return [4 /*yield*/, this.outbox.getModelIds(storage)];\n                                              case 1:\n                                                idsInOutbox = _e.sent();\n                                                oneByOne = [];\n                                                page = items.filter(function (item) {\n                                                  var itemId = getIdentifierValue(modelDefinition, item);\n                                                  if (!idsInOutbox.has(itemId)) {\n                                                    return true;\n                                                  }\n                                                  oneByOne.push(item);\n                                                  return false;\n                                                });\n                                                opTypeCount = [];\n                                                _e.label = 2;\n                                              case 2:\n                                                _e.trys.push([2, 7, 8, 9]);\n                                                oneByOne_1 = __values(oneByOne), oneByOne_1_1 = oneByOne_1.next();\n                                                _e.label = 3;\n                                              case 3:\n                                                if (!!oneByOne_1_1.done) return [3 /*break*/, 6];\n                                                item = oneByOne_1_1.value;\n                                                return [4 /*yield*/, this.modelMerger.merge(storage, item, modelDefinition)];\n                                              case 4:\n                                                opType = _e.sent();\n                                                if (opType !== undefined) {\n                                                  opTypeCount.push([item, opType]);\n                                                }\n                                                _e.label = 5;\n                                              case 5:\n                                                oneByOne_1_1 = oneByOne_1.next();\n                                                return [3 /*break*/, 3];\n                                              case 6:\n                                                return [3 /*break*/, 9];\n                                              case 7:\n                                                e_1_1 = _e.sent();\n                                                e_1 = {\n                                                  error: e_1_1\n                                                };\n                                                return [3 /*break*/, 9];\n                                              case 8:\n                                                try {\n                                                  if (oneByOne_1_1 && !oneByOne_1_1.done && (_d = oneByOne_1.return)) _d.call(oneByOne_1);\n                                                } finally {\n                                                  if (e_1) throw e_1.error;\n                                                }\n                                                return [7 /*endfinally*/];\n                                              case 9:\n                                                _b = (_a = opTypeCount.push).apply;\n                                                _c = [opTypeCount];\n                                                return [4 /*yield*/, this.modelMerger.mergePage(storage, modelConstructor, page, modelDefinition)];\n                                              case 10:\n                                                _b.apply(_a, _c.concat([__spread.apply(void 0, [_e.sent()])]));\n                                                counts = count.get(modelConstructor);\n                                                opTypeCount.forEach(function (_a) {\n                                                  var _b = __read(_a, 2),\n                                                    opType = _b[1];\n                                                  switch (opType) {\n                                                    case OpType.INSERT:\n                                                      counts.new++;\n                                                      break;\n                                                    case OpType.UPDATE:\n                                                      counts.updated++;\n                                                      break;\n                                                    case OpType.DELETE:\n                                                      counts.deleted++;\n                                                      break;\n                                                    default:\n                                                      throw new Error(\"Invalid opType \" + opType);\n                                                  }\n                                                });\n                                                return [2 /*return*/];\n                                            }\n                                          });\n                                        });\n                                      })];\n                                    case 1:\n                                      /**\n                                       * If there are mutations in the outbox for a given id, those need to be\n                                       * merged individually. Otherwise, we can merge them in batches.\n                                       */\n                                      _b.sent();\n                                      if (!done) return [3 /*break*/, 4];\n                                      modelName = modelDefinition.name;\n                                      return [4 /*yield*/, this.getModelMetadata(namespace, modelName)];\n                                    case 2:\n                                      modelMetadata_1 = _b.sent();\n                                      lastFullSync = modelMetadata_1.lastFullSync, fullSyncInterval = modelMetadata_1.fullSyncInterval;\n                                      syncInterval = fullSyncInterval;\n                                      lastFullSyncStartedAt = lastFullSyncStartedAt === undefined ? lastFullSync : Math.max(lastFullSyncStartedAt, isFullSync ? startedAt : lastFullSync);\n                                      modelMetadata_1 = this.modelClasses.ModelMetadata.copyOf(modelMetadata_1, function (draft) {\n                                        draft.lastSync = startedAt;\n                                        draft.lastFullSync = isFullSync ? startedAt : modelMetadata_1.lastFullSync;\n                                      });\n                                      return [4 /*yield*/, this.storage.save(modelMetadata_1, undefined, ownSymbol)];\n                                    case 3:\n                                      _b.sent();\n                                      counts = count.get(modelConstructor);\n                                      this.modelSyncedStatus.set(modelConstructor, true);\n                                      observer.next({\n                                        type: ControlMessage.SYNC_ENGINE_MODEL_SYNCED,\n                                        data: {\n                                          model: modelConstructor,\n                                          isFullSync: isFullSync,\n                                          isDeltaSync: !isFullSync,\n                                          counts: counts\n                                        }\n                                      });\n                                      paginatingModels.delete(modelDefinition);\n                                      if (paginatingModels.size === 0) {\n                                        syncDuration = getNow() - start;\n                                        resolve();\n                                        observer.next({\n                                          type: ControlMessage.SYNC_ENGINE_SYNC_QUERIES_READY\n                                        });\n                                        syncQueriesSubscription.unsubscribe();\n                                      }\n                                      _b.label = 4;\n                                    case 4:\n                                      return [2 /*return*/];\n                                  }\n                                });\n                              });\n                            },\n                            error: function (error) {\n                              observer.error(error);\n                            }\n                          });\n                          observer.next({\n                            type: ControlMessage.SYNC_ENGINE_SYNC_QUERIES_STARTED,\n                            data: {\n                              models: Array.from(paginatingModels).map(function (_a) {\n                                var name = _a.name;\n                                return name;\n                              })\n                            }\n                          });\n                        })];\n                      case 2:\n                        _a.sent();\n                        if (!lastFullSyncStartedAt) {\n                          msNextFullSync = syncInterval - syncDuration;\n                        } else {\n                          msNextFullSync = lastFullSyncStartedAt + syncInterval - (lastStartedAt + syncDuration);\n                        }\n                        logger.debug(\"Next fullSync in \" + msNextFullSync / 1000 + \" seconds. (\" + new Date(Date.now() + msNextFullSync) + \")\");\n                        // TODO: create `BackgroundProcessManager.sleep()` ... but, need to put\n                        // a lot of thought into what that contract looks like to\n                        //  support possible use-cases:\n                        //\n                        //  1. non-cancelable\n                        //  2. cancelable, unsleep on exit()\n                        //  3. cancelable, throw Error on exit()\n                        //  4. cancelable, callback first on exit()?\n                        //  5. ... etc. ? ...\n                        //\n                        // TLDR; this is a lot of complexity here for a sleep(),\n                        // but, it's not clear to me yet how to support an\n                        // extensible, centralized cancelable `sleep()` elegantly.\n                        return [4 /*yield*/, this_1.runningProcesses.add(function (onTerminate) {\n                          return __awaiter(_this, void 0, void 0, function () {\n                            var sleepTimer, unsleep, sleep;\n                            var _this = this;\n                            return __generator(this, function (_a) {\n                              sleep = new Promise(function (_unsleep) {\n                                unsleep = _unsleep;\n                                sleepTimer = setTimeout(unsleep, msNextFullSync);\n                              });\n                              onTerminate.then(function () {\n                                terminated = true;\n                                _this.syncQueriesObservableStartSleeping();\n                                unsleep();\n                              });\n                              this.unsleepSyncQueriesObservable = unsleep;\n                              this.syncQueriesObservableStartSleeping();\n                              return [2 /*return*/, sleep];\n                            });\n                          });\n                        }, 'syncQueriesObservable sleep')];\n                      case 3:\n                        // TODO: create `BackgroundProcessManager.sleep()` ... but, need to put\n                        // a lot of thought into what that contract looks like to\n                        //  support possible use-cases:\n                        //\n                        //  1. non-cancelable\n                        //  2. cancelable, unsleep on exit()\n                        //  3. cancelable, throw Error on exit()\n                        //  4. cancelable, callback first on exit()?\n                        //  5. ... etc. ? ...\n                        //\n                        // TLDR; this is a lot of complexity here for a sleep(),\n                        // but, it's not clear to me yet how to support an\n                        // extensible, centralized cancelable `sleep()` elegantly.\n                        _a.sent();\n                        this_1.unsleepSyncQueriesObservable = null;\n                        this_1.waitForSleepState = new Promise(function (resolve) {\n                          _this.syncQueriesObservableStartSleeping = resolve;\n                        });\n                        return [2 /*return*/];\n                    }\n                  });\n                };\n                this_1 = this;\n                _a.label = 1;\n              case 1:\n                if (!(!observer.closed && !terminated)) return [3 /*break*/, 3];\n                return [5 /*yield**/, _loop_1()];\n              case 2:\n                _a.sent();\n                return [3 /*break*/, 1];\n              case 3:\n                return [2 /*return*/];\n            }\n          });\n        });\n      }, 'syncQueriesObservable main');\n    });\n  };\n  SyncEngine.prototype.disconnectionHandler = function () {\n    var _this = this;\n    return function (msg) {\n      // This implementation is tied to AWSAppSyncRealTimeProvider 'Connection closed', 'Timeout disconnect' msg\n      if (PUBSUB_CONTROL_MSG.CONNECTION_CLOSED === msg || PUBSUB_CONTROL_MSG.TIMEOUT_DISCONNECT === msg) {\n        _this.datastoreConnectivity.socketDisconnected();\n      }\n    };\n  };\n  SyncEngine.prototype.unsubscribeConnectivity = function () {\n    this.datastoreConnectivity.unsubscribe();\n  };\n  /**\n   * Stops all subscription activities and resolves when all activies report\n   * that they're disconnected, done retrying, etc..\n   */\n  SyncEngine.prototype.stop = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            logger.debug('stopping sync engine');\n            /**\n             * Gracefully disconnecting subscribers first just prevents *more* work\n             * from entering the pipelines.\n             */\n            this.unsubscribeConnectivity();\n            /**\n             * Stop listening for websocket connection disruption\n             */\n            this.stopDisruptionListener && this.stopDisruptionListener();\n            /**\n             * aggressively shut down any lingering background processes.\n             * some of this might be semi-redundant with unsubscribing. however,\n             * unsubscribing doesn't allow us to wait for settling.\n             * (Whereas `stop()` does.)\n             */\n            return [4 /*yield*/, this.mutationsProcessor.stop()];\n          case 1:\n            /**\n             * aggressively shut down any lingering background processes.\n             * some of this might be semi-redundant with unsubscribing. however,\n             * unsubscribing doesn't allow us to wait for settling.\n             * (Whereas `stop()` does.)\n             */\n            _a.sent();\n            return [4 /*yield*/, this.subscriptionsProcessor.stop()];\n          case 2:\n            _a.sent();\n            return [4 /*yield*/, this.datastoreConnectivity.stop()];\n          case 3:\n            _a.sent();\n            return [4 /*yield*/, this.syncQueriesProcessor.stop()];\n          case 4:\n            _a.sent();\n            return [4 /*yield*/, this.runningProcesses.close()];\n          case 5:\n            _a.sent();\n            return [4 /*yield*/, this.runningProcesses.open()];\n          case 6:\n            _a.sent();\n            logger.debug('sync engine stopped and ready to restart');\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  SyncEngine.prototype.setupModels = function (params) {\n    return __awaiter(this, void 0, void 0, function () {\n      var fullSyncInterval, ModelMetadataConstructor, models, savedModel, promises, result, _a, _b, modelMetadata, modelName, e_2_1;\n      var e_2, _c;\n      var _this = this;\n      return __generator(this, function (_d) {\n        switch (_d.label) {\n          case 0:\n            fullSyncInterval = params.fullSyncInterval;\n            ModelMetadataConstructor = this.modelClasses.ModelMetadata;\n            models = [];\n            Object.values(this.schema.namespaces).forEach(function (namespace) {\n              Object.values(namespace.models).filter(function (_a) {\n                var syncable = _a.syncable;\n                return syncable;\n              }).forEach(function (model) {\n                models.push([namespace.name, model]);\n                if (namespace.name === USER) {\n                  var modelConstructor = _this.userModelClasses[model.name];\n                  _this.modelSyncedStatus.set(modelConstructor, false);\n                }\n              });\n            });\n            promises = models.map(function (_a) {\n              var _b = __read(_a, 2),\n                namespace = _b[0],\n                model = _b[1];\n              return __awaiter(_this, void 0, void 0, function () {\n                var modelMetadata, syncPredicate, lastSyncPredicate, prevSyncPredicate, syncPredicateUpdated_1;\n                var _c, _d, _e, _f;\n                return __generator(this, function (_g) {\n                  switch (_g.label) {\n                    case 0:\n                      return [4 /*yield*/, this.getModelMetadata(namespace, model.name)];\n                    case 1:\n                      modelMetadata = _g.sent();\n                      syncPredicate = ModelPredicateCreator.getPredicates(this.syncPredicates.get(model), false);\n                      lastSyncPredicate = syncPredicate ? JSON.stringify(syncPredicate) : null;\n                      if (!(modelMetadata === undefined)) return [3 /*break*/, 3];\n                      return [4 /*yield*/, this.storage.save(this.modelInstanceCreator(ModelMetadataConstructor, {\n                        model: model.name,\n                        namespace: namespace,\n                        lastSync: null,\n                        fullSyncInterval: fullSyncInterval,\n                        lastFullSync: null,\n                        lastSyncPredicate: lastSyncPredicate\n                      }), undefined, ownSymbol)];\n                    case 2:\n                      _c = __read.apply(void 0, [_g.sent(), 1]), _d = __read(_c[0], 1), savedModel = _d[0];\n                      return [3 /*break*/, 5];\n                    case 3:\n                      prevSyncPredicate = modelMetadata.lastSyncPredicate ? modelMetadata.lastSyncPredicate : null;\n                      syncPredicateUpdated_1 = prevSyncPredicate !== lastSyncPredicate;\n                      return [4 /*yield*/, this.storage.save(ModelMetadataConstructor.copyOf(modelMetadata, function (draft) {\n                        draft.fullSyncInterval = fullSyncInterval;\n                        // perform a base sync if the syncPredicate changed in between calls to DataStore.start\n                        // ensures that the local store contains all the data specified by the syncExpression\n                        if (syncPredicateUpdated_1) {\n                          draft.lastSync = null;\n                          draft.lastFullSync = null;\n                          draft.lastSyncPredicate = lastSyncPredicate;\n                        }\n                      }))];\n                    case 4:\n                      _e = __read.apply(void 0, [_g.sent(), 1]), _f = __read(_e[0], 1), savedModel = _f[0];\n                      _g.label = 5;\n                    case 5:\n                      return [2 /*return*/, savedModel];\n                  }\n                });\n              });\n            });\n            result = {};\n            _d.label = 1;\n          case 1:\n            _d.trys.push([1, 6, 7, 8]);\n            return [4 /*yield*/, Promise.all(promises)];\n          case 2:\n            _a = __values.apply(void 0, [_d.sent()]), _b = _a.next();\n            _d.label = 3;\n          case 3:\n            if (!!_b.done) return [3 /*break*/, 5];\n            modelMetadata = _b.value;\n            modelName = modelMetadata.model;\n            result[modelName] = modelMetadata;\n            _d.label = 4;\n          case 4:\n            _b = _a.next();\n            return [3 /*break*/, 3];\n          case 5:\n            return [3 /*break*/, 8];\n          case 6:\n            e_2_1 = _d.sent();\n            e_2 = {\n              error: e_2_1\n            };\n            return [3 /*break*/, 8];\n          case 7:\n            try {\n              if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n            } finally {\n              if (e_2) throw e_2.error;\n            }\n            return [7 /*endfinally*/];\n          case 8:\n            return [2 /*return*/, result];\n        }\n      });\n    });\n  };\n  SyncEngine.prototype.getModelsMetadata = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var ModelMetadata, modelsMetadata;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            ModelMetadata = this.modelClasses.ModelMetadata;\n            return [4 /*yield*/, this.storage.query(ModelMetadata)];\n          case 1:\n            modelsMetadata = _a.sent();\n            return [2 /*return*/, modelsMetadata];\n        }\n      });\n    });\n  };\n  SyncEngine.prototype.getModelMetadata = function (namespace, model) {\n    return __awaiter(this, void 0, void 0, function () {\n      var ModelMetadata, predicate, _a, modelMetadata;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            ModelMetadata = this.modelClasses.ModelMetadata;\n            predicate = ModelPredicateCreator.createFromAST(this.schema.namespaces[SYNC].models[ModelMetadata.name], {\n              and: [{\n                namespace: {\n                  eq: namespace\n                }\n              }, {\n                model: {\n                  eq: model\n                }\n              }]\n            });\n            return [4 /*yield*/, this.storage.query(ModelMetadata, predicate, {\n              page: 0,\n              limit: 1\n            })];\n          case 1:\n            _a = __read.apply(void 0, [_b.sent(), 1]), modelMetadata = _a[0];\n            return [2 /*return*/, modelMetadata];\n        }\n      });\n    });\n  };\n  SyncEngine.prototype.getModelDefinition = function (modelConstructor) {\n    var namespaceName = this.namespaceResolver(modelConstructor);\n    var modelDefinition = this.schema.namespaces[namespaceName].models[modelConstructor.name];\n    return modelDefinition;\n  };\n  SyncEngine.getNamespace = function () {\n    var namespace = {\n      name: SYNC,\n      relationships: {},\n      enums: {\n        OperationType: {\n          name: 'OperationType',\n          values: ['CREATE', 'UPDATE', 'DELETE']\n        }\n      },\n      nonModels: {},\n      models: {\n        MutationEvent: {\n          name: 'MutationEvent',\n          pluralName: 'MutationEvents',\n          syncable: false,\n          fields: {\n            id: {\n              name: 'id',\n              type: 'ID',\n              isRequired: true,\n              isArray: false\n            },\n            model: {\n              name: 'model',\n              type: 'String',\n              isRequired: true,\n              isArray: false\n            },\n            data: {\n              name: 'data',\n              type: 'String',\n              isRequired: true,\n              isArray: false\n            },\n            modelId: {\n              name: 'modelId',\n              type: 'String',\n              isRequired: true,\n              isArray: false\n            },\n            operation: {\n              name: 'operation',\n              type: {\n                enum: 'Operationtype'\n              },\n              isArray: false,\n              isRequired: true\n            },\n            condition: {\n              name: 'condition',\n              type: 'String',\n              isArray: false,\n              isRequired: true\n            }\n          }\n        },\n        ModelMetadata: {\n          name: 'ModelMetadata',\n          pluralName: 'ModelsMetadata',\n          syncable: false,\n          fields: {\n            id: {\n              name: 'id',\n              type: 'ID',\n              isRequired: true,\n              isArray: false\n            },\n            namespace: {\n              name: 'namespace',\n              type: 'String',\n              isRequired: true,\n              isArray: false\n            },\n            model: {\n              name: 'model',\n              type: 'String',\n              isRequired: true,\n              isArray: false\n            },\n            lastSync: {\n              name: 'lastSync',\n              type: 'Int',\n              isRequired: false,\n              isArray: false\n            },\n            lastFullSync: {\n              name: 'lastFullSync',\n              type: 'Int',\n              isRequired: false,\n              isArray: false\n            },\n            fullSyncInterval: {\n              name: 'fullSyncInterval',\n              type: 'Int',\n              isRequired: true,\n              isArray: false\n            },\n            lastSyncPredicate: {\n              name: 'lastSyncPredicate',\n              type: 'String',\n              isRequired: false,\n              isArray: false\n            }\n          }\n        }\n      }\n    };\n    return namespace;\n  };\n  /**\n   * listen for websocket connection disruption\n   *\n   * May indicate there was a period of time where messages\n   * from AppSync were missed. A sync needs to be triggered to\n   * retrieve the missed data.\n   */\n  SyncEngine.prototype.startDisruptionListener = function () {\n    var _this = this;\n    return Hub.listen('api', function (data) {\n      if (data.source === 'PubSub' && data.payload.event === PUBSUB_CONNECTION_STATE_CHANGE) {\n        var connectionState = data.payload.data.connectionState;\n        switch (connectionState) {\n          // Do not need to listen for ConnectionDisruptedPendingNetwork\n          // Normal network reconnection logic will handle the sync\n          case ConnectionState.ConnectionDisrupted:\n            _this.connectionDisrupted = true;\n            break;\n          case ConnectionState.Connected:\n            if (_this.connectionDisrupted) {\n              _this.scheduleSync();\n            }\n            _this.connectionDisrupted = false;\n            break;\n        }\n      }\n    });\n  };\n  /*\n   * Schedule a sync to start when syncQueriesObservable enters sleep state\n   * Start sync immediately if syncQueriesObservable is already in sleep state\n   */\n  SyncEngine.prototype.scheduleSync = function () {\n    var _this = this;\n    return this.runningProcesses.isOpen && this.runningProcesses.add(function () {\n      return _this.waitForSleepState.then(function () {\n        // unsleepSyncQueriesObservable will be set if waitForSleepState has resolved\n        _this.unsleepSyncQueriesObservable();\n      });\n    });\n  };\n  return SyncEngine;\n}();\nexport { SyncEngine };\n//# sourceMappingURL=index.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}