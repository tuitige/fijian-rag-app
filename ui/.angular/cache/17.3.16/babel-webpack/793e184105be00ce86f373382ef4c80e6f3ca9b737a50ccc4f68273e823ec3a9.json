{"ast":null,"code":"import { __assign, __awaiter, __generator, __read, __rest } from \"tslib\";\nimport { ModelPredicateCreator } from '../predicates';\nimport { QueryOne } from '../types';\nimport { USER, SYNC, valuesEqual } from '../util';\nimport { getIdentifierValue, TransformerMutationType } from './utils';\n// TODO: Persist deleted ids\n// https://github.com/aws-amplify/amplify-js/blob/datastore-docs/packages/datastore/docs/sync-engine.md#outbox\nvar MutationEventOutbox = /** @class */function () {\n  function MutationEventOutbox(schema, MutationEvent, modelInstanceCreator, ownSymbol) {\n    this.schema = schema;\n    this.MutationEvent = MutationEvent;\n    this.modelInstanceCreator = modelInstanceCreator;\n    this.ownSymbol = ownSymbol;\n  }\n  MutationEventOutbox.prototype.enqueue = function (storage, mutationEvent) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, storage.runExclusive(function (s) {\n              return __awaiter(_this, void 0, void 0, function () {\n                var mutationEventModelDefinition, predicate, _a, first, incomingMutationType, merged_1, incomingConditionJSON, incomingCondition, merged;\n                return __generator(this, function (_b) {\n                  switch (_b.label) {\n                    case 0:\n                      mutationEventModelDefinition = this.schema.namespaces[SYNC].models['MutationEvent'];\n                      predicate = ModelPredicateCreator.createFromAST(mutationEventModelDefinition, {\n                        and: [{\n                          modelId: {\n                            eq: mutationEvent.modelId\n                          }\n                        }, {\n                          id: {\n                            ne: this.inProgressMutationEventId\n                          }\n                        }]\n                      });\n                      return [4 /*yield*/, s.query(this.MutationEvent, predicate)];\n                    case 1:\n                      _a = __read.apply(void 0, [_b.sent(), 1]), first = _a[0];\n                      if (!(first === undefined)) return [3 /*break*/, 3];\n                      return [4 /*yield*/, s.save(mutationEvent, undefined, this.ownSymbol)];\n                    case 2:\n                      _b.sent();\n                      return [2 /*return*/];\n                    case 3:\n                      incomingMutationType = mutationEvent.operation;\n                      if (!(first.operation === TransformerMutationType.CREATE)) return [3 /*break*/, 8];\n                      if (!(incomingMutationType === TransformerMutationType.DELETE)) return [3 /*break*/, 5];\n                      return [4 /*yield*/, s.delete(this.MutationEvent, predicate)];\n                    case 4:\n                      _b.sent();\n                      return [3 /*break*/, 7];\n                    case 5:\n                      merged_1 = this.mergeUserFields(first, mutationEvent);\n                      return [4 /*yield*/, s.save(this.MutationEvent.copyOf(first, function (draft) {\n                        draft.data = merged_1.data;\n                      }), undefined, this.ownSymbol)];\n                    case 6:\n                      _b.sent();\n                      _b.label = 7;\n                    case 7:\n                      return [3 /*break*/, 12];\n                    case 8:\n                      incomingConditionJSON = mutationEvent.condition;\n                      incomingCondition = JSON.parse(incomingConditionJSON);\n                      merged = void 0;\n                      if (!(Object.keys(incomingCondition).length === 0)) return [3 /*break*/, 10];\n                      merged = this.mergeUserFields(first, mutationEvent);\n                      // delete all for model\n                      return [4 /*yield*/, s.delete(this.MutationEvent, predicate)];\n                    case 9:\n                      // delete all for model\n                      _b.sent();\n                      _b.label = 10;\n                    case 10:\n                      merged = merged || mutationEvent;\n                      // Enqueue new one\n                      return [4 /*yield*/, s.save(merged, undefined, this.ownSymbol)];\n                    case 11:\n                      // Enqueue new one\n                      _b.sent();\n                      _b.label = 12;\n                    case 12:\n                      return [2 /*return*/];\n                  }\n                });\n              });\n            })];\n          case 1:\n            _a.sent();\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  MutationEventOutbox.prototype.dequeue = function (storage, record, recordOp) {\n    return __awaiter(this, void 0, void 0, function () {\n      var head;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, this.peek(storage)];\n          case 1:\n            head = _a.sent();\n            if (!record) return [3 /*break*/, 3];\n            return [4 /*yield*/, this.syncOutboxVersionsOnDequeue(storage, record, head, recordOp)];\n          case 2:\n            _a.sent();\n            _a.label = 3;\n          case 3:\n            return [4 /*yield*/, storage.delete(head)];\n          case 4:\n            _a.sent();\n            this.inProgressMutationEventId = undefined;\n            return [2 /*return*/, head];\n        }\n      });\n    });\n  };\n  /**\n   * Doing a peek() implies that the mutation goes \"inProgress\"\n   *\n   * @param storage\n   */\n  MutationEventOutbox.prototype.peek = function (storage) {\n    return __awaiter(this, void 0, void 0, function () {\n      var head;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, storage.queryOne(this.MutationEvent, QueryOne.FIRST)];\n          case 1:\n            head = _a.sent();\n            this.inProgressMutationEventId = head ? head.id : undefined;\n            return [2 /*return*/, head];\n        }\n      });\n    });\n  };\n  MutationEventOutbox.prototype.getForModel = function (storage, model, userModelDefinition) {\n    return __awaiter(this, void 0, void 0, function () {\n      var mutationEventModelDefinition, modelId, mutationEvents;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            mutationEventModelDefinition = this.schema.namespaces[SYNC].models.MutationEvent;\n            modelId = getIdentifierValue(userModelDefinition, model);\n            return [4 /*yield*/, storage.query(this.MutationEvent, ModelPredicateCreator.createFromAST(mutationEventModelDefinition, {\n              and: {\n                modelId: {\n                  eq: modelId\n                }\n              }\n            }))];\n          case 1:\n            mutationEvents = _a.sent();\n            return [2 /*return*/, mutationEvents];\n        }\n      });\n    });\n  };\n  MutationEventOutbox.prototype.getModelIds = function (storage) {\n    return __awaiter(this, void 0, void 0, function () {\n      var mutationEvents, result;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, storage.query(this.MutationEvent)];\n          case 1:\n            mutationEvents = _a.sent();\n            result = new Set();\n            mutationEvents.forEach(function (_a) {\n              var modelId = _a.modelId;\n              return result.add(modelId);\n            });\n            return [2 /*return*/, result];\n        }\n      });\n    });\n  };\n  // applies _version from the AppSync mutation response to other items\n  // in the mutation queue with the same id\n  // see https://github.com/aws-amplify/amplify-js/pull/7354 for more details\n  MutationEventOutbox.prototype.syncOutboxVersionsOnDequeue = function (storage, record, head, recordOp) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _version, _lastChangedAt, _deleted, _incomingData, incomingData, data, __version, __lastChangedAt, __deleted, _outgoingData, outgoingData, mutationEventModelDefinition, userModelDefinition, recordId, predicate, outdatedMutations, reconciledMutations;\n      var _this = this;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (head.operation !== recordOp) {\n              return [2 /*return*/];\n            }\n            _version = record._version, _lastChangedAt = record._lastChangedAt, _deleted = record._deleted, _incomingData = __rest(record, [\"_version\", \"_lastChangedAt\", \"_deleted\"]);\n            incomingData = this.removeTimestampFields(head.model, _incomingData);\n            data = JSON.parse(head.data);\n            if (!data) {\n              return [2 /*return*/];\n            }\n            __version = data._version, __lastChangedAt = data._lastChangedAt, __deleted = data._deleted, _outgoingData = __rest(data, [\"_version\", \"_lastChangedAt\", \"_deleted\"]);\n            outgoingData = this.removeTimestampFields(head.model, _outgoingData);\n            // Don't sync the version when the data in the response does not match the data\n            // in the request, i.e., when there's a handled conflict\n            //\n            // NOTE: `incomingData` contains all the fields in the record, and `outgoingData`\n            // only contains updated fields, resulting in an error when doing a comparison\n            // of two equal mutations. Fix this, or mitigate otherwise.\n            if (!valuesEqual(incomingData, outgoingData, true)) {\n              return [2 /*return*/];\n            }\n            mutationEventModelDefinition = this.schema.namespaces[SYNC].models['MutationEvent'];\n            userModelDefinition = this.schema.namespaces['user'].models[head.model];\n            recordId = getIdentifierValue(userModelDefinition, record);\n            predicate = ModelPredicateCreator.createFromAST(mutationEventModelDefinition, {\n              and: [{\n                modelId: {\n                  eq: recordId\n                }\n              }, {\n                id: {\n                  ne: this.inProgressMutationEventId\n                }\n              }]\n            });\n            return [4 /*yield*/, storage.query(this.MutationEvent, predicate)];\n          case 1:\n            outdatedMutations = _a.sent();\n            if (!outdatedMutations.length) {\n              return [2 /*return*/];\n            }\n            reconciledMutations = outdatedMutations.map(function (m) {\n              var oldData = JSON.parse(m.data);\n              var newData = __assign(__assign({}, oldData), {\n                _version: _version,\n                _lastChangedAt: _lastChangedAt\n              });\n              return _this.MutationEvent.copyOf(m, function (draft) {\n                draft.data = JSON.stringify(newData);\n              });\n            });\n            return [4 /*yield*/, storage.delete(this.MutationEvent, predicate)];\n          case 2:\n            _a.sent();\n            return [4 /*yield*/, Promise.all(reconciledMutations.map(function (m) {\n              return __awaiter(_this, void 0, void 0, function () {\n                return __generator(this, function (_a) {\n                  switch (_a.label) {\n                    case 0:\n                      return [4 /*yield*/, storage.save(m, undefined, this.ownSymbol)];\n                    case 1:\n                      return [2 /*return*/, _a.sent()];\n                  }\n                });\n              });\n            }))];\n          case 3:\n            _a.sent();\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  MutationEventOutbox.prototype.mergeUserFields = function (previous, current) {\n    var _a = JSON.parse(previous.data),\n      _version = _a._version,\n      _lastChangedAt = _a._lastChangedAt,\n      _deleted = _a._deleted,\n      previousData = __rest(_a, [\"_version\", \"_lastChangedAt\", \"_deleted\"]);\n    var _b = JSON.parse(current.data),\n      __version = _b._version,\n      __lastChangedAt = _b._lastChangedAt,\n      __deleted = _b._deleted,\n      currentData = __rest(_b, [\"_version\", \"_lastChangedAt\", \"_deleted\"]);\n    var data = JSON.stringify(__assign(__assign({\n      _version: _version,\n      _lastChangedAt: _lastChangedAt,\n      _deleted: _deleted\n    }, previousData), currentData));\n    return this.modelInstanceCreator(this.MutationEvent, __assign(__assign({}, current), {\n      data: data\n    }));\n  };\n  /*\n  if a model is using custom timestamp fields\n  the custom field names will be stored in the model attributes\n   e.g.\n  \"attributes\": [\n  {\n          \"type\": \"model\",\n          \"properties\": {\n              \"timestamps\": {\n                  \"createdAt\": \"createdOn\",\n                  \"updatedAt\": \"updatedOn\"\n              }\n          }\n  }\n  ]\n  */\n  MutationEventOutbox.prototype.removeTimestampFields = function (model, record) {\n    var _a, _b;\n    var CREATED_AT_DEFAULT_KEY = 'createdAt';\n    var UPDATED_AT_DEFAULT_KEY = 'updatedAt';\n    var createdTimestampKey = CREATED_AT_DEFAULT_KEY;\n    var updatedTimestampKey = UPDATED_AT_DEFAULT_KEY;\n    var modelAttributes = (_a = this.schema.namespaces[USER].models[model].attributes) === null || _a === void 0 ? void 0 : _a.find(function (attr) {\n      return attr.type === 'model';\n    });\n    var timestampFieldsMap = (_b = modelAttributes === null || modelAttributes === void 0 ? void 0 : modelAttributes.properties) === null || _b === void 0 ? void 0 : _b.timestamps;\n    if (timestampFieldsMap) {\n      createdTimestampKey = timestampFieldsMap[CREATED_AT_DEFAULT_KEY];\n      updatedTimestampKey = timestampFieldsMap[UPDATED_AT_DEFAULT_KEY];\n    }\n    delete record[createdTimestampKey];\n    delete record[updatedTimestampKey];\n    return record;\n  };\n  return MutationEventOutbox;\n}();\nexport { MutationEventOutbox };\n//# sourceMappingURL=outbox.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}