{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { __assign, __awaiter, __extends, __generator } from \"tslib\";\nimport { getInAppMessages } from '@aws-amplify/core/internals/aws-clients/pinpoint';\nimport { addEventListener, AWSPinpointProviderCommon } from '../../../common';\nimport SessionTracker from '../../SessionTracker';\nimport { InAppMessageInteractionEvent } from '../../types';\nimport { AWSPinpointMessageEvent } from './types';\nimport { clearMemo, dispatchInAppMessagingEvent, extractContent, extractMetadata, getStartOfDay, interpretLayout, isBeforeEndDate, logger, matchesAttributes, matchesEventType, matchesMetrics, recordAnalyticsEvent } from './utils';\nvar MESSAGE_DAILY_COUNT_KEY = 'pinpointProvider_inAppMessages_dailyCount';\nvar MESSAGE_TOTAL_COUNT_KEY = 'pinpointProvider_inAppMessages_totalCount';\nvar AWSPinpointProvider = /** @class */function (_super) {\n  __extends(AWSPinpointProvider, _super);\n  function AWSPinpointProvider() {\n    var _this = _super.call(this, logger) || this;\n    _this.configured = false;\n    _this.configure = function (config) {\n      if (config === void 0) {\n        config = {};\n      }\n      _this.config = __assign(__assign({}, _super.prototype.configure.call(_this, config)), {\n        endpointInfo: {\n          channelType: 'IN_APP'\n        }\n      });\n      // some configuration steps should not be re-run even if provider is re-configured for some reason\n      if (!_this.configured) {\n        _this.sessionTracker = new SessionTracker(_this.sessionStateChangeHandler);\n        _this.sessionTracker.start();\n        // wire up default Pinpoint message event handling\n        addEventListener(InAppMessageInteractionEvent.MESSAGE_DISPLAYED, function (message) {\n          _this.recordMessageEvent(message, AWSPinpointMessageEvent.MESSAGE_DISPLAYED);\n        });\n        addEventListener(InAppMessageInteractionEvent.MESSAGE_DISMISSED, function (message) {\n          _this.recordMessageEvent(message, AWSPinpointMessageEvent.MESSAGE_DISMISSED);\n        });\n        addEventListener(InAppMessageInteractionEvent.MESSAGE_ACTION_TAKEN, function (message) {\n          _this.recordMessageEvent(message, AWSPinpointMessageEvent.MESSAGE_ACTION_TAKEN);\n        });\n      }\n      _this.configured = true;\n      dispatchInAppMessagingEvent('pinpointProvider_configured', null);\n      return _this.config;\n    };\n    _this.getInAppMessages = function () {\n      return __awaiter(_this, void 0, void 0, function () {\n        var _a, appId, credentials, endpointId, region, input, response, messages, err_1;\n        return __generator(this, function (_b) {\n          switch (_b.label) {\n            case 0:\n              if (!!this.initialized) return [3 /*break*/, 2];\n              return [4 /*yield*/, this.init()];\n            case 1:\n              _b.sent();\n              _b.label = 2;\n            case 2:\n              // There is no way to granuarly reconcile the filter memoization as the keys are composited from a message id and\n              // event properties thus opting to just clear them out when getting messages rather than leave potentially\n              // obsolete entries that will no longer serve any purpose.\n              clearMemo();\n              _b.label = 3;\n            case 3:\n              _b.trys.push([3, 6,, 7]);\n              return [4 /*yield*/, this.updateEndpoint()];\n            case 4:\n              _b.sent();\n              _a = this.config, appId = _a.appId, credentials = _a.credentials, endpointId = _a.endpointId, region = _a.region;\n              input = {\n                ApplicationId: appId,\n                EndpointId: endpointId\n              };\n              this.logger.debug('getting in-app messages');\n              return [4 /*yield*/, getInAppMessages({\n                credentials: credentials,\n                region: region\n              }, input)];\n            case 5:\n              response = _b.sent();\n              messages = response.InAppMessagesResponse.InAppMessageCampaigns;\n              dispatchInAppMessagingEvent('getInAppMessages', messages);\n              return [2 /*return*/, messages];\n            case 6:\n              err_1 = _b.sent();\n              this.logger.error('Error getting in-app messages', err_1);\n              throw err_1;\n            case 7:\n              return [2 /*return*/];\n          }\n        });\n      });\n    };\n    _this.processInAppMessages = function (messages, event) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var highestPrioritySeen;\n        var _this = this;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              if (!!this.initialized) return [3 /*break*/, 2];\n              return [4 /*yield*/, this.init()];\n            case 1:\n              _a.sent();\n              _a.label = 2;\n            case 2:\n              return [2 /*return*/, this.normalizeMessages(messages.reduce(function (acc, message) {\n                var messageQualifies = matchesEventType(message, event) && matchesAttributes(message, event) && matchesMetrics(message, event) && isBeforeEndDate(message) && _this.isBelowCap(message);\n                // filter all qualifying messages returning only those that are of (relative) highest priority\n                if (messageQualifies) {\n                  // have not yet encountered message with priority\n                  if (!highestPrioritySeen) {\n                    // this message has priority, so reset the accumulator with this message only\n                    if (message.Priority) {\n                      highestPrioritySeen = message.Priority;\n                      return [message];\n                    } else {\n                      // this message also has no priority, so just add this message to accumulator\n                      acc.push(message);\n                    }\n                    // have previously encountered message with priority, so only messages with priority matter now\n                  } else if (message.Priority) {\n                    // this message has higher priority (lower number), so reset the accumulator with this message only\n                    if (message.Priority < highestPrioritySeen) {\n                      highestPrioritySeen = message.Priority;\n                      return [message];\n                      // this message has the same priority, so just add this message to accumulator\n                    } else if (message.Priority === highestPrioritySeen) {\n                      acc.push(message);\n                    }\n                  }\n                }\n                return acc;\n              }, []))];\n          }\n        });\n      });\n    };\n    _this.sessionStateChangeHandler = function (state) {\n      if (state === 'started') {\n        // reset all session counts\n        _this.sessionMessageCountMap = {};\n      }\n    };\n    _this.isBelowCap = function (_a) {\n      var CampaignId = _a.CampaignId,\n        SessionCap = _a.SessionCap,\n        DailyCap = _a.DailyCap,\n        TotalCap = _a.TotalCap;\n      var _b = _this.getMessageCounts(CampaignId),\n        sessionCount = _b.sessionCount,\n        dailyCount = _b.dailyCount,\n        totalCount = _b.totalCount;\n      return (!SessionCap || sessionCount < SessionCap) && (!DailyCap || dailyCount < DailyCap) && (!TotalCap || totalCount < TotalCap);\n    };\n    // Use the current session count in memory or initialize as empty count\n    _this.getSessionCount = function (messageId) {\n      return _this.sessionMessageCountMap[messageId] || 0;\n    };\n    _this.getDailyCount = function () {\n      var storage = _this.config.storage;\n      var today = getStartOfDay();\n      var item = storage.getItem(MESSAGE_DAILY_COUNT_KEY);\n      // Parse stored count or initialize as empty count\n      var counter = item ? JSON.parse(item) : {\n        count: 0,\n        lastCountTimestamp: today\n      };\n      // If the stored counter timestamp is today, use it as the count, otherwise reset to 0\n      return counter.lastCountTimestamp === today ? counter.count : 0;\n    };\n    _this.getTotalCountMap = function () {\n      var storage = _this.config.storage;\n      var item = storage.getItem(MESSAGE_TOTAL_COUNT_KEY);\n      // Parse stored count map or initialize as empty\n      return item ? JSON.parse(item) : {};\n    };\n    _this.getTotalCount = function (messageId) {\n      var countMap = _this.getTotalCountMap();\n      // Return stored count or initialize as empty count\n      return countMap[messageId] || 0;\n    };\n    _this.getMessageCounts = function (messageId) {\n      try {\n        return {\n          sessionCount: _this.getSessionCount(messageId),\n          dailyCount: _this.getDailyCount(),\n          totalCount: _this.getTotalCount(messageId)\n        };\n      } catch (err) {\n        _this.logger.error('Failed to get message counts from storage', err);\n      }\n    };\n    _this.setSessionCount = function (messageId, count) {\n      _this.sessionMessageCountMap[messageId] = count;\n    };\n    _this.setDailyCount = function (count) {\n      var storage = _this.config.storage;\n      var dailyCount = {\n        count: count,\n        lastCountTimestamp: getStartOfDay()\n      };\n      try {\n        storage.setItem(MESSAGE_DAILY_COUNT_KEY, JSON.stringify(dailyCount));\n      } catch (err) {\n        _this.logger.error('Failed to save daily message count to storage', err);\n      }\n    };\n    _this.setTotalCountMap = function (countMap) {\n      var storage = _this.config.storage;\n      try {\n        storage.setItem(MESSAGE_TOTAL_COUNT_KEY, JSON.stringify(countMap));\n      } catch (err) {\n        _this.logger.error('Failed to save total count to storage', err);\n      }\n    };\n    _this.setTotalCount = function (messageId, count) {\n      var _a;\n      var updatedMap = __assign(__assign({}, _this.getTotalCountMap()), (_a = {}, _a[messageId] = count, _a));\n      _this.setTotalCountMap(updatedMap);\n    };\n    _this.incrementCounts = function (messageId) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var _a, sessionCount, dailyCount, totalCount;\n        return __generator(this, function (_b) {\n          _a = this.getMessageCounts(messageId), sessionCount = _a.sessionCount, dailyCount = _a.dailyCount, totalCount = _a.totalCount;\n          this.setSessionCount(messageId, sessionCount + 1);\n          this.setDailyCount(dailyCount + 1);\n          this.setTotalCount(messageId, totalCount + 1);\n          return [2 /*return*/];\n        });\n      });\n    };\n    _this.normalizeMessages = function (messages) {\n      return messages.map(function (message) {\n        var CampaignId = message.CampaignId,\n          InAppMessage = message.InAppMessage;\n        return {\n          id: CampaignId,\n          content: extractContent(message),\n          layout: interpretLayout(InAppMessage.Layout),\n          metadata: extractMetadata(message)\n        };\n      });\n    };\n    _this.recordMessageEvent = function (message, event) {\n      return __awaiter(_this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              if (!!this.initialized) return [3 /*break*/, 2];\n              return [4 /*yield*/, this.init()];\n            case 1:\n              _a.sent();\n              _a.label = 2;\n            case 2:\n              recordAnalyticsEvent(event, message);\n              if (!(event === AWSPinpointMessageEvent.MESSAGE_DISPLAYED)) return [3 /*break*/, 4];\n              return [4 /*yield*/, this.incrementCounts(message.id)];\n            case 3:\n              _a.sent();\n              _a.label = 4;\n            case 4:\n              return [2 /*return*/];\n          }\n        });\n      });\n    };\n    _this.sessionMessageCountMap = {};\n    return _this;\n  }\n  /**\n   * get the sub-category of the plugin\n   */\n  AWSPinpointProvider.prototype.getSubCategory = function () {\n    return AWSPinpointProvider.subCategory;\n  };\n  AWSPinpointProvider.subCategory = 'InAppMessaging';\n  return AWSPinpointProvider;\n}(AWSPinpointProviderCommon);\nexport default AWSPinpointProvider;\n//# sourceMappingURL=index.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}