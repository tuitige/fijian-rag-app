{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nimport { withMemoization } from '@aws-amplify/core/internals/aws-client-utils';\nimport { ConsoleLogger as Logger } from '@aws-amplify/core';\nimport { SEND_DOWNLOAD_PROGRESS_EVENT, SEND_UPLOAD_PROGRESS_EVENT, ABORT_ERROR_CODE, ABORT_ERROR_MESSAGE, CANCELED_ERROR_CODE, CANCELED_ERROR_MESSAGE, NETWORK_ERROR_CODE, NETWORK_ERROR_MESSAGE } from './constants';\nvar logger = new Logger('xhr-http-handler');\n/**\n * Base transfer handler implementation using XMLHttpRequest to support upload and download progress events.\n *\n * @param request - The request object.\n * @param options - The request options.\n * @returns A promise that will be resolved with the response object.\n *\n * @internal\n */\nexport var xhrTransferHandler = function (request, options) {\n  var url = request.url,\n    method = request.method,\n    headers = request.headers,\n    body = request.body;\n  var emitter = options.emitter,\n    responseType = options.responseType,\n    abortSignal = options.abortSignal;\n  return new Promise(function (resolve, reject) {\n    var _a;\n    var xhr = new XMLHttpRequest();\n    xhr.open(method.toUpperCase(), url.toString());\n    Object.entries(headers).filter(function (_a) {\n      var _b = __read(_a, 1),\n        header = _b[0];\n      return !FORBIDDEN_HEADERS.includes(header);\n    }).forEach(function (_a) {\n      var _b = __read(_a, 2),\n        header = _b[0],\n        value = _b[1];\n      xhr.setRequestHeader(header, value);\n    });\n    xhr.responseType = responseType;\n    if (emitter) {\n      xhr.upload.addEventListener('progress', function (event) {\n        emitter.emit(SEND_UPLOAD_PROGRESS_EVENT, event);\n        logger.debug(event);\n      });\n      xhr.addEventListener('progress', function (event) {\n        emitter.emit(SEND_DOWNLOAD_PROGRESS_EVENT, event);\n        logger.debug(event);\n      });\n    }\n    xhr.addEventListener('error', function () {\n      var error = simulateAxiosError(NETWORK_ERROR_MESSAGE, NETWORK_ERROR_CODE, xhr, options);\n      logger.error(NETWORK_ERROR_MESSAGE);\n      reject(error);\n      xhr = null; // clean up request\n    });\n    // Handle browser request cancellation (as opposed to a manual cancellation)\n    xhr.addEventListener('abort', function () {\n      // The abort event can be triggered after the error or load event. So we need to check if the xhr is null.\n      if (!xhr || (abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.aborted)) return;\n      var error = simulateAxiosError(ABORT_ERROR_MESSAGE, ABORT_ERROR_CODE, xhr, options);\n      logger.error(ABORT_ERROR_MESSAGE);\n      reject(error);\n      xhr = null; // clean up request\n    });\n    // Skip handling timeout error since we don't have a timeout\n    xhr.addEventListener('readystatechange', function () {\n      if (!xhr || xhr.readyState !== xhr.DONE) {\n        return;\n      }\n      var onloadend = function () {\n        // The load event is triggered after the error/abort/load event. So we need to check if the xhr is null.\n        if (!xhr) return;\n        var responseHeaders = convertResponseHeaders(xhr.getAllResponseHeaders());\n        var responseType = xhr.responseType;\n        var responseBlob = xhr.response;\n        var responseText = responseType === 'text' ? xhr.responseText : '';\n        var bodyMixIn = {\n          blob: function () {\n            return Promise.resolve(responseBlob);\n          },\n          text: withMemoization(function () {\n            return responseType === 'blob' ? readBlobAsText(responseBlob) : Promise.resolve(responseText);\n          }),\n          json: function () {\n            return Promise.reject(\n            // S3 does not support JSON response. So fail-fast here with nicer error message.\n            new Error('Parsing response to JSON is not implemented. Please use response.text() instead.'));\n          }\n        };\n        var response = {\n          statusCode: xhr.status,\n          headers: responseHeaders,\n          // The xhr.responseType is only set to 'blob' for streaming binary S3 object data. The streaming data is\n          // exposed via public interface of Storage.get(). So we need to return the response as a Blob object for\n          // backward compatibility. In other cases, the response payload is only used internally, we return it is\n          // {@link ResponseBodyMixin}\n          body: xhr.responseType === 'blob' ? Object.assign(responseBlob, bodyMixIn) : bodyMixIn\n        };\n        resolve(response);\n        xhr = null; // clean up request\n      };\n      // readystate handler is calling before onerror or ontimeout handlers,\n      // so we should call onloadend on the next 'tick'\n      // @see https://github.com/axios/axios/blob/9588fcdec8aca45c3ba2f7968988a5d03f23168c/lib/adapters/xhr.js#L98-L99\n      setTimeout(onloadend);\n    });\n    if (abortSignal) {\n      var onCancelled = function () {\n        // The abort event is triggered after the error or load event. So we need to check if the xhr is null.\n        if (!xhr) {\n          return;\n        }\n        var canceledError = simulateAxiosCanceledError(CANCELED_ERROR_MESSAGE !== null && CANCELED_ERROR_MESSAGE !== void 0 ? CANCELED_ERROR_MESSAGE : abortSignal.reason, CANCELED_ERROR_CODE, xhr, options);\n        xhr.abort();\n        reject(canceledError);\n        xhr = null;\n      };\n      abortSignal.aborted ? onCancelled() : abortSignal.addEventListener('abort', onCancelled);\n    }\n    if (typeof ReadableStream === 'function' && body instanceof ReadableStream) {\n      // This does not matter as previous implementation uses Axios which does not support ReadableStream anyway.\n      throw new Error('ReadableStream request payload is not supported.');\n    }\n    xhr.send((_a = body) !== null && _a !== void 0 ? _a : null);\n  });\n};\n// TODO: V6 remove this\nvar simulateAxiosError = function (message, code, request, config) {\n  return Object.assign(new Error(message), {\n    code: code,\n    config: config,\n    request: request\n  });\n};\nvar simulateAxiosCanceledError = function (message, code, request, config) {\n  var error = simulateAxiosError(message, code, request, config);\n  error.name = 'CanceledError';\n  error['__CANCEL__'] = true;\n  return error;\n};\nexport var isCancelError = function (error) {\n  return !!(error === null || error === void 0 ? void 0 : error['__CANCEL__']);\n};\n/**\n * Convert xhr.getAllResponseHeaders() string to a Record<string, string>. Note that modern browser already returns\n * header names in lowercase.\n * @param xhrHeaders - string of headers returned from xhr.getAllResponseHeaders()\n */\nvar convertResponseHeaders = function (xhrHeaders) {\n  if (!xhrHeaders) {\n    return {};\n  }\n  return xhrHeaders.split('\\r\\n').reduce(function (headerMap, line) {\n    var parts = line.split(': ');\n    var header = parts.shift();\n    var value = parts.join(': ');\n    headerMap[header.toLowerCase()] = value;\n    return headerMap;\n  }, {});\n};\nvar readBlobAsText = function (blob) {\n  var reader = new FileReader();\n  return new Promise(function (resolve, reject) {\n    reader.onloadend = function () {\n      if (reader.readyState !== FileReader.DONE) {\n        return;\n      }\n      resolve(reader.result);\n    };\n    reader.onerror = function () {\n      reject(reader.error);\n    };\n    reader.readAsText(blob);\n  });\n};\n// To add more forbidden headers as found set by S3. Intentionally NOT list all of them here to save bundle size.\n// https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name\nvar FORBIDDEN_HEADERS = ['host'];","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}