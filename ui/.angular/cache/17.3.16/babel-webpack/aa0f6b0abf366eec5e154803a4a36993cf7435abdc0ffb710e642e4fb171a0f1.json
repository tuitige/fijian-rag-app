{"ast":null,"code":"import { __read } from \"tslib\";\nexport var parseBoolean = function (value) {\n  switch (value) {\n    case \"true\":\n      return true;\n    case \"false\":\n      return false;\n    default:\n      throw new Error(\"Unable to parse boolean value \\\"\".concat(value, \"\\\"\"));\n  }\n};\nexport var expectBoolean = function (value) {\n  if (value === null || value === undefined) {\n    return undefined;\n  }\n  if (typeof value === \"number\") {\n    if (value === 0 || value === 1) {\n      logger.warn(stackTraceWarning(\"Expected boolean, got \".concat(typeof value, \": \").concat(value)));\n    }\n    if (value === 0) {\n      return false;\n    }\n    if (value === 1) {\n      return true;\n    }\n  }\n  if (typeof value === \"string\") {\n    var lower = value.toLowerCase();\n    if (lower === \"false\" || lower === \"true\") {\n      logger.warn(stackTraceWarning(\"Expected boolean, got \".concat(typeof value, \": \").concat(value)));\n    }\n    if (lower === \"false\") {\n      return false;\n    }\n    if (lower === \"true\") {\n      return true;\n    }\n  }\n  if (typeof value === \"boolean\") {\n    return value;\n  }\n  throw new TypeError(\"Expected boolean, got \".concat(typeof value, \": \").concat(value));\n};\nexport var expectNumber = function (value) {\n  if (value === null || value === undefined) {\n    return undefined;\n  }\n  if (typeof value === \"string\") {\n    var parsed = parseFloat(value);\n    if (!Number.isNaN(parsed)) {\n      if (String(parsed) !== String(value)) {\n        logger.warn(stackTraceWarning(\"Expected number but observed string: \".concat(value)));\n      }\n      return parsed;\n    }\n  }\n  if (typeof value === \"number\") {\n    return value;\n  }\n  throw new TypeError(\"Expected number, got \".concat(typeof value, \": \").concat(value));\n};\nvar MAX_FLOAT = Math.ceil(Math.pow(2, 127) * (2 - Math.pow(2, -23)));\nexport var expectFloat32 = function (value) {\n  var expected = expectNumber(value);\n  if (expected !== undefined && !Number.isNaN(expected) && expected !== Infinity && expected !== -Infinity) {\n    if (Math.abs(expected) > MAX_FLOAT) {\n      throw new TypeError(\"Expected 32-bit float, got \".concat(value));\n    }\n  }\n  return expected;\n};\nexport var expectLong = function (value) {\n  if (value === null || value === undefined) {\n    return undefined;\n  }\n  if (Number.isInteger(value) && !Number.isNaN(value)) {\n    return value;\n  }\n  throw new TypeError(\"Expected integer, got \".concat(typeof value, \": \").concat(value));\n};\nexport var expectInt = expectLong;\nexport var expectInt32 = function (value) {\n  return expectSizedInt(value, 32);\n};\nexport var expectShort = function (value) {\n  return expectSizedInt(value, 16);\n};\nexport var expectByte = function (value) {\n  return expectSizedInt(value, 8);\n};\nvar expectSizedInt = function (value, size) {\n  var expected = expectLong(value);\n  if (expected !== undefined && castInt(expected, size) !== expected) {\n    throw new TypeError(\"Expected \".concat(size, \"-bit integer, got \").concat(value));\n  }\n  return expected;\n};\nvar castInt = function (value, size) {\n  switch (size) {\n    case 32:\n      return Int32Array.of(value)[0];\n    case 16:\n      return Int16Array.of(value)[0];\n    case 8:\n      return Int8Array.of(value)[0];\n  }\n};\nexport var expectNonNull = function (value, location) {\n  if (value === null || value === undefined) {\n    if (location) {\n      throw new TypeError(\"Expected a non-null value for \".concat(location));\n    }\n    throw new TypeError(\"Expected a non-null value\");\n  }\n  return value;\n};\nexport var expectObject = function (value) {\n  if (value === null || value === undefined) {\n    return undefined;\n  }\n  if (typeof value === \"object\" && !Array.isArray(value)) {\n    return value;\n  }\n  var receivedType = Array.isArray(value) ? \"array\" : typeof value;\n  throw new TypeError(\"Expected object, got \".concat(receivedType, \": \").concat(value));\n};\nexport var expectString = function (value) {\n  if (value === null || value === undefined) {\n    return undefined;\n  }\n  if (typeof value === \"string\") {\n    return value;\n  }\n  if ([\"boolean\", \"number\", \"bigint\"].includes(typeof value)) {\n    logger.warn(stackTraceWarning(\"Expected string, got \".concat(typeof value, \": \").concat(value)));\n    return String(value);\n  }\n  throw new TypeError(\"Expected string, got \".concat(typeof value, \": \").concat(value));\n};\nexport var expectUnion = function (value) {\n  if (value === null || value === undefined) {\n    return undefined;\n  }\n  var asObject = expectObject(value);\n  var setKeys = Object.entries(asObject).filter(function (_a) {\n    var _b = __read(_a, 2),\n      v = _b[1];\n    return v != null;\n  }).map(function (_a) {\n    var _b = __read(_a, 1),\n      k = _b[0];\n    return k;\n  });\n  if (setKeys.length === 0) {\n    throw new TypeError(\"Unions must have exactly one non-null member. None were found.\");\n  }\n  if (setKeys.length > 1) {\n    throw new TypeError(\"Unions must have exactly one non-null member. Keys \".concat(setKeys, \" were not null.\"));\n  }\n  return asObject;\n};\nexport var strictParseDouble = function (value) {\n  if (typeof value == \"string\") {\n    return expectNumber(parseNumber(value));\n  }\n  return expectNumber(value);\n};\nexport var strictParseFloat = strictParseDouble;\nexport var strictParseFloat32 = function (value) {\n  if (typeof value == \"string\") {\n    return expectFloat32(parseNumber(value));\n  }\n  return expectFloat32(value);\n};\nvar NUMBER_REGEX = /(-?(?:0|[1-9]\\d*)(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)|(-?Infinity)|(NaN)/g;\nvar parseNumber = function (value) {\n  var matches = value.match(NUMBER_REGEX);\n  if (matches === null || matches[0].length !== value.length) {\n    throw new TypeError(\"Expected real number, got implicit NaN\");\n  }\n  return parseFloat(value);\n};\nexport var limitedParseDouble = function (value) {\n  if (typeof value == \"string\") {\n    return parseFloatString(value);\n  }\n  return expectNumber(value);\n};\nexport var handleFloat = limitedParseDouble;\nexport var limitedParseFloat = limitedParseDouble;\nexport var limitedParseFloat32 = function (value) {\n  if (typeof value == \"string\") {\n    return parseFloatString(value);\n  }\n  return expectFloat32(value);\n};\nvar parseFloatString = function (value) {\n  switch (value) {\n    case \"NaN\":\n      return NaN;\n    case \"Infinity\":\n      return Infinity;\n    case \"-Infinity\":\n      return -Infinity;\n    default:\n      throw new Error(\"Unable to parse float value: \".concat(value));\n  }\n};\nexport var strictParseLong = function (value) {\n  if (typeof value === \"string\") {\n    return expectLong(parseNumber(value));\n  }\n  return expectLong(value);\n};\nexport var strictParseInt = strictParseLong;\nexport var strictParseInt32 = function (value) {\n  if (typeof value === \"string\") {\n    return expectInt32(parseNumber(value));\n  }\n  return expectInt32(value);\n};\nexport var strictParseShort = function (value) {\n  if (typeof value === \"string\") {\n    return expectShort(parseNumber(value));\n  }\n  return expectShort(value);\n};\nexport var strictParseByte = function (value) {\n  if (typeof value === \"string\") {\n    return expectByte(parseNumber(value));\n  }\n  return expectByte(value);\n};\nvar stackTraceWarning = function (message) {\n  return String(new TypeError(message).stack || message).split(\"\\n\").slice(0, 5).filter(function (s) {\n    return !s.includes(\"stackTraceWarning\");\n  }).join(\"\\n\");\n};\nexport var logger = {\n  warn: console.warn\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}