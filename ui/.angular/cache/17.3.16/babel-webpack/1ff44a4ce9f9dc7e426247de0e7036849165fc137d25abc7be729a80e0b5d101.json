{"ast":null,"code":"import { __assign, __read } from \"tslib\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport booleanClockwise from '@turf/boolean-clockwise';\nexport function validateCoordinates(lng, lat) {\n  if (!Number.isFinite(lng) || !Number.isFinite(lat)) {\n    throw new Error(\"Invalid coordinates: [\" + lng + \",\" + lat + \"]\");\n  }\n  if (lat < -90 || 90 < lat) {\n    throw new Error('Latitude must be between -90 and 90 degrees inclusive.');\n  } else if (lng < -180 || 180 < lng) {\n    throw new Error('Longitude must be between -180 and 180 degrees inclusive.');\n  }\n}\nexport function validateGeofenceId(geofenceId) {\n  var geofenceIdRegex = /^[-._\\p{L}\\p{N}]+$/iu;\n  // Check if geofenceId is valid\n  if (!geofenceIdRegex.test(geofenceId)) {\n    throw new Error(\"Invalid geofenceId: '\" + geofenceId + \"' - IDs can only contain alphanumeric characters, hyphens, underscores and periods.\");\n  }\n}\nexport function validateLinearRing(linearRing, geofenceId) {\n  var errorPrefix = geofenceId ? geofenceId + \": \" : '';\n  // Validate LinearRing size, must be at least 4 points\n  if (linearRing.length < 4) {\n    throw new Error(errorPrefix + \"LinearRing must contain 4 or more coordinates.\");\n  }\n  // Validate all coordinates are valid, error with which ones are bad\n  var badCoordinates = [];\n  linearRing.forEach(function (coordinates) {\n    try {\n      validateCoordinates(coordinates[0], coordinates[1]);\n    } catch (error) {\n      badCoordinates.push({\n        coordinates: coordinates,\n        error: error.message\n      });\n    }\n  });\n  if (badCoordinates.length > 0) {\n    throw new Error(errorPrefix + \"One or more of the coordinates in the Polygon LinearRing are not valid: \" + JSON.stringify(badCoordinates));\n  }\n  // Validate first and last coordinates are the same\n  var _a = __read(linearRing[0], 2),\n    lngA = _a[0],\n    latA = _a[1];\n  var _b = __read(linearRing[linearRing.length - 1], 2),\n    lngB = _b[0],\n    latB = _b[1];\n  if (lngA !== lngB || latA !== latB) {\n    throw new Error(errorPrefix + \"LinearRing's first and last coordinates are not the same\");\n  }\n  if (booleanClockwise(linearRing)) {\n    throw new Error(errorPrefix + \"LinearRing coordinates must be wound counterclockwise\");\n  }\n}\nexport function validatePolygon(polygon, geofenceId) {\n  var errorPrefix = geofenceId ? geofenceId + \": \" : '';\n  if (!Array.isArray(polygon)) {\n    throw new Error(errorPrefix + \"Polygon is of incorrect structure. It should be an array of LinearRings\");\n  }\n  if (polygon.length < 1) {\n    throw new Error(errorPrefix + \"Polygon must have a single LinearRing array.\");\n  }\n  if (polygon.length > 1) {\n    throw new Error(errorPrefix + \"Polygon must have a single LinearRing array. Note: We do not currently support polygons with holes, multipolygons, polygons that are wound clockwise, or that cross the antimeridian.\");\n  }\n  var verticesCount = polygon.reduce(function (prev, linearRing) {\n    return prev + linearRing.length;\n  }, 0);\n  if (verticesCount > 1000) {\n    throw new Error(errorPrefix + \"Polygon has more than the maximum 1000 vertices.\");\n  }\n  polygon.forEach(function (linearRing) {\n    validateLinearRing(linearRing, geofenceId);\n  });\n}\nexport function validateGeofencesInput(geofences) {\n  var geofenceIds = {};\n  geofences.forEach(function (geofence) {\n    // verify all required properties are present\n    // Validate geofenceId exists\n    if (!geofence.geofenceId) {\n      throw new Error(\"Geofence '\" + geofence + \"' is missing geofenceId\");\n    }\n    var geofenceId = geofence.geofenceId;\n    validateGeofenceId(geofenceId);\n    // Validate geofenceId is unique\n    if (geofenceIds[geofenceId]) {\n      throw new Error(\"Duplicate geofenceId: \" + geofenceId);\n    } else {\n      geofenceIds[geofenceId] = true;\n    }\n    // Validate geometry exists\n    if (!geofence.geometry) {\n      throw new Error(\"Geofence '\" + geofenceId + \"' is missing geometry\");\n    }\n    var geometry = geofence.geometry;\n    // Validate polygon exists\n    if (!geometry.polygon) {\n      throw new Error(\"Geofence '\" + geofenceId + \"' is missing geometry.polygon\");\n    }\n    var polygon = geometry.polygon;\n    // Validate polygon length and structure\n    try {\n      validatePolygon(polygon, geofenceId);\n    } catch (error) {\n      if (error.message.includes('Polygon has more than the maximum 1000 vertices.')) {\n        throw new Error(\"Geofence '\" + geofenceId + \"' has more than the maximum of 1000 vertices\");\n      }\n    }\n    // Validate LinearRing length, structure, and coordinates\n    var _a = __read(polygon, 1),\n      linearRing = _a[0];\n    validateLinearRing(linearRing, geofenceId);\n  });\n}\nexport function mapSearchOptions(options, locationServiceInput) {\n  var locationServiceModifiedInput = __assign({}, locationServiceInput);\n  locationServiceModifiedInput.FilterCountries = options.countries;\n  locationServiceModifiedInput.MaxResults = options.maxResults;\n  if (options.searchIndexName) {\n    locationServiceModifiedInput.IndexName = options.searchIndexName;\n  }\n  if (options['biasPosition'] && options['searchAreaConstraints']) {\n    throw new Error('BiasPosition and SearchAreaConstraints are mutually exclusive, please remove one or the other from the options object');\n  }\n  if (options['biasPosition']) {\n    locationServiceModifiedInput.BiasPosition = options['biasPosition'];\n  }\n  if (options['searchAreaConstraints']) {\n    locationServiceModifiedInput.FilterBBox = options['searchAreaConstraints'];\n  }\n  return locationServiceModifiedInput;\n}\n//# sourceMappingURL=util.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}